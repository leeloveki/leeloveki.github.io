<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习路线_准备面试</title>
    <link href="/2022/11/08/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2022/11/08/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>学习路线, 每天要抓紧进度</p><ol><li><p>做项目</p></li><li><p><del>算法</del></p><ul><li><input disabled="" type="checkbox"> <a href="https://www.geeksforgeeks.org/introduction-to-algorithms/?ref=lbp">算法导论 - 极客 (geeksforgeeks.org)</a></li><li><input disabled="" type="checkbox"> 每天刷5道leetcode题目(搜索大厂面经, 根据面接刷对应的算法题)</li><li><input disabled="" type="checkbox"> 动态编程问题(DP)</li><li><input disabled="" type="checkbox"> 排序算法<ul><li><input disabled="" type="checkbox"> 二分查找</li><li><input disabled="" type="checkbox"> 快速排序</li><li><input disabled="" type="checkbox"> 缓存淘汰算法(LRU)</li></ul></li></ul></li><li><p>数据结构 </p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://www.geeksforgeeks.org/data-structures/?ref=lbp">Data Structures - GeeksforGeeks</a></li></ul></li><li><p>Java基础知识</p><ul><li><input checked="" disabled="" type="checkbox"> 疯狂java</li><li><input disabled="" type="checkbox"> <a href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html#%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86">Java 全栈知识体系 (pdai.tech)</a></li><li><input disabled="" type="checkbox"> <a href="file://C:/Users/libolon/Downloads/notejava/JavaGuide面试突击版-V4.0.pdf">Java Guide面试突击版-V4.0.pdf</a></li></ul></li><li><p>计算机通用知识</p><ul><li><input disabled="" type="checkbox"> <a href="https://github.com/leeloveki/java_note/blob/main/Java%E5%BC%80%E5%8F%91%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0.md">java_note&#x2F;Java开发一轮复习</a></li><li><input disabled="" type="checkbox"> <a href="https://github.com/CyC2018/CS-Notes">CS-Notes： 技术面试必备基础知识</a></li><li><input disabled="" type="checkbox"> 计算机网络</li><li><input disabled="" type="checkbox"> Linux基础知识</li></ul></li><li><p>Spring</p><ul><li><input disabled="" type="checkbox"> 源码</li><li><input disabled="" type="checkbox"> 原理</li><li><input disabled="" type="checkbox"> 特点</li><li><input disabled="" type="checkbox"> 面试高频题</li><li><input disabled="" type="checkbox"> Spring boot</li><li><input disabled="" type="checkbox"> Spring cloud</li></ul></li><li><p>数据库</p><ul><li><input checked="" disabled="" type="checkbox"> mysql</li><li><input checked="" disabled="" type="checkbox"> sql面试题</li><li><input checked="" disabled="" type="checkbox"> sql基础</li></ul></li><li><p>可以看下</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/Snailclimb/JavaGuide">JavaGuide 面试 全面版</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.bilibili.com/read/cv9965357/">2022黑马程序员Java学习路线图 把握下要学的总路线</a></li></ul></li></ol><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>要记住的话</p><ol><li>深挖项目亮点</li><li>算法和基础要打扎实</li><li>做项目时要有自己的知识沉淀, 将基础 原理 细节 难点写成笔记 并掌握通透</li><li>尽量进有成熟项目的公司</li></ol><p>参考资料:</p><ol><li><a href="https://github.com/pure-xiaojie/JavaInterview">pure-xiaojie&#x2F;JavaInterview: Java开发面试题整理含答案（计网、Java、操作系统、数据库、框架） (github.com)</a></li><li><a href="https://www.nowcoder.com/discuss/472041?channel=1009&source_id=home_feed">Java开发面试题整理含答案（计网、Java、数据库、框架）_笔经面经_牛客网 (nowcoder.com)</a></li><li><a href="https://www.zhihu.com/question/25034235/answer/793756187">自学4个月，转行1年，入职字节 自学编程的人，都是怎么找到第一份软件开发工作的？</a></li></ol><h1 id="算法学习路线"><a href="#算法学习路线" class="headerlink" title="算法学习路线"></a>算法学习路线</h1><p>重点掌握常考的排序算法</p><p>掌握冒泡、堆排、归并、桶排、快排，尤其是归并，归并的思想在后面刷算法题中经常用到，桶排也是如此，空间换时间的思想在算法中很常见。这些排序算法请能够理解并且默写，知道他们的时间和空间复杂度，这些是基础，必须掌握。</p><h2 id="解决问题的思路"><a href="#解决问题的思路" class="headerlink" title="解决问题的思路"></a>解决问题的思路</h2><p>debug</p><p>看服务器日志 sql日志</p><p>重新审视需求</p><p>看官网文档</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>软件测试</title>
    <link href="/2022/11/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/11/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><p>一般的软件测试顺序为: 单元测试-&gt;集成测试-&gt;系统测试-&gt;验收测试</p><p>一般开发人员只需要进行单元测试</p><p>后面的三个测试步骤由专门的测试负责</p><p>测试按照是否依赖工具&#x2F;框架分为自动测试和手动测试</p><p>按照测试的可观测程度分为</p><ol><li>黑盒测试: 代码对于测试人员不可见</li><li>白盒测试: 代码对于测试人员可见</li><li>灰盒测试: 测试人员可以看到部分代码&#x2F;结构</li></ol><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试又被称为模块测试, 是针对程序的最小单元进行正确性检验的测试,确保单元的行为符合预期, 检测单元是否存在问题</p><blockquote><p>最小单元指方法&#x2F;函数</p></blockquote><p>单元测试通常是开发工程师进行的自测</p><p>单元测试的流程:</p><p><img src="/2022/11/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/image-20221102170108838.png" alt="image-20221102170108838"></p><blockquote><p>创建测试用例 检查用例 确定方法的行为基准 执行测试用例</p></blockquote><p>JUnit是一个java的单元测试框架, 基于先测试后编码的理念</p><p>Juint单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> calculator.calculator;<br><span class="hljs-keyword">import</span> org.junit.Assert;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">calculatorTest</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *  测试add方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span><br>    &#123;<br>         calculator c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">calculator</span>();<br>         <span class="hljs-comment">//调用add方法</span><br>        <span class="hljs-type">int</span> ret=c.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//用断言判断方法输出是否符合预期</span><br>        Assert.assertEquals(<span class="hljs-number">3</span>,ret);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>集成测试是对两个模块间的接口进行测试, 确保界面的正确性</p><p>集成测试一般用于检查两个模块间的交互(接口)是否存在问题</p><table><thead><tr><th>单元测试</th><th>集成测试</th></tr></thead><tbody><tr><td>对每个模块进行单独测试</td><td>对多个模块进行组合(接口)测试</td></tr><tr><td>白盒</td><td>黑盒</td></tr><tr><td>开发自测</td><td>专门的测试进行</td></tr><tr><td>问题定位难度低</td><td>问题定位难度高</td></tr><tr><td>维护成本低</td><td>维护成本高</td></tr><tr><td>速度快</td><td>速度慢</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>向上转型</title>
    <link href="/2022/11/08/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/"/>
    <url>/2022/11/08/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h1><p>由于子类实质上是特殊的父类, 因此子类对象可以直接赋值给父类引用变量, 这时不会发生任何类型转换, 系统会自动完成 向上转型(upcasting)</p><p>Object类是接口类的唯一间接父类</p><p>可以用向上转型将接口类型引用变量赋予Object类型引用变量</p><p><strong>向上转型如果发生在引用类型间, 需要两个操作数为继承关系</strong></p><p><strong>基本数据类型的自动转型也是向上转型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Son s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>Father f=s;<br></code></pre></td></tr></table></figure><p>上述代码实现了引用类型的向上转换</p><ol><li>向上转型: 父类类型引用变量指向子类对象, 接口类型引用变量指向子类对象</li><li>向下转型: 子类类型引用变量指向父类对象</li></ol><h1 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h1><p>Java中通过强制转换来实现向下转型</p><p>基本数据类型的向下转型会导致部分数据丢失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Father f=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br>Son s=(Son)f;<br></code></pre></td></tr></table></figure><p>上述代码实现了引用类型的向下转换</p><h1 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Father f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br>Son s1=(Son)f1;<br><span class="hljs-comment">//上述代码会抛出java.lang.ClassCastException错误</span><br>Son s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>Father fs=(Father)s2;<br><span class="hljs-comment">//正确的多态实现</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br><span class="hljs-keyword">if</span> (f1 <span class="hljs-keyword">instanceof</span> Son) &#123;<br>    <span class="hljs-type">Son</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Son) f1;<br>&#125;<br><span class="hljs-comment">//可以用instanceof运算符来判断是否可以成功转换, 避免抛出ClassCastException错误</span><br><span class="hljs-comment">//上述if判断将为false, 不会执行代码块里面的内容</span><br></code></pre></td></tr></table></figure><p>instanceof运算符: 当前面的操作数是后面操作数的同一个类 子类 实现类的实例则返回true, 否则返回false</p><p>要求前面的操作数为实例&#x2F;对象, 后面的操作数为类</p><p>instanceof运算符一般与(type)强制转换符配合使用, 先用instanceof判断是否可以进行强制转换, 再用强制类型转换符进行转换, 保证代码的健壮性</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>Java中的引用变量同时有两个类型: 编译时类型 运行时类型</p><p>编译时类型由声明时使用的类型决定</p><p>运行时类型由该变量指向的对象决定</p><p>当编译时类型与运行时类型不同时, 就可能出现多态</p><p>多态是什么:将父类类型变量指向其子类对象</p><p>多态的特征: 同类型的变量, 调用同一方法时出现不同的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">FatherClass polymophicVar=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SonClass</span>();<br></code></pre></td></tr></table></figure><p>它的编译类型为FatherClass 运行类型是SonClass</p><p>当使用polymophicVar调用子类中覆盖了父类的方法时, 会出现多态</p><p>注意: ploymophicVar只能调用父类中的存在方法, 调用方法时会表现出子类中覆盖方法的行为 </p><blockquote><p>可以通过反射来执行子类中的方法</p></blockquote><blockquote><p>由于子类实质上是特殊的父类, 因此子类对象可以直接赋值给父类引用变量, 这时不会发生任何类型转换, 系统会自动完成 向上转型(upcasting)</p></blockquote><blockquote><p>注意实例变量没有多态性, 用ploymophicVar只能调用父类中的实例变量, 不能调用子类中的实例变量</p></blockquote><blockquote><p>本质是引用变量只能调用其编译时类型具有的方法, 但是在运行方法时会优先执行它运行时类型里面的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>(<span class="hljs-type">double</span>)a;<br></code></pre></td></tr></table></figure><p>上述代码使用了强制类型转换符将a变量从int类型转换为double类型</p><p>使用强制类型转换时注意:</p><p>基本数据类型只能在整数型 字符型 浮点型之间进行相互转换, 布尔类型无法转换</p><p>引用类型的转换只能在具有继承关系的两个类型间进行</p><blockquote><p>将父类类型实例强制转换成子类类型时, 其运行时类型必须是子类类型, 否则会发生ClassCastException错误</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring面试题</title>
    <link href="/2022/11/08/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/11/08/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring面试题"><a href="#Spring面试题" class="headerlink" title="Spring面试题"></a>Spring面试题</h1><h2 id="面试题一：Spring是什么"><a href="#面试题一：Spring是什么" class="headerlink" title="面试题一：Spring是什么?"></a>面试题一：Spring是什么?</h2><p>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。主要包括以下七个模块：</p><p>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p><p>Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务；</p><p>Spring AOP：AOP服务；</p><p>Spring Web：提供了基本的面向Web的综合特性，提供对常见框架如Struts2的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器；</p><p>Spring MVC：提供面向Web应用的Model-View-Controller，即MVC实现。</p><p>Spring DAO：对JDBC的抽象封装，简化了数据访问异常的处理，并能统一管理JDBC事务；</p><p>Spring ORM：对现有的ORM框架的支持；</p><h2 id="面试题二：说说Spring-的优点？"><a href="#面试题二：说说Spring-的优点？" class="headerlink" title="面试题二：说说Spring 的优点？"></a>面试题二：说说Spring 的优点？</h2><p>spring属于低侵入式设计，代码的污染极低；</p><p>spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p><p>Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p><p>spring对于主流的应用框架提供了集成支持。</p><h2 id="面试题三：谈谈你对Spring的IOC理解？"><a href="#面试题三：谈谈你对Spring的IOC理解？" class="headerlink" title="面试题三：谈谈你对Spring的IOC理解？"></a>面试题三：谈谈你对Spring的IOC理解？</h2><p>IOC，Inversion of Control，控制反转，指将对象的控制权转移给Spring框架，由 Spring 来负责控制对象的生命周期（比如创建、销毁）和对象间的依赖关系。</p><p>最直观的表达就是，以前创建对象的时机和主动权都是由自己把控的，如果在一个对象中使用另外的对象，就必须主动通过new指令去创建依赖对象，使用完后还需要销毁（比如Connection等），对象始终会和其他接口或类耦合起来。而 IOC 则是由专门的容器来帮忙创建对象，将所有的类都在 Spring 容器中登记，当需要某个对象时，不再需要自己主动去 new 了，只需告诉 Spring 容器，然后 Spring 就会在系统运行到适当的时机，把你想要的对象主动给你。也就是说，对于某个具体的对象而言，以前是由自己控制它所引用对象的生命周期，而在IOC中，所有的对象都被 Spring 控制，控制对象生命周期的不再是引用它的对象，而是Spring容器，由 Spring 容器帮我们创建、查找及注入依赖对象，而引用对象只是被动的接受依赖对象，所以这叫控制反转。</p><h2 id="面试题四：说说你对Spring的AOP理解？"><a href="#面试题四：说说你对Spring的AOP理解？" class="headerlink" title="面试题四：说说你对Spring的AOP理解？"></a>面试题四：说说你对Spring的AOP理解？</h2><p>AOP(Aspect-OrientedProgramming)，也就是面向切面编程。也可以这样理解，学java的应该都知道面向对象编程（oop），而OOP是从静态解读考虑程序结构，但AOP是从动态角度考虑程序运行过程。也可以说AOP是OOP的补充和完善。OOP引入了封装、继承和多态性等概念来建立一种对象层次结构， 用以模拟公共的一个集合。当我们需要为分散的对象引入公共行为的时候，则OOP显得无能为力了。也就是说，OOP允许你定义从上到下的关系，但并不适合从左到右的关系，例如日志功能。日志代码往往水平的散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切代码，在oop设计中，他导致了大量代码的重复，而不利于各个模块的重用。</p><p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将哪些影响了多个类的公共行为封装到一个可重用模块，并将其名为’Aspect’(方面)。 所谓”方面”，简单的来说就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来。便于减少系统的重复代码，降低模块间的耦合度等。</p><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取信息的方式，对该信息进行装饰，以取代鱼油对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</p><h2 id="面试题五：Spring-AOP里面常用名词的概念："><a href="#面试题五：Spring-AOP里面常用名词的概念：" class="headerlink" title="面试题五：Spring AOP里面常用名词的概念："></a>面试题五：Spring AOP里面常用名词的概念：</h2><p>（1）连接点（Join point）：指程序运行过程中所执行的方法。在Spring AOP中，一个连接点总代表一个方法的执行。</p><p>（2）切面（Aspect）：被抽取出来的公共模块，可以用来会横切多个对象。Aspect切面可以看成 Pointcut切点 和 Advice通知 的结合，一个切面可以由多个切点和通知组成。</p><p>在Spring AOP中，切面可以在类上使用 @AspectJ 注解来实现。</p><p>（3）切点（Pointcut）：切点用于定义 要对哪些Join point进行拦截。</p><p>切点分为execution方式和annotation方式。execution方式可以用路径表达式指定对哪些方法拦截，比如指定拦截add<em>、search</em>。annotation方式可以指定被哪些注解修饰的代码进行拦截。</p><p>（4）通知（Advice）：指要在连接点（Join Point）上执行的动作，即增强的逻辑，比如权限校验和、日志记录等。通知有各种类型，包括Around、Before、After、After returning、After throwing。</p><p>（5）目标对象（Target）：包含连接点的对象，也称作被通知（Advice）的对象。 由于Spring AOP是通过动态代理实现的，所以这个对象永远是一个代理对象。</p><p>（6）织入（Weaving）：通过动态代理，在目标对象（Target）的方法（即连接点Join point）中执行增强逻辑（Advice）的过程。</p><p>（7）引入（Introduction）：添加额外的方法或者字段到被通知的类。Spring允许引入新的接口（以及对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p><p>几个概念的关系图可以参考下图：</p><p><img src="/2022/11/08/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220803154736444.png" alt="image-20220803154736444"></p><h2 id="面试题六：Spring容器的启动流程？"><a href="#面试题六：Spring容器的启动流程？" class="headerlink" title="面试题六：Spring容器的启动流程？"></a>面试题六：Spring容器的启动流程？</h2><p>（1）初始化Spring容器，注册内置的BeanPostProcessor的BeanDefinition到容器中。</p><p>（2）将配置类的BeanDefinition注册到容器中。</p><p>（3）调用refresh()方法刷新容器。</p><h2 id="面试题七：Spring-Bean的生命周期？"><a href="#面试题七：Spring-Bean的生命周期？" class="headerlink" title="面试题七：Spring Bean的生命周期？"></a>面试题七：Spring Bean的生命周期？</h2><p>实例化 Instantiation –&gt; 属性赋值 Populate –&gt; 初始化 Initialization –&gt; 销毁 Destruction</p><h2 id="面试题八：说一下Spring中bean的作用域？"><a href="#面试题八：说一下Spring中bean的作用域？" class="headerlink" title="面试题八：说一下Spring中bean的作用域？"></a>面试题八：说一下Spring中bean的作用域？</h2><p>（1）singleton：默认作用域，单例bean，每个容器中只有一个bean的实例。</p><p>（2）prototype：为每一个bean请求创建一个实例。</p><p>（3）request：为每一个request请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p><p>（4）session：与request范围类似，同一个session会话共享一个实例，不同会话使用不同的实例。</p><p>（5）global-session：全局作用域，所有会话共享一个实例。如果想要声明让所有会话共享的存储变量的话，那么这全局变量需要存储在global-session中。</p><h2 id="面试题九：说一下Spring基于xml注入bean的几种方式"><a href="#面试题九：说一下Spring基于xml注入bean的几种方式" class="headerlink" title="面试题九：说一下Spring基于xml注入bean的几种方式?"></a>面试题九：说一下Spring基于xml注入bean的几种方式?</h2><p>set()方法注入；</p><p>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p><p>静态工厂注入；</p><p>实例工厂；</p><h2 id="面试题十：Spring如何解决循环依赖问题？"><a href="#面试题十：Spring如何解决循环依赖问题？" class="headerlink" title="面试题十：Spring如何解决循环依赖问题？"></a>面试题十：Spring如何解决循环依赖问题？</h2><p>循环依赖问题在Spring中主要有三种情况：</p><p>（1）通过构造方法进行依赖注入时产生的循环依赖问题。</p><p>（2）通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</p><p>（3）通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</p><p>在Spring中，只有第（3）种方式的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。这是因为：</p><p>第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。</p><p>第二种setter方法（多例）的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。</p><p>Spring在单例模式下的setter方法依赖注入引起的循环依赖问题，主要是通过二级缓存和三级缓存来解决的，其中三级缓存是主要功臣。解决的核心原理就是：在对象实例化之后，依赖注入之前，Spring提前暴露的Bean实例的引用在第三级缓存中进行存储。</p><h2 id="面试题十一：谈一下Spring的自动装配"><a href="#面试题十一：谈一下Spring的自动装配" class="headerlink" title="面试题十一：谈一下Spring的自动装配?"></a>面试题十一：谈一下Spring的自动装配?</h2><p>在spring中，使用autowire来配置自动装载模式，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。</p><p>（1）在Spring框架xml配置中共有5种自动装配：</p><p>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p><p>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</p><p>byType：通过参数的数据类型进行自动装配。</p><p>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p><p>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p><p>（2）基于注解的自动装配方式：</p><p>使用@Autowired、@Resource注解来自动装配指定的bean。</p><p>在使用@Autowired注解之前需要在Spring配置文件进行配置。</p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。</p><p>在使用@Autowired时，首先在容器中查询对应类型的bean：</p><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</p><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>注：@Autowired和@Resource之间的区别：</p><p>(1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>(2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p><h2 id="面试题十二：Spring框架中都用到了哪些设计模式？"><a href="#面试题十二：Spring框架中都用到了哪些设计模式？" class="headerlink" title="面试题十二：Spring框架中都用到了哪些设计模式？"></a>面试题十二：Spring框架中都用到了哪些设计模式？</h2><p>（1）工厂模式：Spring使用工厂模式，通过BeanFactory和ApplicationContext来创建对象</p><p>（2）单例模式：Bean默认为单例模式</p><p>（3）策略模式：例如Resource的实现类，针对不同的资源文件，实现了不同方式的资源获取策略</p><p>（4）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术</p><p>（5）模板方法：可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中，用来解决代码重复的问题。比如RestTemplate, JmsTemplate, JpaTemplate</p><p>（6）适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式，Spring MVC中也是用到了适配器模式适配Controller</p><p>（7）观察者模式：Spring事件驱动模型就是观察者模式的一个经典应用。</p><p>（8）桥接模式：可以根据客户的需求能够动态切换不同的数据源。比如我们的项目需要连接多个数据库，客户在每次访问中根据需要会去访问不同的数据库。</p><h2 id="面试题十三：Spring框架中有哪些不同类型的事件？"><a href="#面试题十三：Spring框架中有哪些不同类型的事件？" class="headerlink" title="面试题十三：Spring框架中有哪些不同类型的事件？"></a>面试题十三：Spring框架中有哪些不同类型的事件？</h2><p>Spring 提供了以下5种标准的事件：</p><p>（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p><p>（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</p><p>（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p><p>（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p><p>（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</p><p>如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>offer来了- java基础</title>
    <link href="/2022/11/08/offer%E6%9D%A5%E4%BA%86-%20java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/11/08/offer%E6%9D%A5%E4%BA%86-%20java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>offer来了- java基础</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java的集合类主要有4种: List Queue Set Map </p><ol><li><p>List: </p><ol><li><p>ArrayList</p></li><li><p>LinkedList</p></li><li><p>Vector</p></li></ol></li><li><p>Queue(不重要):</p><ol><li>DelayQueue</li><li>…</li></ol></li><li><p>Set</p><ol><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ol></li><li><p>Map</p><ol><li>HashMap</li><li>HashTable</li><li>TreeMap</li><li>LinkedHashMap</li><li>ConcurrentHashMap</li></ol></li></ol><h2 id="数据结构特点"><a href="#数据结构特点" class="headerlink" title="数据结构特点"></a>数据结构特点</h2><p>List: 有序, 允许有重复的元素</p><p>Set: 是无序, 不允许有重复的元素</p><p>Map: 通过键值对保存数据, key(索引)以set集合的形式保存, 不允许有重复的key, </p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List是有序的集合, 有三种常见的实现类</p><p><strong>ArrayList: 底层由数组实现, 增删慢, 查询快</strong></p><p>ArrayList是使用最普遍的List实现类</p><p>对外提供 add remove get方法实现增删查的功能</p><p>增删慢的原因: ArrayList是在连续的位置存储元素(数组实现), 导致对ArrayList的元素进行插入删除操作时必须同时对操作元素位置后面的元素进行移动操作. 也可以称为修改代价高</p><blockquote><p>数组特点: 插入删除操作慢, 操作时需要对操作元素后面的元素都进行移动操作, 也称为修改代价高</p></blockquote><p>随机查找(查询)&#x2F;遍历效率高的原因也是由于数组实现的原因</p><blockquote><p>当ArrayList的元素达到当前数组容量上限时, 会创建一个新的数组并将旧数组的数据复制到新数组中再进行增删操作</p></blockquote><p><strong>Vector</strong></p><p>vector与ArrayList类似, 也是基于数组实现, 提供相同的Api操作方法. 不同在于Vector是线程安全的, ArrayList是线程不安全的(效率更高, 应用更广泛)</p><blockquote><p>线程安全: 同一时刻只允许一个线程对集合进行操作, 保证在多线程应用场景下集合的数据一致性, 但是实现线程安全会导致频繁的加锁释放锁操作, 导致IO效率较低</p></blockquote><p><strong>LinkedList</strong></p><p>LinkedList基于双向链表实现, 增删操作快, 查询慢, 线程不安全</p><blockquote><p>链表特点: 插入删除操作快(需要操作的元素较少), 查询慢(需要从头遍历所有的元素)</p></blockquote><p>LinkedList还提供了对链表头尾进行操作的功能, 因此可以作为stack或queue使用</p><p><strong>Queue</strong></p><p>队列结构的实现类在项目开发中比较少使用, 一般在中间件(MQ, kafka)中队列结构的应用较广泛</p><p>常见的java队列实现类:</p><ol><li>ArrayBlockingQueue</li><li>DelayQueue</li><li>SynchronousQueue : 线程同步的阻塞队列</li></ol><p><strong>Set</strong></p><p>Set结构的特点是不允许有重复的元素</p><blockquote><p>根据hashCode和equals方法判断两个元素是否重复</p></blockquote><blockquote><p>HashCode是对象的内存地址计算</p></blockquote><p><strong>HashSet</strong>: HashMap的key底层实现为HashSet</p><p>HashSet判断两个元素是否重复:</p><ol><li>根据hashCode和equals方法判断两个元素是否重复</li><li>当且仅当两个方法都返回相同,则视为重复的元素</li><li>当两个方法有一个方法返回不相同时, 则视为非重复元素</li></ol><p><strong>TreeSet</strong></p><p>TreeSet基于二叉树实现, 并且整棵树的元素位置都是有顺序(升序或降序)的. 因此在添加新元素时需要进行排序, 将新元素插入二叉树中的指定位置</p><blockquote><p>Java中提供的基本类型包装类已经提供了排序方法, 因此可以直接保存到TreeSet中</p><p>自定义的对象保存到TreeSet中前必须先实现Comparable接口, 重写接口中的compareTo(对两个对象进行对比)(返回值大于0表示a大于b, 返回值小于0表示a小于b)</p></blockquote><p><strong>LinkedHashSet</strong></p><p>LinkedHashSet是在HashSet的基础上使用双链表接口记录元素的顺序</p><p>LinkedHashSet是LinkedHashMap存储key的底层实现</p><p>使用方法与HashSet类似</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>HashMap的key去重底层基于HashSet实现, 通过key对应的HashCode来标识或查询数据 , 线程不安全</p><blockquote><p>HashSet特点: 遍历顺序无序, 每次遍历的元素顺序都不相同</p></blockquote><p>HashMap可以继承synchronizedMap接口来实现线程安全, 或者直接使用ConcurrentHashMap代替</p><p>HashMap存储结构: 数组+链表&#x2F;红黑树</p><p>数组中的每个元素都是链表或红黑树</p><blockquote><p>默认为链表, 当链表中的元素超过8个后会自动转换为红黑树来提高查询效率</p></blockquote><p>HashMap查找元素的底层原理: 首先通过HashCode定位数组中的元素位置(下标) , 在对应位置的链表或黑红树中查找数据</p><blockquote><p>链表结构查找数据需要遍历整个链表,时间复杂度为O(n) </p><p>红黑树的查询效率高, 时间复杂度为O(logN)</p></blockquote><p>HashMap的底层属性:</p><ol><li>capacity: 当前的数组容量, 默认为16, 每次扩容时在当前容量的基础上x2</li><li>loadFactor: 负载因素, 默认为0.75</li></ol><p><strong>ConcurrentHashMap</strong></p><p>ConcurrentHashMap与HashMap类似, 但是是线程安全的, 并且在JDK1.7和1.8使用了不同的方式实现线程安全</p><p>JDK1.7: 使用分段锁实现线程安全</p><p>JDK1.8: 使用Synchronized+CAS 实现对多线程的安全操作, 并且在数据结构中引入了红黑树</p><p><strong>HashTable</strong></p><p>HashTable属于一种遗留类, 不推荐在正式环境中使用</p><p>HashTable的功能与HashMap类似, 但是是线程安全的</p><p><strong>TreeMap</strong></p><p>TreeMap基于二叉树作为存储的数据结构, 并且实现了SortedMap接口, 保证数据存储按照顺序</p><blockquote><p>默认是按照key的升序排列, 也可以使用自定义的比较器来排序</p></blockquote><p>TreeMap的key必须实现Comparable接口或者使用自定义的比较器, 否则会抛出ClassCastException异常</p><p><strong>LinkedHashMap</strong></p><p>LinkedHashMap是HashMap的子类, 内部使用链表来保存元素的顺序</p><p>使用Iterator遍历LinkedHashMap时会按照链表保存的顺序来遍历</p><h1 id="异常的分类和处理"><a href="#异常的分类和处理" class="headerlink" title="异常的分类和处理"></a>异常的分类和处理</h1><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p>异常是指方法不能正常运行时, 以抛出异常的方式直接退出方法</p><p>抛出的异常中一般封装了错误信息和原因, 调用方法的方法可以根据业务情况选择处理异常或者继续往上层调用方抛出异常</p><p>异常分类</p><p>在java中, 所有的错误或异常都直接或间接继承了Throwable类</p><p>Throwable类往下分为Error(错误)和Exception(异常)</p><p>Error是由于程序外的原因造成, 比如: 系统死机或内存不足</p><blockquote><p>因此错误是无法被程序处理的, 只能进行记录</p></blockquote><p>常见的错误有: AWTError ThreadDeath</p><p>异常又分为运行时异常(RuntimeException)和检查时异常(CheckedException)(又称为编译时异常)</p><p>运行时异常: 可以被捕获和处理, 常见的运行时异常有: NullPointException(空指针异常) ClassCastException(类型转换异常) ArrayIndexOutOfBundsException(数组越界异常)</p><p>编译时异常: 由编译器在程序编译阶段进行检查, 必须对编译时异常进行捕获和处理, 否则程序无法运行. 常见的编译时异常有 IOException(IO异常) SQLException(SQl语句错误) ClassNotFoundException(类不存在异常)</p><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>处理异常可以选择直接抛出异常(不在当前方法处理)或者使用try catch语句捕获处理异常</p><p>抛出异常有两种方式: throws和throw(方法内部)</p><p>区别: </p><ol><li>位置不同: throws在方法声明, 后面跟异常类 throw在方法内部, 后面跟异常对象</li><li>功能不同: throws声明当前方法运行中可能出现的异常, 将异常类型提供给方法调用者, 而throw直接将异常对象抛出给调用者, throw后面的代码不会被执行(但是finally语句的执行不受异常抛出影响)</li></ol><p>使用try catch语句可以捕获异常并处理, 异常信息不会传递给调用者</p><blockquote><p>在正式项目中一般使用抛出异常的方式, 尽量少用捕获异常</p></blockquote><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>java中反射机制一般用于在程序运行时的动态执行场景如: 获取类或对象的信息, 动态调用对象的方法, 动态代理</p><p>动态语言: 程序在运行时可以改变自身结构的语言: 比如在创建好的对象中添加新的属性, 在旧方法中注入新的代码</p><p>常见的动态编程语言有: JS Ruby Python</p><blockquote><p>C和C++不属于动态语言</p></blockquote><p>由于Java具有反射机制, 因此java被称为半动态语言</p><p>通过反射机制, java可以运行时时获取或修改类和对象的属性,方法</p><p>java中的对象具有两种类型: 编译时类型, 运行时类型</p><p>编译时类型是对象声明时使用的类型</p><p>运行时类型是对象在程序运行时赋值时使用的类型</p><blockquote><p>通过运行时类型可以使对象具有多态的表现: 对象根据运行时类型不同, 会具有不同的运行方法(同名, 但是运行时表现不同)</p></blockquote><p>由于运行时类型使对象具有多态表现, 因此程序无法在编译期间确定对象和类的真实信息, 只能在运行时通过反射机制来获取(反射机制的核心功能) </p><p>反射API: 用于在运行时动态获取类 对象 或接口的信息, 常用的有4种:</p><ol><li>Class类: 获取类的属性或方法等信息</li><li>Field类: 获取或设置类的非static变量</li><li>Method类: 获取或执行类的方法 </li><li>Constructor: 类的构造方法</li></ol><p>获取对应类的Class对象后, 可以通过调用Class对象来实现反射</p><p>获取Class对象的三种方法:</p><ol><li><p>调用对象的getClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>().getClass();<br></code></pre></td></tr></table></figure></li><li><p>调用类的static变量class</p></li><li><p>调用Class类的static方法forName(“完整类路径”)</p></li></ol><p>Class对象的实例方法有:</p><ol><li><p>getDeclareMethods(): 获取所有的方法</p></li><li><p>getDeclaredFields(): 获取所有的属性</p></li><li><p>getDeclaredConstructors(): 获取所有的构造方法</p></li><li><p>newInstance(): 创建对象</p><blockquote><p>要求该类具有无参构造器, 如果没有的话需要调用getDeclaredConstructor()获取对应的构造器再用构造器对象调用newInstance方法</p></blockquote></li></ol><p><strong>通过反射实现动态调用方法的步骤</strong>:</p><ol><li>调用getMethods方法, 获取Method对象</li><li>调用Method对象的invoke实例方法</li></ol><blockquote><p>具体invoke实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz=Class.forName(<span class="hljs-string">&quot;com.lee.mvc.bean.User&quot;</span>);<br>Method method=clazz.getMethod(<span class="hljs-string">&quot;setName&quot;</span>,String.class);<br>Constructor constructor=clazz.getConstructor();<br>Object object=constructor.newInstance();<br>method.invoke(object,<span class="hljs-string">&quot;lee&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h1><p>注解是一个接口, 用于设置关联信息化或元数据(MetaData) </p><p>程序可以通过反射获取到注解对象, 再通过注解对象获取注解的信息</p><blockquote><p>大部分的框架都是通过注解实现丰富的扩展功能</p></blockquote><p>元注解负责注解其他注解</p><p>Java中提供了四种标准元注解: </p><ol><li>@Target :定义注解修饰的对象范围</li><li>@Rentention : 定义注解的保留级别(有三种保留级别, 从低到高)<ol><li>SOURCE: 源代码保留</li><li>CLASS: 编译时保留</li><li>RUNTIME : 运行时保留</li></ol></li><li>@Documented : 表示javadoc工具需要记录该注解实现文档化</li><li>@Inherited: 表示该注解是需要被继承的, 子类会继承父类中的该注解</li></ol><p>注解处理器: 使用注解的工具</p><blockquote><p>注解处理的步骤</p></blockquote><ol><li>定义注解接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FruitProvider&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用注解接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>&#123;<br>    <span class="hljs-meta">@FruitProvider(id=1,name=&quot;红富士&quot;)</span><br>    String appleProvider;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>定义注解处理器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FruitInfoUtil就是自定义的注解处理器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitInfoUtil</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getFruitInfo</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span>&#123;<br>        clazz.getDeclaredFields();<br>    &#125; <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        FruitInfoUtil.getFruitInfo(Apple.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类有四种: 静态内部类 成员内部类 局部内部类 匿名内部类</p><p>静态内部类: 被static修饰, 定义在类内部</p><p>静态内部类可以访问外部类的静态变量和静态方法</p><p>通过外部类.静态内部类来调用静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInner</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>HashMap在底层会维护一个静态内部类Node数组用于存放元素</p></blockquote><p>非静态内部类, 也称为成员内部类</p><p>成员内部类中不能有静态成员(除非被final修饰)</p><blockquote><p>实现一个简单的成员内部类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部内部类</p><p>局部内部类只能在方法内部定义</p><blockquote><p>简单的方法内部类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>匿名内部类</p><p>匿名内部类是没有定义名称的类, 一般用于继承抽象类或实现接口</p><p>可以用lambda表达式来实现匿名内部类</p><p><strong>泛型</strong></p><p>泛型是参数化类型, 使用类作为类型</p><p>类型擦除: 泛型只用于编译时进行检验, 编译后会将在字节码中的泛型信息进行擦除, 在运行时中无任何作用</p><p>泛型可以用于编译时进行类型检测, 防止运行中抛出类型转换异常, 提高代码的安全性和重用性</p><p>常见的泛型标记有6种: </p><table><thead><tr><th>泛型标记</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>E</td><td>Element</td><td>集合中的元素</td></tr><tr><td>T</td><td>Type</td><td>Java类</td></tr><tr><td>K</td><td>Key</td><td>键</td></tr><tr><td>V</td><td>Value</td><td>值</td></tr><tr><td>N</td><td>Number</td><td>数值类型</td></tr><tr><td>?</td><td></td><td>不确定的java类型</td></tr></tbody></table><blockquote><p>注意这些泛型标记是强制要求, 不能使用其他字母作为标记</p></blockquote><p>泛型可以定义上限和下限</p><ol><li>上限: &lt;? extends T&gt; 表示T的子类或子接口</li><li>下限: &lt;? super T&gt; 表示T的父类或父接口</li></ol><p>泛型可以用于定义泛型方法 泛型类 泛型接口 泛型集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型方法 ...表示可以匹配多个参数</span><br>&lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T ... types)</span>&#123;<br>    List&lt;T&gt; t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt;();<br>    System.out.println(<span class="hljs-string">&quot;hello&quot;</span> +<br>                       <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">for</span> (T type : types) &#123;<br>        System.out.println(type);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt;&#123;<br>    T t;<br>&#125;<br><span class="hljs-comment">//泛型接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITest</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是指将内存中的对象转换为(二进制)信息, 方便进行传输和存储(持久化)</p><blockquote><p>对象在JVM中的生命周期中为 创建 更新 销毁</p></blockquote><p>持久化后的对象信息可以更方便在网络或者硬盘等介质中进行传输和存储</p><blockquote><p>RPC框架也需要用到序列化</p></blockquote><p>常用的序列化框架有: Kryo ProtoBuf FastJson</p><p>Java提供了标准化地序列化API用于序列化对象</p><ol><li>实现java.io.Serializable接口可以使类具有序列化功能 (Serializable接口为标记接口, 没有需要实现的方法)</li><li>序列化和反序列化时需要保持序列化ID一致, 一般用private static final long serialVersionUID定义序列化ID</li><li>序列化不保存静态变量</li><li>父类也需要实现Serializable接口</li><li>使用Tramsient关键字可以防止变量信息被序列化, 反序列化时会进行自动初始化</li></ol><p>Java I&#x2F;O</p><p>在java中数据的读取和写入(I&#x2F;O)以流的形式进行</p><p>流根据操作单位分为字节流和字符流两类接口</p><p>根据功能可以分为高级流(修饰流)和低级流</p><blockquote><p>字节是计算机操作数据的最小单位, 1byte&#x3D;8bit</p></blockquote><p>字符流以一个字符(两字节)为单位, 默认用Unicode编码</p><p>高级流的实现必须依靠低级流(高级流对低级流处理后的数据进行再处理)</p><table><thead><tr><th>类型</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输出</td><td>OutputStream</td><td>Writer</td></tr><tr><td>输入</td><td>InputStream</td><td>Reader</td></tr></tbody></table><p>上面四个类都是抽象类, 有多个实现类</p><p>InputStream常用的实现类有: </p><ol><li>FileInputStream : 文件输入</li><li>ObjectInputStream: 对象输入</li><li>ByteArrayInputStream: Byte数组输入</li><li>FilterInputStream: 过滤器</li><li>StringBufferedInputStream: 缓存字符串流</li></ol><p>InputStream的方法有:</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>read</td><td>读取字节数据, 返回值为读取的总字节数, 可以传入byte数组存储数据, 可以传入读取的开始位置和长度(默认为0, 长度8字节)</td></tr><tr><td>close</td><td>关闭流</td></tr><tr><td>available</td><td>返回输入流可以读取的位数</td></tr><tr><td>skip</td><td>从输入流跳过n字节</td></tr></tbody></table><blockquote><p>读取文件流示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;1.txt&quot;</span>);<br>    <span class="hljs-comment">//读取文件的相对路径是从整个项目的根路径出发</span><br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;2.txt&quot;</span>);<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span>(fileInputStream.read(bytes)!=-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);<br>        fileOutputStream.write(s.getBytes());<br>    &#125;<br>    fileInputStream.close();<br>    fileOutputStream.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>OutputStream的常用实现类与InputStream类似, 只需要将Input替换为Output</p><p>常用方法:</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>write</td><td>将字节数据写入输出流</td></tr><tr><td>close</td><td>关闭输出流</td></tr><tr><td>flush</td><td>刷新缓冲区</td></tr></tbody></table><p>Reader常见的子类有:</p><ol><li>CharArrayReader: 将字符数组转为输入</li><li>StringReader: 将字符串转换为输入</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>StringBuilder</title>
    <link href="/2022/11/08/StringBuilder/"/>
    <url>/2022/11/08/StringBuilder/</url>
    
    <content type="html"><![CDATA[<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>StringBuilder类是具有缓冲能力的字符串处理类</p><p>特点: 长度和内容都是可变的</p><p>常用方法:</p><p>append</p><p>insert</p><p>setCharAt</p><p>replace</p><p>deleteChatAt</p><p>delete</p><p>capacity</p><p>length</p><p>reverse</p><p>indexOf</p><p>lastIndexOf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;a1234a&quot;</span>);<br>      <span class="hljs-comment">//创建一个内容为a1234a的StringBuilder对象</span><br>      System.out.println(sb);<br>      sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>      <span class="hljs-comment">//将另一个字符串,或者基本数据类型加入到原字符串的末尾</span><br>      System.out.println(sb);<br>      sb.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br>      <span class="hljs-comment">//在index位置插入字符串或基本数据类型数值, 原来位置的字符向后移</span><br>      System.out.println(sb);<br>      sb.setCharAt(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br>      <span class="hljs-comment">//将index所在位置的字符替换为字符串或基本数据类型</span><br>      System.out.println(sb);<br>      sb.replace(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;d&quot;</span>);<br>      <span class="hljs-comment">//先删除startIndex到EndIndex-1的内容</span><br>      <span class="hljs-comment">//然后插入子字符串</span><br>      System.out.println(sb);<br>      sb.deleteCharAt(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//删除字符串中index对应字符</span><br>      System.out.println(sb);<br>      sb.delete(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>      <span class="hljs-comment">//删除startIndex到EndIndex-1的内容</span><br>      System.out.println(sb);<br>      System.out.println(sb.capacity());<br>      <span class="hljs-comment">//输出sb底层char[]数组的长度</span><br>      System.out.println(sb.length());<br>      <span class="hljs-comment">//输出内容字符长度</span><br>      System.out.println(sb.reverse());<br>      <span class="hljs-comment">//将字符串反转</span><br>      System.out.println(sb.indexOf(<span class="hljs-string">&quot;a&quot;</span>));<br>      <span class="hljs-comment">//输出第一个匹配到的字符串的第一个字符所在index</span><br>      sb.append(<span class="hljs-string">&#x27;a&#x27;</span>);<br>      System.out.println(sb);<br>      System.out.println(sb.lastIndexOf(<span class="hljs-string">&quot;aa&quot;</span>));<br>      <span class="hljs-comment">//输出第二个匹配到的字符串的第一个字符所在index</span><br></code></pre></td></tr></table></figure><p><strong>注意StringBuffer中也有跟StringBuilder相同功能的同名方法</strong></p><p><strong>StringBuffer和StringBuilder的方法会操作对象本身, 但是String中的方法不会操作对象, 而是返回一个新的String类对象</strong></p><p><strong>StringBuffer和StringBuilder两个属性length和capacity, 都是可变的, capacity代表对象的底层存储数组的长度(容量) 通常比length大, 而且该属性由系统自动操作, 程序无须关心</strong></p><p>可以用length()和setLength(int len)方法来获取长度或修改长度</p><p>String对象没有capacity属性, 只有length属性</p><p><strong>Java中有三种类来封装字符串: String StringBuffer StringBuilder</strong></p><p>区别: String类是固定的, 一旦创建不可再次改变</p><p>StringBuffer和StringBuilder类类似, 两个类都是可变的, 并且两者的方法和构造器基本相同, 但是只有StringBuffer是线程安全</p><blockquote><p>线程安全意味着StringBuffer有更好的高并发, 多线程支持</p></blockquote><p>StringBuffer类可以通过toString()方法转换成对应的String对象</p><p>StringBuilder的性能较高</p><p>创建一个内容可变的字符串对象时, 应该优先考虑使用StringBuilder</p><blockquote><p> Java中有CharSequence接口, 该接口被字符串的三种类都实现了, 可以视为Java中的字符串通用接口</p></blockquote><p>Java8中, 三个类都是使用char[]数组来存储字符串, 因此字符串中的每个字符占两个字节大小</p><p>Java9改进了三个类, 使用byte[]数组和encoding-flag字段来存储字符, 使得每个字符只占一个字节, 节省了内存空间</p><p>但是改进不会影响三个类的功能方法的使用</p><h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-type">int</span> num=Integer.parseInt(s);<br></code></pre></td></tr></table></figure><p>java中的8种基本数据类型的包装类都提供了工具方法parseInt(String s)来将字符串转换成对应的包装类对象</p><p>String类有大量构造器来创建对象</p><p>常用的构造器有:</p><p>String() 返回一个0长度的对象</p><p>String(String original) 用字符串直接量创建对象</p><p>String(StringBuffer buffer) 将StringBuffer类对象转换成String对象</p><p>String(StringBuilder bulder) 将StringBuilder类对象转换成String对象</p><p>String类的20种方法的使用示例: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;11123&quot;</span>;<br>        String str3=<span class="hljs-string">&quot;abc&quot;</span>;<br>        String str4=<span class="hljs-string">&quot;ABC&quot;</span>;<br><span class="hljs-comment">//        boolean flag = str3.isEmpty();</span><br><span class="hljs-comment">//        str.indexOf(&quot;23&quot;)</span><br>        System.out.println(str.indexOf(<span class="hljs-string">&quot;213&quot;</span>));<br>        <span class="hljs-comment">//返回第一个匹配到的字符串的第一个字符所在index</span><br>        <span class="hljs-comment">//不匹配返回-1</span><br>        System.out.println(str.charAt(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//返回index对应的字符</span><br>        String str2=str.concat(<span class="hljs-string">&quot;456&quot;</span>);<br>        <span class="hljs-comment">//进行字符串拼接,等同于+操作</span><br>        System.out.println(str2.contains(<span class="hljs-string">&quot;56&quot;</span>));<br>        <span class="hljs-comment">//判断是否包含另一个字符串</span><br>        System.out.println(str3.equals(str4));<br>        <span class="hljs-comment">//判断字符串内容是否相等</span><br>        System.out.println(str3.equalsIgnoreCase(str4));<br>        <span class="hljs-comment">//判断字符串内容是否相等, 忽略字母大小写的区别</span><br>        System.out.println(str3.startsWith(<span class="hljs-string">&quot;a&quot;</span>));<br>        <span class="hljs-comment">//判断字符串的开头是否是另一个字符串</span><br>        <span class="hljs-comment">//String str3=&quot;abc&quot;;</span><br>        System.out.println(str3.endsWith(<span class="hljs-string">&quot;a&quot;</span>));<br>        <span class="hljs-comment">//判断字符串的末尾是否是另一个字符串</span><br>        System.out.println(Arrays.toString(str3.getBytes(StandardCharsets.UTF_8)));<br>        <span class="hljs-comment">//以数组形式返回字符串的每个字符在编码集中对应的数值</span><br>        System.out.println(Arrays.toString(str3.toCharArray()));<br>        <span class="hljs-comment">//返回字符串中的字符对应的char数组</span><br>        System.out.println(str3.isEmpty());<br>        <span class="hljs-comment">//判断字符串的内容是否为空</span><br>        String str5=<span class="hljs-string">&quot;  aab c   &quot;</span>;<br>        System.out.println(str5.trim());<br>        <span class="hljs-comment">//去除字符串开头和结尾的空格并返回</span><br>        <span class="hljs-comment">//注意不会修改字符串本身, 返回的是另一个新字符串</span><br>        System.out.println(Arrays.toString(str5.split(<span class="hljs-string">&quot; &quot;</span>)));<br>        <span class="hljs-comment">//以参数的字符串为分隔符, 将字符串分割并存储为char类型数组返回</span><br>        System.out.println(str5.equals(str5.substring(<span class="hljs-number">0</span>)));<br>        <span class="hljs-comment">//返回从index开始到结尾的子字符串</span><br>        System.out.println(str5.replace(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<br>        <span class="hljs-comment">//将字符串中所有的匹配字符串替换为另一个字符串</span><br>        System.out.println(str5.lastIndexOf(<span class="hljs-string">&#x27;a&#x27;</span>));<br>        <span class="hljs-comment">//返回字符串中最后一个匹配的字符所在的index</span><br>        str5.toUpperCase(Locale.ROOT);<br>        <span class="hljs-comment">//将字符串中的所有小写字母转换为大写</span><br>        str5.toLowerCase(Locale.ROOT);<br>        <span class="hljs-comment">//将字符串中所有的大写字母转换成小写</span><br>        System.out.println(String.valueOf(<span class="hljs-number">5</span>));<br>        <span class="hljs-comment">//将基本数据类型转换成字符串, 可以用空白字符串+基本数据类型代替</span><br>        <span class="hljs-comment">//注意该方法为类方法, 不是实例方法</span><br>        System.out.println(str5.intern());<br>        <span class="hljs-comment">//从常量池中取出对应的字符串对象返回, 如果不存在则在常量池中创建</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String a=<span class="hljs-string">&quot;1&quot;</span>;<br>String b=a+a+a+a+a+a;<br><span class="hljs-comment">//上述代码将中途产生4个临时对象, 使用StringBuilder或StringBuffer类可以避免产生临时对象</span><br></code></pre></td></tr></table></figure><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>Arrays类是Java中的数组(Array)工具类</p><p>提供了大量static方法来操作数组</p><blockquote><p>注意通常是使用Arryas.方法名来调用Arrays中的方法</p><p>不是通过数组实例来调用Arrays中的方法</p></blockquote><p>Array中的常用方法</p><p>toString() 将数组转换成字符串</p><p>sort() 将数组替换为排序后的数组元素, 会修改数组本身</p><p>binarySearch() 用二分查找在数组中查询数据返回index, 二分查找算法要求数组必须是有序的, 否则返回的结果可能不正确</p><p>copyOf 将数组复制到另一个指定长度的数组中, 不会修改数组本身</p><p>equals: 对比两个数组的长度和数组元素是否一一对应, 不相同则返回false</p><p>在Array类里面的static修饰的方法可以直接调用来操作数组</p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> num)</span> <br></code></pre></td></tr></table></figure><p>用二分法在nums数组中查找key, 返回其出现过的索引值 由于二分法的要求,nums数组中的元素必须是从小到大排序才能正确查找 如果不包含则返回一个负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(type[] a, <span class="hljs-type">int</span> formIndex, <span class="hljs-type">int</span> toIndex, type key)</span><br></code></pre></td></tr></table></figure><p>与前一个方法类似, 但是搜索范围限制在 formIndex到toIndex里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type[] copyOf(type[] originalArray, <span class="hljs-type">int</span> length)<br></code></pre></td></tr></table></figure><p>将originalArray数组复制为length长度的新数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type[] copyOfRange(type[]originalArryay, <span class="hljs-type">int</span> form, <span class="hljs-type">int</span> to)<br></code></pre></td></tr></table></figure><p>与前方法类似, 但是将复制范围限制在form到to的索引范围内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(type[] a,type[] a2)</span><br></code></pre></td></tr></table></figure><p>如果两个数组的长度和数组元素一一对应相同,则返回true 否则返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(type[] a,type value)</span><br></code></pre></td></tr></table></figure><p>将a数组中的元素都赋值为value(注意这里的value需要是type类型的具体值)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(type[] a,<span class="hljs-type">int</span> formIndex,<span class="hljs-type">int</span> toIndex,type value)</span><br></code></pre></td></tr></table></figure><p>与上一方法类似, 但是仅仅将索引范围内的元素赋值为value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(type[] a)</span><br></code></pre></td></tr></table></figure><p>对a数组中的数组元素进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(type[] a, <span class="hljs-type">int</span> formIndex, <span class="hljs-type">int</span> toIndex)</span><br></code></pre></td></tr></table></figure><p>与上一方法类似,但是仅对范围内的元素进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">toString</span><span class="hljs-params">(type[] a)</span><br></code></pre></td></tr></table></figure><p>将数组的元素按顺序拼接为字符串并返回, 每个元素中间用逗号和空格进行分割</p><p>在Java8中, 对Array类的功能进行了增强, 添加了新的工具方法(这些方法支持利用CPU的并发处理性能)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">parallelSort</span><span class="hljs-params">(type[] a)</span><br></code></pre></td></tr></table></figure><p>与sort方法类似, 但是增加了对并发运算的支持</p><blockquote><p>用parallel开头的方法都表示该方法增加了对并行计算的支持</p></blockquote><p><strong>sort方法会改变数组本身</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,-<span class="hljs-number">1</span>&#125;;<br>      Arrays.sort(nums);<br>      <span class="hljs-comment">//sort()将数组替换为排序后的数组</span><br>      System.out.println(Arrays.toString(nums));<br>      <span class="hljs-comment">//toString()将数组打印</span><br>      System.out.println(Arrays.binarySearch(nums, <span class="hljs-number">4</span>));<br>      <span class="hljs-comment">//用二分查找法搜索数组, 返回匹配到的数组元素所在的index</span><br>      <span class="hljs-type">int</span>[]nums2=Arrays.copyOf(nums,<span class="hljs-number">4</span>);<br>      <span class="hljs-comment">//将数组复制成一个长度指定的新数组并返回</span><br>      <span class="hljs-comment">//不会修改原数组本身</span><br>      System.out.println(Arrays.toString(nums2));<br>      nums2=Arrays.copyOfRange(nums,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>      System.out.println(Arrays.toString(nums2));<br>      <span class="hljs-comment">//将数组从startIndex复制到endIndex-1的位置</span><br>      <span class="hljs-comment">//不会修改原数组本身</span><br>      Arrays.equals(nums,nums2);<br>      <span class="hljs-comment">//仅当两数组的长度和数组元素一一相同时才会返回true</span><br>      <span class="hljs-comment">//否则返回false</span><br>      Arrays.fill(nums2,<span class="hljs-number">2</span>);<br>      <span class="hljs-comment">//将数组的元素都赋值为对应类型的变量或直接量</span><br>      <span class="hljs-comment">//将会修改数组本身</span><br>      System.out.println(Arrays.toString(nums2));<br></code></pre></td></tr></table></figure><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><p><strong>System代表当前运行的JVM本身, 程序不能创建System对象</strong></p><blockquote><p>System提供了类变量和类方法来给外部调用</p></blockquote><p><strong>Java提供了System类和Runtime类使程序可以与系统交互</strong></p><p>类成员: </p><p>System.in 标准输出</p><p>System.out 标准输出</p><p>System.error 异常输出</p><p>类方法可以访问环境变量和系统属性</p><blockquote><p>这里的标准和异常是指系统的信息状态</p></blockquote><p><strong>Java中如果需要调用C语言来方法操作系统底层硬件设备可以通过以下步骤实现:</strong></p><blockquote><ol><li>声明一个native修饰的方法, 只有方法签名没有方法实现</li><li>用Javac编译成class文件</li><li>用Javah编译成.h文件</li><li>在C语言的源代码中include .h文件并实现native修饰的方法</li><li>将C语言的源代码文件编译成动态链接库文件</li><li>在Java中用System.loadLibrary()或Runtime.loadLibrary()加载第五步的动态链接库文件, 该native方法就可以被调用了</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; env=System.getenv();<br>        <span class="hljs-comment">//将当前系统中的所有环境变量获取名称</span><br>        <span class="hljs-comment">//Map是java.util中的一个类</span><br>        <span class="hljs-keyword">for</span>(String name:env.keySet())&#123;<br>            System.out.println(name+<span class="hljs-string">&quot;--&quot;</span>+env.get(name));<br>        &#125;<br>        <span class="hljs-comment">//遍历所有的环境变量的值</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span>System.getProperties();<br>        <span class="hljs-comment">//Properties也是java.util中的一个类</span><br>        props.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;props.txt&quot;</span>),<span class="hljs-string">&quot;System pro&quot;</span>);<br>        <span class="hljs-comment">//FileOutPutStream是java.io中的类, 用于将信息存储到文件里</span><br>        <span class="hljs-comment">//默认路径为项目所在的根目录</span><br></code></pre></td></tr></table></figure><p>上述代码调用System.getenv方法来获取当前系统的环境变量, 并将获取到的数据存储到了文本文件中</p><p>System类中常用的方法有:</p><ol><li><strong>获取当前的系统环境变量</strong></li></ol><p>getenv() getProperties() getProperty(String name)</p><ol start="2"><li><strong>获取当前时间</strong></li></ol><p>currentTimeMills() nanoTime()</p><blockquote><p>返回的值为当前时间与1970年1月1日0:00的时间差, </p><p>currentTimeMills()以毫秒为单位, nanoTime()以纳秒为单位</p><p>并且不同操作系统的底层时间粒度不同, 所以导致返回值的精确会有差异</p><p>大部分操作系统以几十毫秒为时间测量单位, 所以很少用到nanoTime()</p></blockquote><ol start="3"><li><p>System.exit(0)</p><blockquote><p>关闭程序所在的JVM, 会导致JVM和上面运行的所有程序直接结束运行</p></blockquote></li><li><p>System.gc()</p><blockquote><p>主动调用垃圾回收</p></blockquote></li><li><p>setIn() setOut() setErr()</p><blockquote><p>改变系统的标准输入 标准输出 标准错误输出流</p></blockquote></li><li><p>arraycopy()</p><blockquote><p>复制的两个数组都必须已经初始化, 如果index超过数组长度将发生数组索引越界错误</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(System.currentTimeMillis());<br>      <span class="hljs-comment">//输出当前系统时间与1970年1月1日0:00的时间差, 以毫秒为单位</span><br>      System.gc();<br>      <span class="hljs-comment">//主动调用垃圾回收</span><br>      <span class="hljs-type">int</span>[] nums=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>      <span class="hljs-type">int</span>[] nums2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">6</span>];<br>      System.arraycopy(nums,<span class="hljs-number">2</span>,nums2,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>      System.out.println(Arrays.toString(nums2));<br>      <span class="hljs-comment">//必须是对两个已经初始化的数组进行操作</span><br>System.exit(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">//导致整个JVM停止运行</span><br></code></pre></td></tr></table></figure><h1 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h1><p>每个Java程序都有一个对应的Runtime实例</p><p>Runtime提供了实例方法来操作当前程序的运行时环境</p><blockquote><p>System类的操作会影响到整个JVM上面的程序</p></blockquote><p>常用的方法:</p><p>getRuntime() 获取当前程序对应的Runtime对象</p><p>gc()</p><blockquote><p>与system类中的方法功能类似</p></blockquote><p>runFinalization()</p><blockquote><p>与system类中的方法功能类似</p></blockquote><p>freeMemory()</p><p>获取空闲内存量</p><p>totalMemory()</p><p>获取总的内存量</p><p>exec(“notepad.exe”)</p><blockquote><p>运行操作系统中指定名称的程序</p><p>在Java9中提供了ProcessHandle接口和ProcessHandle.Info实现类来获取exec运行的进程信息</p></blockquote><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>Math是Java中的数学运算工具类, 提供了大量数学运算的方法</p><p>常见方法:</p><p>random()</p><blockquote><p>产生一个0.0到1.0范围的浮点数</p></blockquote><p>abs(int i)pow(int a,int b)max(int a,int b)min(int a,int b)round(double d) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Math.abs(-<span class="hljs-number">1</span>));<br>      <span class="hljs-comment">//绝对值</span><br>      System.out.println(Math.pow(<span class="hljs-number">3.0</span>, <span class="hljs-number">2.0</span>));<br>      <span class="hljs-comment">//求幂</span><br>      System.out.println(Math.max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>      <span class="hljs-comment">//返回最大值</span><br>      System.out.println(Math.min(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>      <span class="hljs-comment">//最小值</span><br>      System.out.println(Math.round(<span class="hljs-number">15.5</span>));<br>      <span class="hljs-comment">//将double小数四舍五入返回一个int数值</span><br></code></pre></td></tr></table></figure><h1 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h1><p>Random中提供了大量的实例方法用于产生随机数值</p><p>使用Random中的实例方法一般要先创建Random类的实例</p><p>Random类有两个构造器, 无参构造器用默认的种子(当前系统时间) 有参构造器需要传入一个long类型整数作为种子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Random random=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-comment">//调用无参构造器创建对象</span><br>Random random2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//调用有参构造器创建对象, 如果传入的seed相同, 则创建的随机数可以追溯</span><br>random.nextInt(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//产生一个0-~100的随机数</span><br></code></pre></td></tr></table></figure><p>Java7中提供了Random的增强类 ThreadLocalRandom</p><blockquote><p>两个类的功能类似, 但是ThreadLocalRandom提供了对多线程 高并发的支持 有更好的线程安全</p></blockquote><h1 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h1><p>UUID: Universally Unique Indentifier (通用唯一标识码)</p><p><strong>UUID用于生成36位的随机值, UUID值的重复概率非常低, 因此可以视为具有唯一性</strong></p><p>可以用于高并发的系统中, 作为数据的唯一索引</p><blockquote><p>UUID是根据当前系统时间, 网卡MAC地址再加上随机数(盐) 作为种子来产生UUID值, 可以视为具有很高的随机性</p></blockquote><h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><p>在Java中进行浮点数(float double)运算时会发生精度丢失,计算的结果不准确</p><blockquote><p>原因在于浮点数是将十进制小数转换为二进制存储, 转换过程中会发生数据丢失(精度丢失)</p></blockquote><p><strong>数据丢失的本质是由于部分十进制小数没有对应的二进制浮点数, 只能存储成无限接近的近似值(类似于分数中无限循环小数的概念)</strong></p><p>为了在十进制小数的存储和使用时避免精度丢失, Java提供了BigDecimal来进行十进制小数的存储和运算</p><blockquote><p>在BigDecimal中, 十进制浮点数并非直接转换成二进制浮点数进行存储, 所以可以避免产生数据丢失</p></blockquote><p>BigDeciaml提供了大量构造器来将浮点数存储为对象</p><p>BigDecimal(double val)</p><blockquote><p>不推荐使用该构造器, 推荐使用BigDecimal.valueOf(double val)类方法来创建对象</p></blockquote><p>BigDecimal(type val)</p><blockquote><p>将8种基本数据类型(除了Boolean) 转换成对应的BigDeciaml对象 </p></blockquote><p><strong>推荐使用BigDeciaml(String str)构造器来将小数对应的字符串转换</strong></p><p>常用方法(都是实例方法, 必须通过对象调用): 加减乘除 幂</p><p>add()subtract()mutiply()divide()pow()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">BigDecimal bd=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;10&quot;</span>);<br>BigDecimal bd2=BigDecimal.valueOf(<span class="hljs-number">2.2222</span>);<br>bd.add(bd2);<br><span class="hljs-comment">//将BigDecimal对象与另一个对象相加, 不会修改原对象, 直接返回结果对象</span><br>bd.subtract(bd2);<br><span class="hljs-comment">//将两个对象相减并返回结果</span><br>bd.multiply(bd2);<br><span class="hljs-comment">//将两个对象相乘并返回结果</span><br>bd.divide(bd2);<br><span class="hljs-comment">//相除并返回结果</span><br>bd.divide(bd2,<span class="hljs-number">2</span>,BigDecimalROUND_DOWN)<br><span class="hljs-comment">//相除, 返回只保留两位小数的结果</span><br>bd.pow(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//计算幂, 注意必须传入参数必须为int整数</span><br></code></pre></td></tr></table></figure><p><strong>收尾模式</strong></p><p>类常量:</p><p>ROUND_DOWN保留小数位,后面都舍弃</p><p>ROUND_UP判断保留小数位的下一位不等于0则进一</p><p>ROUND_HALF_UP四舍五入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BigDecimal bd2=BigDecimal.valueOf(<span class="hljs-number">2.1234567</span>);<br>bd2.setScale(<span class="hljs-number">4</span>,BigDecimal.ROUND_HALF_UP);<br><span class="hljs-comment">//只保留4位小数,四舍五入</span><br></code></pre></td></tr></table></figure><p><strong>setScale() 需要输入保留位数和保留模式的参数</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IO流</title>
    <link href="/2022/11/08/IO%E6%B5%81/"/>
    <url>/2022/11/08/IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>输出是指将程序内部的数据输出到外部(磁盘 U盘), 使程序生成的数据可以存储起来</p><p>输入是指将外部的数据读取(输入)到程序内, 使程序可以处理数据</p><p>IO(Input&#x2F;Output)输入&#x2F;输出</p><p>在java.io包下的提供了各种类和接口来提供IO支持</p><p>IO流有两种, 输入流和输出流</p><p>输入和输出流中也分为字节流和字符流两大类</p><p>字节流以字节为单位处理输出和输出</p><p>字符流以字符为单位处理输入和输出</p><p>java还使用了装饰器设计模式将IO流分为底层节点流和上层处理流</p><p>底层节点流: 与底层的物理存储节点直接关联</p><p>java7中在java.nio下提供了全新的API(NIO2) ,是对原来的NIO(新IO)的升级</p><p>通过NIO2的API, 可以进行更高效的输入输出操作</p><p><strong>序列化可以将内存中的对象转换为二进制字节流, 使得java对象通过IO流传输</strong></p><blockquote><p>序列化是分布式编程的重要基础</p></blockquote><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>java.io.File类有各种对文件目录的操作API, 并且是平台无关的</p><p>File类中的API可以操作文件或者目录, 进行新建 删除 重命名操作, 但是无法对已经存在的文件本身进行修改或读取操作, 必须使用IO流才能访问文件本身</p><p>File类使用的文件路径可以是相对路径或者绝对路径</p><blockquote><p>相对路径默认情况下是用户的工作路径, 即jvm运行的路径</p></blockquote><p>File对象创建后, 就可以调用其实例方法对其对应的文件或目录进行操作</p><p>常用实例方法:</p><blockquote><p>(下列方法的文件都可以为目录)目录实质上是一种特殊的文件</p></blockquote><table><thead><tr><th>实例方法</th><th>作用</th><th>返回</th></tr></thead><tbody><tr><td>——获取信息——</td><td></td><td></td></tr><tr><td>getName</td><td>返回文件名或最后一级子路径名的字符串</td><td>String</td></tr><tr><td>getPath</td><td>返回路径名的字符串(包含文件名)</td><td>String</td></tr><tr><td>getAbsoluteName</td><td>返回绝对路径(包含文件名)对应的对象</td><td>File</td></tr><tr><td>getAbsolutePath</td><td>返回绝对路径(不包含文件名)</td><td>String</td></tr><tr><td>getParent</td><td>返回父目录名</td><td>String</td></tr><tr><td>renameTo</td><td>重命名文件, 成功返回true, 否则返回false</td><td>boolean</td></tr><tr><td>lastModified</td><td>返回文件最后修改时间</td><td>long</td></tr><tr><td>length</td><td>返回文件长度</td><td>long</td></tr><tr><td>—操作文件—-</td><td></td><td></td></tr><tr><td>createNewFile</td><td>创建文件</td><td></td></tr><tr><td>delete</td><td>删除文件(如果当前对象为文件夹, 不会做任何操作) 并且将引用变量赋值为null</td><td></td></tr><tr><td>deleteOnExit</td><td>将引用变量置为null,注册一个删除hook, 当JVM结束运行时将file对象</td><td></td></tr><tr><td>—-操作目录—–</td><td></td><td></td></tr><tr><td>mkdir</td><td>创建文件夹</td><td>boolean</td></tr><tr><td>list</td><td>列出文件夹下面的所有文件和文件路径</td><td>String</td></tr><tr><td>listFiles</td><td>列出文件夹下面所有的文件和目录, 返回它们的对象</td><td>File</td></tr><tr><td>—–检测方法—–都为boolean返回类型</td><td></td><td></td></tr><tr><td>exists</td><td>判断文件是否存在</td><td></td></tr><tr><td>canWrite</td><td>判断文件是否可写</td><td></td></tr><tr><td>canRead</td><td>判断文件是否可读</td><td></td></tr><tr><td>isFile</td><td>判断对象是否为文件, 不是目录</td><td></td></tr><tr><td>isDirectory</td><td>判断是否是目录</td><td></td></tr><tr><td>isAbsolute</td><td>判断对象的路径是否是绝对路径</td><td></td></tr></tbody></table><p>还有两个static方法</p><p>createTempFile(String prefix, String suffix)</p><p>在默认的临时文件目录创建一个随机文件名的文件</p><blockquote><p>随机文件名为 prefix+随机数+suffix</p><p>如果suffix为null, 将使用默认的后缀”.tmp”</p></blockquote><p>createTempFile(String prefix, String suffix, File Directory)</p><p>在指定的目录创建临时文件</p><p>listRoots</p><p>列出当前系统的所有根目录</p><blockquote><p>在linux中,以&#x2F;开头一定是绝对路径 (双向一定)</p><p>在Windows中, 以盘符开头一定是绝对路径</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2&quot;</span>);<br><span class="hljs-comment">//必须使用双反斜杠, 因为java中反斜杠默认为转义字符</span><br><span class="hljs-keyword">if</span>(!file.exists())&#123;<br>    file.mkdir();<br>    <span class="hljs-comment">//不存在则创建</span><br>&#125;<br>file.isDirectory();<br>file.isAbsolute();<br>file.isHidden();<br>File[] files=file.listFiles();<br><span class="hljs-keyword">for</span> (File file1 : files) &#123;<br>    file.getPath();<br>    file.getName();<br>&#125;<br>String[] names=file.list(((dir, name) -&gt;&#123;<br>    <span class="hljs-keyword">return</span> name.endsWith(<span class="hljs-string">&quot;java&quot;</span>);<br>&#125;));<br><span class="hljs-comment">//用lambda表达式实现FilenameFilter的accept方法</span><br><span class="hljs-keyword">for</span> (String name : names) &#123;<br>    System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h2><p>list方法可以接收FilenameFilter参数, 只列出被筛选后的文件</p><p>FilenameFilter为函数接口, 可以用lambda表达式创建</p><blockquote><p>遍历子目录下面的文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">File[] files = file1.listFiles();<br><span class="hljs-keyword">for</span> (File file : files) &#123;<br>    <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>        showAllFiles(file);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(file.getPath());<br>        System.out.println(file.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>java通过IO流来实现IO操作, 在java中 输入&#x2F;输入源(source)被抽象为流(stream)</p><blockquote><p>java中的流(stream) 是指从源头(source)接收到(sink)的有序数据(格式化数据)</p></blockquote><p>java.io包中有所有传统的流类型, 可以用来实现IO</p><blockquote><p>java将不同类型的输入输出源都抽象为流(stream)的形式, 可以使用相同的api来处理流, 而无须考虑复杂的底层, 大大提高了编程效率</p></blockquote><p>按照方向可以将流分为输入流和输出流</p><p>输入流: 只能读取数据, 不能写入数据</p><p>输出流: 只能写入数据, 不能读取数据</p><blockquote><p>这里的输入和输出都是站在程序的角度说的</p></blockquote><table><thead><tr><th>流类型</th><th>抽象基类</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream和Reader</td></tr><tr><td>输出流</td><td>OutputStream和Writer</td></tr><tr><td>字节流</td><td>InputStream和OutputStream</td></tr><tr><td>字符流</td><td>Reader和Writer</td></tr></tbody></table><p>字节流和字符流的使用api几乎完全相同, 但是它们处理的基本单位不同</p><p>字节流处理8位的字节</p><p>字符流操作16位的字符</p><p>按照流的角色又分为: 节点流和功能(处理)流</p><p>节点流: 直接处理数据源流入的数据</p><p>功能流: 将数据源数据进行一些功能封装的流</p><blockquote><p>功能流的现实实例位蓄水池, 变压器</p></blockquote><p><img src="/2022/11/08/IO%E6%B5%81/image-20220520150305511.png" alt="image-20220520150305511"></p><p>节点流又被称为低级流(Low Level Stream)</p><p>处理流被称为高级流(High Level Stream)</p><p>处理流实际是经过包装后的节点流, 这也是java中经典装饰器设计模式的体现, 因此处理流也被称为包装流</p><p>**一般程序员都是在程序中使用处理流(高级流), 因为处理流提供了便捷的API可以</p><h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>java中IO流一共有40多个类, 并且都是由以下4个抽象基类派生的</p><p><strong>InputStreamReaderOutputStreamWriter</strong></p><blockquote><p>输入流</p></blockquote><p><img src="/2022/11/08/IO%E6%B5%81/image-20220520154711839.png" alt="image-20220520154711839"></p><blockquote><p>输出流</p></blockquote><p><img src="/2022/11/08/IO%E6%B5%81/image-20220520154747174.png" alt="image-20220520154747174"></p><p>java中IO流的设计具有良好的灵活性：</p><ol><li>使用缓冲区来提高输入&#x2F;输出效率</li><li>提供API来一次处理大量数量的数据</li></ol><p>不同数据源都转换为同一的处理流， 用相同的代码进行处理</p><p><img src="/2022/11/08/IO%E6%B5%81/image-20220520155512854.png" alt="image-20220520155512854"></p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><p>字节流操作生命周期</p><p>三步: 创建流操作流关闭流</p><blockquote><p>输入流代码示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建流</span><br>FileInputStream fileInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\4.java&quot;</span>);<br><span class="hljs-type">byte</span>[] datas=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-comment">//读取\操作流 一次读取1024字节</span><br><span class="hljs-keyword">while</span>(fileInputStream.read(datas)!=-<span class="hljs-number">1</span>)&#123;<br>    System.out.println(Arrays.toString(datas));<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;Second&quot;</span>);<br><span class="hljs-comment">//由于字节流已经读取完了, 所以下面的代码不会被执行</span><br><span class="hljs-keyword">while</span>(fileInputStream.read(datas,<span class="hljs-number">0</span>,datas.length)!=-<span class="hljs-number">1</span>)&#123;<br>    System.out.println(Arrays.toString(datas));<br>&#125;<br><span class="hljs-comment">//关闭流</span><br>fileInputStream.close();<br></code></pre></td></tr></table></figure><blockquote><p>输出流代码示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fos= <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<br>        <span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\1.txt&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;请输入&quot;</span>);<br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span>sc.nextLine();<br><span class="hljs-type">byte</span>[] datas=input.getBytes(StandardCharsets.UTF_8);<br>fos.write(datas);<br>fos.close();<br></code></pre></td></tr></table></figure><blockquote><p>使用输入输出流复制一个文件到另一个文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream fos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\1-cpoy.txt&quot;</span>);<br>FileInputStream fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\1.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] datas=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">while</span>(fis.read(datas)!=-<span class="hljs-number">1</span>)&#123;<br>    fos.write(datas);<br>&#125;<br>fos.close();<br>fis.close();<br></code></pre></td></tr></table></figure><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p>字节流和字符流的API非常相似</p><p>但是字节流可以操作任何文件（二进制文件和文本文件）</p><p>字符流只能识别文本文件，无法正确识别处理二进制文件</p><blockquote><p>因为二进制文件以字节为单位存储数组， 并非使用字符存储数据</p></blockquote><blockquote><p>字符流读取</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">FileReader r= <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\1.txt&quot;</span>);<br><span class="hljs-type">char</span>[] datas=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span>(r.read(datas)!=-<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//            String s=Arrays.toString(datas);</span><br><span class="hljs-comment">//            String s=String.valueOf(datas);</span><br>    String s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(datas);<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>字符流写入</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">FileWriter fileWriter=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\4.txt&quot;</span>);<br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入&quot;</span>);<br>String s=sc.nextLine();<br>fileWriter.write(s);<br>fileWriter.close();<br></code></pre></td></tr></table></figure><blockquote><p>文件复制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">FileReader fr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\4.txt&quot;</span>);<br>FileWriter fw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\4-copy.txt&quot;</span>);<br><span class="hljs-type">char</span>[] chars=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">while</span>(fr.read(chars)!=-<span class="hljs-number">1</span>)&#123;<br>    fw.write(chars);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;复制完成&quot;</span>);<br>fr.close();<br>fw.close();<br><span class="hljs-comment">//输出流如果没有写close语句， 不会对文件进行修改操作（数据实际上还在内存中未写入磁盘）</span><br><span class="hljs-comment">//只有待写入数据达到1024个字节才会执行磁盘写入</span><br></code></pre></td></tr></table></figure><h1 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h1><h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p>InpuStream和Reader是所有输入流的抽象基类</p><p>InputStream是字节输入流， Reader是字符输入流</p><p>它们都有处理文件读取的实现类：</p><p>FileInputStreamFileReader</p><table><thead><tr><th>方法名</th><th>字节流</th><th>字符流</th><th>返回值</th></tr></thead><tbody><tr><td>read()</td><td>读取一个字节</td><td>单位为字符</td><td>返回读取到的数据</td></tr><tr><td>read(byte[] b)</td><td>读取b.length长度的数据</td><td>字符数组</td><td>返回读取到的数据长度</td></tr><tr><td>read(byte[] b,int off, int len)</td><td>读取len个字节， 存储到字节数组中(从数组的第off个元素开始存)</td><td>单位为字符</td><td>返回读取到的数据长度</td></tr></tbody></table><p><strong>打开的IO流不属于内存中的资源， 因此GC不会回收IO资源， 当一个IO资源不再使用时应该显式关闭该资源</strong></p><blockquote><p>jdbc编程中的数据库资源也是类似， 无法被GC自动回收</p></blockquote><blockquote><p>在java7中将IO类都实现了AutoCloseable接口， 可以通过try语句来实现自动关闭IO资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只要将IO资源的使用代码放入try语句中即可实现自动关闭IO资源</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<br>                    <span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\4.txt&quot;</span>));<br>    <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<br>                    <span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\4_2.txt&quot;</span>));<br>    <span class="hljs-type">byte</span>[] datas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">while</span> (bis.read(datas) != -<span class="hljs-number">1</span>) &#123;<br>        bos.write(datas);<br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//下行代码会产生编译错误， 因为该IO只能在try语句内使用， 离开try语句会导致该资源被自动关闭</span><br>bis.read();<br></code></pre></td></tr></table></figure><p>输入流类实例方法：</p><table><thead><tr><th>记录指针方法</th><th>形参</th><th>返回值</th><th>功能</th></tr></thead><tbody><tr><td>mark</td><td>int readAheadLimit</td><td>void</td><td>在当前指针位置记录mark</td></tr><tr><td>markSupproted</td><td>无</td><td>boolean</td><td>判断该输入流是否支持记录标记</td></tr><tr><td>reset</td><td>无</td><td>void</td><td>将指针重置到上次的记录（mark）</td></tr><tr><td>skip</td><td>long n</td><td>long</td><td>将指针向前移动n个字节、字符</td></tr></tbody></table><h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>OutputStream  Writer</p><p>输出流创建对象时可以在构造器中传入路径和boolean append</p><blockquote><p>append传入true将允许进行持续输出拼接</p><p>默认为false, 后面的输出会覆盖(replace)前面的输出</p></blockquote><table><thead><tr><th>实例方法</th><th>参数</th><th>功能</th><th>返回值</th></tr></thead><tbody><tr><td>write</td><td>int</td><td>将传入字节输出到字节流(int可以与字节相互转换)</td><td>void</td></tr><tr><td>write</td><td>byte[]</td><td>将字节数组输出</td><td>void</td></tr><tr><td>write</td><td>byte[], int off,int len</td><td>从数组的off位置开始输出len长度的字节</td><td>void</td></tr></tbody></table><h1 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h1><p>缓存流是一种提供了缓存功能的高级流</p><p>特性：</p><ol><li>不会直接处理文件</li><li>提供了缓冲区， 提高了输入&#x2F;输出效率</li></ol><p><strong>高级流创建时必须指定底层的低级流, 体现了装饰器设计模式</strong></p><table><thead><tr><th>缓存流(高级流)</th><th>低级流</th></tr></thead><tbody><tr><td>BufferedInputStream</td><td>InputStream</td></tr><tr><td>BufferedOutputStream</td><td>OutputStream</td></tr><tr><td>BufferedReader</td><td>Reader</td></tr><tr><td>BufferedWriter</td><td>Writer</td></tr></tbody></table><blockquote><p>缓冲流的使用</p></blockquote><p><img src="/2022/11/08/IO%E6%B5%81/image-20220520175714128.png" alt="image-20220520175714128"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<br>                <span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\4.txt&quot;</span>));<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<br>                <span class="hljs-string">&quot;C:\\Users\\libolon\\Downloads\\New folder2\\4_2.txt&quot;</span>));<br><span class="hljs-type">byte</span>[] datas=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span>(bis.read(datas)!=-<span class="hljs-number">1</span>)&#123;<br>    bos.write(datas);<br>&#125;<br>bis.close();<br>bos.close();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java开发一轮复习</title>
    <link href="/2022/11/08/Java%E5%BC%80%E5%8F%91%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/11/08/Java%E5%BC%80%E5%8F%91%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java开发一轮复习"><a href="#Java开发一轮复习" class="headerlink" title="Java开发一轮复习"></a>Java开发一轮复习</h1><h2 id="一、网络篇"><a href="#一、网络篇" class="headerlink" title="一、网络篇"></a><strong>一、网络篇</strong></h2><p><strong>1、OSI七层模型与TCP&#x2F;IP 五层模型</strong></p><p>​OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p>​TCP&#x2F;IP五层：物理层、数据链路层、网络层、传输层、应用层</p><p><strong>2、常见应用层协议和运输层、网络层协议，以及硬件如路由器之类在哪一层</strong> </p><p>​应用层：HTTP、SMTP、DNS、FTP</p><p>​传输层：TCP 、UDP</p><p>​网络层：ICMP 、IP、路由器、防火墙</p><p>​数据链路层：网卡、网桥、交换机</p><p>​物理层：中继器、集线器</p><p><strong>3、TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些</strong> </p><table><thead><tr><th>类型</th><th align="center">特点</th><th align="center">性能</th><th align="center">应用过场景</th><th align="center">首部字节</th><th></th></tr></thead><tbody><tr><td>TCP</td><td align="center">面向连接、可靠、字节流</td><td align="center">传输效率慢、所需资源多</td><td align="center">文件、邮件传输</td><td align="center">20-60</td><td></td></tr><tr><td>UDP</td><td align="center">无连接、不可靠、数据报文段</td><td align="center">传输效率快、所需资源少</td><td align="center">语音、视频、直播</td><td align="center">8个字节</td><td></td></tr></tbody></table><p>​<strong>基于TCP的协议：</strong>HTTP、FTP、SMTP</p><p>​<strong>基于UDP的协议：</strong>RIP、DNS、SNMP</p><p><strong>4、TCP可靠传输的保证，拥塞控制目的和过程</strong> </p><p>​<strong>TCP通过：</strong>应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、ARP协议、超时重传等措施保证数据的可靠传输；</p><p>​<strong>拥塞控制目的：</strong>为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载</p><p>​<strong>拥塞控制过程：</strong>TCP发送将维护一个拥塞窗口的状态变量，该变量随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。</p><p><strong>5、TCP粘包现象原因和解决方法</strong> </p><p>​<strong>TCP粘包是指</strong>：发送方发送的若干包数据到接收方接收时粘成一包</p><p>​<strong>发送方原因：</strong></p><p>​TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</p><p>​只有上一个分组得到确认，才会发送下一个分组<br>​收集多个小分组，在一个确认到来时一起发送<br>​Nagle算法造成了发送方可能会出现粘包问题</p><p>​<strong>接收方原因：</strong></p><p>​TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>​<strong>解决粘包问题：</strong></p><p>​最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：</p><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。</li><li>包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</li></ul><p><strong>6、TCP三次握手过程以及每次握手后的状态改变，为什么三次？  为什么两次不行？</strong></p><p>​<strong>三次握手过程：</strong></p><p>​客户端——发送带有SYN标志的数据包——服务端       <strong>一次握手</strong>  Client进入syn_sent状态</p><p>​服务端——发送带有SYN&#x2F;ACK标志的数据包——客户端   <strong>二次握手</strong>  服务端进入syn_rcvd</p><p>​客户端——发送带有ACK标志的数据包——服务端               <strong>三次握手</strong>   连接就进入Established状态</p><p>​<strong>为什么三次：</strong></p><p>​主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力</p><p>​<strong>为什么两次不行？</strong></p><p>​1、防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源</p><p>​2、 两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）</p><p><strong>7、TCP四次挥手过程以及状态改变，为什么四次？CLOSE-WAIT和TIME-WAIT存在的意义？如何查看TIME-WAIT状态的链接数量？为什么会TIME-WAIT过多？解决方法是怎样的？</strong> </p><p><strong>四次挥手过程：</strong></p><p>​客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态</p><p>​服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态</p><p>​服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态</p><p>​客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态</p><p><strong>为什么四次：</strong></p><p>​因为需要确保客户端与服务端的数据能够完成传输。</p><p><strong>CLOSE-WAIT：</strong></p><p>​这种状态的含义其实是表示在等待关闭</p><p><strong>TIME-WAIT：</strong></p><p>​为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接</p><p><strong>如何查看TIME-WAIT状态的链接数量？</strong></p><p>​netstat -an |grep TIME_WAIT|wc -l  查看连接数等待time_wait状态连接数</p><p><strong>为什么会TIME-WAIT过多？解决方法是怎样的？</strong></p><p>​<strong>可能原因：</strong> 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接</p><p>​<strong>解决：</strong>负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接</p><p><strong>8、TCP、UDP、IP、以太网报文格式以及重要字段，报文从一端到另一端传递的过程。</strong> </p><p>​<strong>TCP报文格式：</strong></p><p>​<img src="https://farm1.staticflickr.com/792/27194088468_4cb0141fc8_b.jpg"></p><p>​<strong>源端口号和目的端口号</strong>：</p><p>​用于寻找发端和收端应用进程。这两个值加上ip首部源端ip地址和目的端ip地址唯一确定一个tcp连接。</p><p>​<strong>序号字段：</strong></p><p>​序号用来标识从T C P发端向T C P收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 T C P用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。</p><p>　　当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号</p><p>​<strong>确认序号</strong>：</p><p>​既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有ACK标志为 1时确认序号字段才有效。发送ACK无需任何代价，因为 32 bit的确认序号字段和A C K标志一样，总是T C P首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK标志也总是被设置为1。TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p><p>​<strong>首都长度</strong>：</p><p>​首部长度给出首部中 32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此T C P最多有6 0字节的首部。然而，没有任选字段，正常的长度是 2 0字节。</p><p>​<strong>标志字段</strong>：在T C P首部中有 6个标志比特。它们中的多个可同时被设置为1.<br>　　URG紧急指针（u rgent pointer）有效<br>　　ACK确认序号有效。<br>　　PSH接收方应该尽快将这个报文段交给应用层。<br>　　RST重建连接。<br>　　SYN同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。<br>　　FIN发端完成发送任务。</p><p>​<strong>窗口大小</strong>：</p><p>​T C P的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。</p><p>​<strong>检验和：</strong></p><p>​检验和覆盖了整个的 T C P报文段：T C P首部和T C P数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p><p>​<strong>紧急指针</strong>：</p><p>​只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 T C P的紧急方式是发送端向另一端发送紧急数据的一种方式。</p><p>​<strong>选项</strong>：</p><p>​最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 S Y N标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。</p><p>​<strong>UDP报文格式：</strong></p><p>​<img src="https://appwk.baidu.com/naapi/doc/view?ih=482&o=png_6_0_0_176_917_504_247_892.979_1262.879&iw=986&ix=0&iy=0&aimw=986&rn=1&doc_id=182d935c3186bceb18e8bb77&pn=1&sign=b88bda03b9954e506622f97b8b2ae438&type=1&app_ver=2.9.8.2&ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&bid=1&app_ua=IncredibleS&uid=&cuid=&fr=3&Bdi_bear=WIFI&from=3_10000&bduss=&pid=1&screen=800_800&sys_ver=2.3.7"></p><p>​<strong>端口号</strong>：</p><p>​用来表示发送和接受进程。由于 I P层已经把I P数据报分配给T C P或U D P（根据I P首部中协议字段值），因此T C P端口号由T C P来查看，而 U D P端口号由UDP来查看。T C P端口号与UDP端口号是相互独立的。</p><p>​<strong>长度</strong>：</p><p>​UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为 8字节（发送一份0字节的UDP数据报是 O K）。</p><p>​<strong>检验和</strong>：</p><p>​UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。</p><p>​<strong>IP报文格式：</strong>普通的IP首部长为20个字节，除非含有可选项字段。</p><p>​<img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1614312792,1954581760&fm=26&gp=0.jpg"></p><p>​<strong>4位版本</strong>：</p><p>​目前协议版本号是4，因此IP有时也称作IPV4.</p><p>​<strong>4位首部长度</strong>：</p><p>​首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p><p>​<strong>服务类型（TOS）</strong>：</p><p>​服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p><p>​<strong>总长度</strong>：</p><p>​总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p><p>​<strong>标识字段</strong>：</p><p>​标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p><p>​<strong>生存时间</strong>：</p><p>​TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。</p><p>​<strong>首部检验和</strong>：</p><p>​首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p><p>​<strong>以太网报文格式：</strong></p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2733576797,55677727&fm=26&gp=0.jpg"></p><p>​<strong>目的地址和源地址：</strong></p><p>​是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。</p><p>​<strong>数据：</strong></p><p>​以太网帧中的数据长度规定最小46 字节，最大1500 字节，ARP 和RARP 数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的MTU了，则需要对数据包进行分片fragmentation）。ifconfig 命令的输出中也有“MTU:1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。</p><p><strong>9、浏览器输入URL并回车的过程以及相关协议，DNS查询过程。</strong> </p><p>​<strong>过程：</strong>DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束</p><table><thead><tr><th>过程</th><th>使用的协议</th></tr></thead><tbody><tr><td>1、浏览器查找域名DNS的IP地址<br />DNS查找过程（浏览器缓存、路由器缓存、DNS缓存）</td><td>DNS：获取域名对应的ip</td></tr><tr><td>2、根据ip建立TCP连接</td><td>TCP：与服务器建立连接</td></tr><tr><td>3、浏览器向服务器发送HTTP请求</td><td>HTTP：发送请求</td></tr><tr><td>4、服务器响应HTTP响应</td><td>HTTP</td></tr><tr><td>5、浏览器进行渲染</td><td></td></tr></tbody></table><p><strong>10、HTTP1.0、1.1、2.0之间的区别</strong> </p><p>​<strong>HTTP1.0：</strong>默认使用Connection:cloose，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p><p>​<strong>HTTP1.1：</strong>默认使用Connection:keep-alive（长连接），避免了连接建立和释放的开销；通过Content-Length字段来判断当前请求的数据是否已经全部接受。不允许同时存在两个并行的响应。</p><p>​<strong>HTTP2.0：</strong>引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以并行的传输数据。</p><p>​<strong>http1.0和http1.1的主要区别如下：</strong><br>​1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）<br>​2、网络连接的优化：1.1支持断点续传<br>​3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态<br>​4、Host头处理：支持Host头域，不在以IP为请求方标志<br>​5、长连接：减少了建立和关闭连接的消耗和延迟。</p><p>​<strong>http1.1和http2.0的主要区别：</strong><br>​1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式<br>​2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成  正常的请求）<br>​3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的  hearder大小<br>​4、服务端推送：同google的SPDUY（1.0的一种升级）一样</p><p><strong>11、HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？</strong></p><p>​<strong>HTTP与HTTPS之间的区别：</strong></p><table><thead><tr><th align="center">HTTP</th><th align="center">HTTPS</th></tr></thead><tbody><tr><td align="center">默认端口80</td><td align="center">HTTPS默认使用端口443</td></tr><tr><td align="center">明文传输、数据未加密、安全性差</td><td align="center">传输过程ssl加密、安全性较好</td></tr><tr><td align="center">响应速度快、消耗资源少</td><td align="center">响应速度较慢、消耗资源多、需要用到CA证书</td></tr></tbody></table><p>​<strong>HTTPS链接建立的过程：</strong></p><p>​1.首先客户端先给服务器发送一个请求</p><p>​2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p><p>​3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密</p><p>​4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端</p><p>​5.随后客户端和服务端就使用对称密钥进行信息传输</p><p>​<strong>对称加密算法：</strong></p><p>​双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES</p><p>​<strong>非对称加密算法：</strong></p><p>​密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA</p><p><strong>12、HTTP请求有哪些。get和Post区别。</strong> </p><p><strong>HTTP请求：</strong></p><table><thead><tr><th align="left">方法</th><th>描述</th></tr></thead><tbody><tr><td align="left">GET</td><td>向特定资源发送请求，查询数据，并返回实体</td></tr><tr><td align="left">POST</td><td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td></tr><tr><td align="left">PUT</td><td>向服务器上传新的内容</td></tr><tr><td align="left">HEAD</td><td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">DELETE</td><td>请求服务器删除指定标识的资源</td></tr><tr><td align="left">OPTIONS</td><td>可以用来向服务器发送请求来测试服务器的功能性</td></tr><tr><td align="left">TRACE</td><td>回显服务器收到的请求，用于测试或诊断</td></tr><tr><td align="left">CONNECT</td><td>HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p><strong>get和Post区别：</strong></p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>可见性</td><td>数据在URL中对所有人可见</td><td>数据不会显示在URL中</td></tr><tr><td>安全性</td><td>与post相比，get的安全性较差，因为所<br/>发送的数据是URL的一部分</td><td>安全，因为参数不会被保存在浏览器<br/>历史或web服务器日志中</td></tr><tr><td>数据长度</td><td>受限制，最长2kb</td><td>无限制</td></tr><tr><td>编码类型</td><td>application&#x2F;x-www-form-urlencoded</td><td>multipart&#x2F;form-data</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能被缓存</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>13、HTTP常见响应状态码，从1xx到5xx</strong></p><p>​100：Continue — 继续。客户端应继续其请求。</p><p>​200：OK — 请求成功。一般用于GET与POST请求。</p><p>​301：Moved Permanently — 永久重定向。</p><p>​302：Found — 暂时重定向。</p><p>​400：Bad Request — 客户端请求的语法错误，服务器无法理解。</p><p>​403：Forbideen — 服务器理解请求客户端的请求，但是拒绝执行此请求。</p><p>​404：Not Found — 服务器无法根据客户端的请求找到资源（网页）。</p><p>​500：Internal Server Error — 服务器内部错误，无法完成请求。</p><p>​502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p><p><strong>14、重定向和转发区别</strong> </p><p>​<strong>重定向：redirect：</strong></p><p>​地址栏发生变化</p><p>​重定向可以访问其他站点（服务器）的资源</p><p>​重定向是两次请求。不能使用request对象来共享数据</p><p>​<strong>转发：forward：</strong></p><p>​转发地址栏路径不变</p><p>​转发只能访问当前服务器下的资源</p><p>​转发是一次请求，可以使用request对象共享数据</p><p><strong>15、cookie和session区别。</strong></p><p>​Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：</p><p>​Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>​cookie不是很安全，别人可以分析存放在本地的COOKIE并进行欺骗,考虑到安全应当使用session。</p><p>​Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态</p><h2 id="二、操作系统篇"><a href="#二、操作系统篇" class="headerlink" title="二、操作系统篇"></a><strong>二、操作系统篇</strong></h2><p><strong>1、进程和线程的区别</strong> </p><p>​<strong>进程：</strong>是资源分配的最小单位，是程序的执行过程，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，但每个线程又有属于自己的本地方法栈、虚拟机栈、程序计数器</p><p>​<strong>线程：</strong>是任务调度和执行的最小单位，线程间可能存在相互影响，执行开销较小，不利于资源的管理和保护，线程间是共享进程中的资源的</p><p><strong>2、协程？</strong> </p><p>​是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p><p><strong>3、进程间通信方式IPC</strong> </p><p>参考：<a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></p><p><strong>匿名管道pipe：</strong></p><p>​匿名管道是半双工的，数据只能单向通信；需要双方通信时，需要建立起两个管道；只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。</p><p><strong>命名管道FIFO：</strong></p><p>​不同于匿名管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。</p><p><strong>信号：</strong></p><p>​信号是一种比较复杂的通信方式，信号产生的条件：按键、硬件异常、进程调用kill函数将信号发送给另一个进程、用户调用kill命令将信号发送给其他进程，信号传递的消息比较少，主要用于通知接收进程某个时间已经发生。</p><p><strong>消息队列：</strong></p><p>​消息队列是消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。消息队列起信箱作用，到了就挂在那里，需要的时候去取。消息队列提供了一种在两个不相关进程间传递数据的简单有效的方法。与命名管道相比：消息队列的优势在于，它独立于发送和接收进程而存在，这消除了在同步命名管道的打开和关闭时可能产生的一些困难。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。而且，每个数据块被认为含有一个类型，接收进程可以独立地接收含有不同类型值的数据块。</p><p>​<strong>优点：</strong></p><p>​A. 我们可以通过发送消息来几乎完全避免命名管道的同步和阻塞问题。</p><p>​B. 我们可以用一些方法来提前查看紧急消息。</p><p>​<strong>缺点：</strong></p><p>​A. 与管道一样，每个数据块有一个最大长度的限制。</p><p>​B. 系统中所有队列所包含的全部数据块的总长度也有一个上限。</p><p><strong>共享内存(share memory)：</strong></p><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li></ul><p><strong>信号量(Semaphores) ：</strong></p><p>​信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</p><p><strong>套接字(Sockets) :</strong> </p><p>​此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持TCP&#x2F;IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</p><p><strong>4、用户态和核心态</strong> </p><p>​在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、核心态</p><p><strong>用户态：</strong>只能受限的访问内存，运行所有的应用程序</p><p><strong>核心态：</strong>运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备</p><p><strong>为什么要有用户态和内核态：</strong></p><p>​由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络</p><p><strong>用户态切换到内核态的3种方式：</strong></p><p>​<strong>a. 系统调用</strong></p><p>​这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p><p>​<strong>b. 异常</strong></p><p>​当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p><p>​<strong>c. 外围设备的中断</strong></p><p>​当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p><p>​这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p><p>​</p><p><strong>5、操作系统分配的进程空间是怎样的？线程能共享哪些？</strong> </p><p>​栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</p><p>​堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。</p><p>​静态区（static）—存放全局变量和静态变量的存储</p><p>​代码区(text)—存放函数体的二进制代码。</p><p>​<strong>线程共享堆区、静态区</strong></p><p><strong>6、操作系统内存管理方式，分页分段以及段页式的优缺点</strong> </p><p>参考地址：<a href="https://blog.csdn.net/qq_37189082/article/details/97963763">https://blog.csdn.net/qq_37189082/article/details/97963763</a></p><p><strong>存管理方式：</strong>块式管理、页式管理、段式管理、段页式管理</p><p><strong>分段管理：</strong></p><p>​在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p><p><strong>分页管理：</strong></p><p>​在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）</p><p><strong>段页式管理：</strong></p><p>​段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的。</p><p><strong>7、页面置换算法有哪些，FIFO为什么不好？如何改进?LRU思想，手写LRU</strong> </p><p><strong>置换算法：</strong>先进先出FIFO、最近最久未使用LRU、最佳置换算法OPT</p><p><strong>先进先出FIFO:</strong></p><p>​原理：把内存中驻留时间最久的页面置换算法予以淘汰</p><p>​优点：实现简单、直观</p><p>​缺点：没有考虑到实际的页面使用频率，性能差、与通常页面使用的规则不符合，实际应用较少</p><p>​改进：给每个页面增加一个R位，每次先从链表头开始查找，如果R置位，清除R位并且把该页面节点放到链表结尾；如果R是0，那么就是又老又没用到，替换掉。</p><p><strong>最近最久未使用LRU:</strong></p><p>​原理：选择最近且最久未使用的页面进行淘汰</p><p>​优点：考虑到了程序访问的时间局部性，有较好的性能，实际应用也比较多</p><p>​缺点：实现需要比较多的硬件支持，会增加一些硬件成本</p><p>​手写LRU: 参考 <a href="https://www.jianshu.com/p/ec1952b9d84a">https://www.jianshu.com/p/ec1952b9d84a</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: Java</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: LRU最近最久未使用置换算法，通过LinkedHashMap实现</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Mr.Li</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-17 10:29</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedHashMap&lt;Integer,Integer&gt; cache;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;   <span class="hljs-comment">//容量大小</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *初始化构造函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(capacity);<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">//缓存中不存在此key，直接返回</span><br>        <span class="hljs-keyword">if</span>(!cache.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> cache.get(key);<br>        cache.remove(key);   <span class="hljs-comment">//先从链表中删除</span><br>        cache.put(key,res);  <span class="hljs-comment">//再把该节点放到链表末尾处</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key,<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(cache.containsKey(key)) &#123;<br>            cache.remove(key); <span class="hljs-comment">//已经存在，在当前链表移除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(capacity == cache.size()) &#123;<br>            <span class="hljs-comment">//cache已满，删除链表头位置</span><br>            Set&lt;Integer&gt; keySet = cache.keySet();<br>            Iterator&lt;Integer&gt; iterator = keySet.iterator();<br>            cache.remove(iterator.next());<br>        &#125;<br>        cache.put(key,value);  <span class="hljs-comment">//插入到链表末尾</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: Java</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Mr.Li</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-17 10:59</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *初始化构造函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;Integer, Integer&gt;(capacity, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry eldest)</span> &#123;<br>                <span class="hljs-keyword">return</span> size() &gt; capacity;  <span class="hljs-comment">// 容量大于capacity 时就删除</span><br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">//返回key对应的value值，若不存在，返回-1</span><br>        <span class="hljs-keyword">return</span> map.getOrDefault(key, -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        map.put(key, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最佳置换算法OPT:</strong></p><p>​原理：每次选择当前物理块中的页面在未来长时间不被访问的或未来不再使用的页面进行淘汰</p><p>​优点：具有较好的性能，可以保证获得最低的缺页率</p><p>​缺点：过于理想化，但是实际上无法实现（没办法预知未来的页面）</p><p><strong>8、死锁条件，解决方式。</strong> </p><p>​死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象；</p><p>​<strong>死锁的条件：</strong></p><p>​互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</p><p>​请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</p><p>​非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p><p>​循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源</p><p>​<strong>解决方法：</strong>破坏死锁的任意一条件</p><p>​资源一次性分配，从而剥夺请求和保持条件</p><p>​可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</p><p>​资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p><h2 id="三、Java基础篇"><a href="#三、Java基础篇" class="headerlink" title="三、Java基础篇"></a><strong>三、Java基础篇</strong></h2><p><strong>1、Java面向对象特性介绍、与C++区别</strong> </p><p><strong>特性：</strong>封装、继承、多态</p><p>​<strong>封装：</strong>对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法，这样一个对象便有存在的意义了；</p><p>​<strong>继承：</strong>在已存在类的基础上，建立新类并对其增加新的数据域或功能，同时该类可以复用父类的属性与功能，这种思路可以称为继承；通过使用继承能够方便地复用旧代码，减少不必要的代码量；</p><p>​<strong>多态：</strong>指程序中的某个引用变量，它所指向的具体类型以及该引用变量发出的方法调用，在编程时不能确定，要在程序运行并使用时由机器自己判别确定；实现多态的方式有两种方式，可以通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）</p><p><strong>Java与C++区别：</strong></p><p>​相同点：都是面向对象语言，并且都支持封装、继承、多态</p><p>​不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</p><p><strong>2、多态实现原理</strong> </p><p>参考：<a href="https://www.baidu.com/link?url=qCqeY8tJInTtjEXuotB712TJtEpKeLJ9ds1ACGEnYwMyJdjf6J0C7JvOEwbV7qNG&amp;wd=&amp;eqid=fe3b2106001ee6ab000000065f111b6c">https://www.baidu.com/link?url=qCqeY8tJInTtjEXuotB712TJtEpKeLJ9ds1ACGEnYwMyJdjf6J0C7JvOEwbV7qNG&amp;wd=&amp;eqid=fe3b2106001ee6ab000000065f111b6c</a></p><p>多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。</p><p><strong>静态绑定与动态绑定：</strong></p><p>​JVM 的方法调用指令有五个，分别是：</p><p>​invokestatic：调用静态方法；</p><p>​invokespecial：调用实例构造器<init>方法、私有方法和父类方法；</p><p>​invokevirtual：调用虚方法；</p><p>​invokeinterface：调用接口方法，运行时确定具体实现；</p><p>​invokedynamic：运行时动态解析所引用的方法，然后再执行，用于支持动态类型语言。</p><p>​invokestatic 和 invokespecial 用于静态绑定</p><p>​invokevirtual 和 invokeinterface 用于动态绑定</p><p>​可以看出，动态绑定主要应用于虚方法和接口方法。</p><p>​虚方法的方法调用与方法实现的关联（也就是分派）有两种，一种是在编译期确定，被称为静态分派，比如方法的重载；一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）。对象方法基本上都是虚方法。</p><p><strong>多态的实现</strong></p><p>​虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，通过栈帧的信息去找到被调用方法的具体实现，然后使用这个具体实现的直接引用完成方法调用。</p><p>以 invokevirtual 指令为例，在执行时，大致可以分为以下几步：</p><ol><li>先从操作栈中找到对象的实际类型 class；</li><li>找到 class 中与被调用方法签名相同的方法，如果有访问权限就返回这个方法的直接引用，如果没有访问权限就报错 java.lang.IllegalAccessError ；</li><li>如果第 2 步找不到相符的方法，就去搜索 class 的父类，按照继承关系自下而上依次执行第 2 步的操作；</li><li>如果第 3 步找不到相符的方法，就报错 java.lang.AbstractMethodError ；</li></ol><p>可以看到，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p><p><strong>3、抽象类和接口区别，以及各自的使用场景</strong> </p><p><strong>抽象类：</strong>包含抽象方法的类，即使用abstract修饰的类；不能使用final修饰，final修饰的类不能被继承；抽象类不能被实例化，只能被继承</p><p><strong>接口：</strong>接口是一个抽象类型，是抽象方法的集合，接口以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法；接口只能继承接口，不能继承类，接口支持多继承；接口中的定义的成员变量，默认是public static final修饰的静态常量；接口中定义的方法，默认是public abstract修饰的抽象方法</p><p><strong>相同点：</strong></p><p>​① 抽象类和接口都不能被实例化</p><p>​② 抽象类和接口都可以定义抽象方法，子类&#x2F;实现类必须覆写这些抽象方法</p><p><strong>不同点：</strong></p><p>​① 抽象类有构造方法，接口没有构造方法</p><p>​③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以）</p><p>​③ 抽象类只能单继承，接口可以多继承</p><p>​④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量</p><p><strong>抽象类的使用场景：</strong></p><p>​既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量</p><p><strong>接口的应用场景：</strong></p><p>​约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类需要具备很多不同的功能，但各个功能之间可能没有任何联系</p><p><strong>4、泛型以及泛型擦除。List<A>类型的list,可以加入无继承关系的B类型对象吗？如何加入？</strong> </p><p>参考：<a href="https://blog.csdn.net/baoyinwang/article/details/107341997">https://blog.csdn.net/baoyinwang/article/details/107341997</a></p><p><strong>泛型：</strong></p><p>​泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p><p><strong>泛型擦除：</strong></p><p>​Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p><p>​如在代码中定义的 List<Object>和 List<String>等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</p><p><strong>如何加入：</strong></p><p>​通过反射添加其它类型元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <br>        ArrayList&lt;A&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;A&gt;();<br>        <br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());  <span class="hljs-comment">//这样调用 add 方法只能存储A，因为泛型类型的实例为 A</span><br> <br>        list.getClass().getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>());<br> <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            System.out.println(list.get(i));<br>        &#125;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5、Java异常体系</strong> </p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3137389296,1222888772&fm=26&gp=0.jpg"></p><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p><p><strong>Error ：</strong></p><p>​是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p><p><strong>Exception 包含：RuntimeException 、CheckedException</strong></p><p><strong>RuntimeException：</strong> 运 行 时 异 常</p><p>​ 如 NullPointerException 、 ClassCastException ； </p><p>​ RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类，这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p><strong>CheckedException：</strong>受检异 常</p><p>​如 I&#x2F;O 错误导致的 IOException、SQLException；</p><p>​CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类</p><p>异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面：</p><p>​  ①试图在文件尾部读取数据</p><p>​  ②试图打开一个错误格式的 URL</p><p>​  ③试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</p><p><strong>6、反射原理以及使用场景</strong> </p><p><strong>Java反射：</strong></p><p>​是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p><p><strong>反射原理：</strong></p><p>​反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类</p><p>​<strong>如何得到Class的实例:</strong></p><pre><code class="hljs">     1.类名.class(就是一份字节码)     2.Class.forName(String className);根据一个类的全限定名来构建Class对象     3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型</code></pre><p><strong>使用场景：</strong></p><p>​逆向代码 ，例如反编译；</p><p>​动态生成类框架，如Spring：xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p><p><strong>7、ThreadLocal原理，如何使用？</strong> </p><p><strong>ThreadLocal简介：</strong></p><p>​通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的<br>专属本地变量该如何解决呢？ JDK中提供的 ThreadLocal 类正是为了解决这样的问题。</p><p><strong>原理：</strong></p><p>​首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，这个 Map 不是直接使用的 HashMap ，而是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。</p><p>​最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p><p>​我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的 </p><p><strong>set 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>get方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;   <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();   <br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);   <br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)   <br>        <span class="hljs-keyword">return</span> (T)map.get(<span class="hljs-built_in">this</span>);   <br> <br>    <span class="hljs-comment">// 如果不存在，则创建它   </span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();   <br>    createMap(t, value);   <br>    <span class="hljs-keyword">return</span> value;   <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>createMap方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;   <br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);   <br>&#125; <br></code></pre></td></tr></table></figure><p><strong>ThreadLocalMap是个静态的内部类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;   <br>    ……  <br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>如何使用：</strong></p><p>​1）存储用户Session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadSession</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InfrastructureException &#123;<br>    <span class="hljs-type">Session</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Session) threadSession.get();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>            s = getSessionFactory().openSession();<br>            threadSession.set(s);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (HibernateException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InfrastructureException</span>(ex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>​2）解决线程安全的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateUtil</span> &#123;<br>    <span class="hljs-comment">//SimpleDateFormat不是线程安全的，所以每个线程都要有⾃⼰独⽴的副本</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; format1 = <span class="hljs-keyword">new</span>                     <span class="hljs-title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> SimpleDateFormat <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">formatDate</span><span class="hljs-params">(Date date)</span> &#123;<br>        <span class="hljs-keyword">return</span> format1.get().format(date);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>8、ThreadLocal内存泄漏的场景</strong> </p><p>​实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。弱引用的特点是，如果这个对象持有弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p><p>​所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。</p><p>​ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。</p><p>​因此使⽤完ThreadLocal ⽅法后，最好⼿动调⽤ remove() ⽅法。</p><p><strong>9、static关键字和final关键字使用情况，一个类不能被继承，除了final关键字之外，还有什么方法（从构造函数考虑）？</strong></p><p><strong>static：</strong>可以修饰属性、方法</p><p>​<strong>static修饰属性：</strong></p><p>​所有对象共享一份，一个对象对其修改，其他的调用也会受到影响，类级别；随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。</p><p>​<strong>static修饰方法：</strong></p><p>​随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员；非静态的方法中，可以调用静态和非静态的成员；在静态方法中，不会出现this。</p><p><strong>final：</strong>关键字主要⽤在三个地⽅：变量、⽅法、类。</p><p>​<strong>final修饰变量：</strong></p><p>​对于⼀个 final 变量，如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。</p><p>​<strong>final修饰方法：</strong></p><p>​把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。</p><p>​<strong>final修饰类：</strong></p><p>​ final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。</p><p><strong>10、序列化和反序列化。反序列化失败的场景。</strong> </p><p>​序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。</p><p><strong>序列化：</strong>将java对象转化为字节序列的过程。</p><p><strong>反序列化：</strong>将字节序列转化为java对象的过程。 </p><p><strong>优点：</strong></p><p>​a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）</p><p>​b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 </p><p><strong>反序列化失败的场景：</strong></p><p>​序列化ID：serialVersionUID不一致的时候，导致反序列化失败</p><p><strong>11、ArrayList和LinkedList的区别和底层实现？如何实现线程安全？</strong> </p><p><strong>ArrayList：</strong></p><p>​底层基于数组实现，支持对元素进行快速随机访问，支持元素重复；默认初始大小为10，当数组容量不够时，会触发扩容机制（扩大到当前的1.5倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p><p><strong>LinkedList：</strong></p><p>​底层基于双向链表实现，适合数据的动态插入和删除；内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p><p><strong>ArrayList与LinkedList区别：</strong></p><p>​都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于 增加、删除多的场景</p><p><strong>实现线程安全：</strong></p><p>​可以使用原生的<strong>Vector</strong>，或者是<strong>Collections.synchronizedList(List list)<strong>函数返回一个线程安全的ArrayList集合，或者使用concurrent并发包下的</strong>CopyOnWriteArrayList</strong>的。</p><p>​①、<strong>Vector:</strong> 底层通过synchronize修饰保证线程安全，效率较差</p><p>​② 、<strong>Collections.synchronizedList(List list)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用Collections.synchronizedList(List list)方法实现线程安全</span><br>List&lt;?&gt; list=Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br></code></pre></td></tr></table></figure><p>​③、<strong>CopyOnWriteArrayList：</strong>写时加锁，使用了一种叫<strong>写时复制</strong>的方法；读操作是可以不用加锁的</p><p>​</p><p><strong>12、List遍历时如何删除元素？fail—fast是什么？fail—safe是什么？</strong> </p><p><strong>①、普通for循环遍历List删除指定元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>   <span class="hljs-keyword">if</span>(list.get(i) == <span class="hljs-number">5</span>) <br>       list.remove(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>② 、迭代遍历,用list.remove(i)方法删除元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Iterator&lt;Integer&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> it.next();<br>    <span class="hljs-keyword">if</span>(value == <span class="hljs-number">5</span>)&#123;<br>        list.remove(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>③、foreach遍历List删除元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">for</span>(Integer i:list)&#123;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>) list.remove(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>fail—fast：</strong>快速失败</p><p>​当异常产生时，直接抛出异常，程序终止;</p><p>​fail-fast只要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。这里要注意的这里说的结构被改变,是例如插入和删除这种操作,只是改变集合里的值的话并不会抛出异常。</p><p><strong>fail—safe：</strong>安全失败</p><p>    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p>    原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p><p>    缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>    场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><p><strong>13、详细介绍HashMap。</strong> </p><p>角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N，JDK1.7与1.8的区别。</p><p>参考：<a href="https://www.jianshu.com/p/9fe4cb316c05">https://www.jianshu.com/p/9fe4cb316c05</a></p><p><strong>数据结构：</strong></p><p>​HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据</p><p><strong>扩容情况：</strong></p><p>​默认的负载因子是0.75，表示的是，如果数组中已经存储的元素个数大于数组长度的75%，将会引发扩容操作。</p><p>​【1】创建一个长度为原来数组长度<strong>两倍的新数组</strong>。</p><p>​【2】重新对原数组中的Entry对象进行哈希运算，以确定他们各自在新数组中的新位置。</p><p><strong>put操作步骤：</strong></p><p>​1、判断数组是否为空，为空进行初始化;</p><p>​2、不为空，则计算 key 的 hash 值，通过(n - 1) &amp; hash计算应当存放在数组中的下标 index;</p><p>​3、查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</p><p>​4、存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据；</p><p>​5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；</p><p>​6、若不是红黑树，创建普通Node加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树；</p><p>​7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍</p><p><strong>哈希函数：</strong></p><p>​ hash函数是先拿到 key 的hashcode，是一个32位的值，然后让hashcode的高16位和低16位进行<strong>异或</strong>操作。该函数也称为扰动函数，做到尽可能降低hash碰撞。</p><p><strong>容量为什么始终都是2^N：</strong></p><p>​为了能让 HashMap 存取⾼效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上⾯也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来⼤概40亿的映射空间，只要哈希函数映射得⽐较均匀松散，⼀般应⽤是很难出现碰撞的。但问题是⼀个40亿⻓度的数组，内存是放不下的。所以这个散列值是不能直接拿来⽤的。⽤之前还要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“  (n - 1) &amp; hash ”。（n代表数组⻓度）。这也就解释了 HashMap 的⻓度为什么是2的幂次⽅。</p><p><strong>JDK1.7与1.8的区别：</strong></p><p>J<strong>DK1.7 HashMap：</strong></p><p>​底层是 <strong>数组和链表</strong> 结合在⼀起使⽤也就是 链表散列。HashMap 通过 key 的hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><strong>DK1.8 HashMap：</strong></p><p>​HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据；当链表⻓度⼤于阈值（默认为 8），数组的⻓度大于 64时，将链表转化为红⿊树，以减少搜索时间</p><p><strong>14、HashMap如何实现线程安全？ConcurrentHashMap的底层实现？JDK1.7与JDK1.8的区别</strong> </p><p>​可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；Hashtable 是原始API类，通过synchronize同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比Hashtable要好；</p><p><strong>ConcurrentHashMap的底层实现：</strong></p><p>​<strong>JDK1.7的 ConcurrentHashMap</strong> 底层采⽤ 分段的数组+链表 实现；采用 <strong>分段锁</strong>（Sagment） 对整个桶数组进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1035283471,1167301443&fm=26&gp=0.jpg"></p><p>​<strong>JDK1.8的 ConcurrentHashMap</strong> 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表&#x2F;红⿊⼆叉树；摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 <strong>synchronized 和CAS</strong>来操作保证线程的安全。</p><p><strong>15、正则表达式会写吗？</strong> </p><p>参考：<a href="https://blog.csdn.net/qq_39331713/article/details/82871510">https://blog.csdn.net/qq_39331713/article/details/82871510</a></p><p>​正则通过一些特定的符号与数字来表示一串字符，其中有：元字符、重复限定符、分组、转义、条件或、区间；</p><p><strong>16、设计模式了解吗？</strong> </p><p>单例模式、工厂模式、代理模式</p><p><strong>17、linux指令知道哪些？</strong> </p><p>文件管理：ls、cd、touch创建普通文件、rm删除、mkdir新建目录、mv移动、cp拷贝、chmod修改权限</p><p>进程管理：ps显示进程信息、kill杀死进程</p><p>系统管理：top、free显示系统运行信息、vmstat输出各资源使用情况</p><p>网络通讯：ping测试网络连通性、netstat显示网络相关信息</p><p><strong>18、JVM相关</strong> </p><p><strong>1、JVM运行时内存划分？</strong> </p><p><strong>JVM运行时数据区域：</strong>堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3099290709,1184193923&fm=26&gp=0.jpg"></p><p><strong>Heap(堆)：</strong></p><p>​对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；</p><p>​堆细分：新生代、老年代，对于新生代又分为：Eden区和Surviver1和Surviver2区；</p><p><strong>方法区：</strong></p><p>​对于JVM的方法区也可以称之为永久区，它储存的是已经被java虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；</p><p><strong>虚拟机栈：</strong></p><p>​虚拟机栈<strong>是线程私有的</strong>，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的<strong>栈帧</strong>，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（<strong>局部变量表</strong>、<strong>操作数栈</strong> 、<strong>动态链接</strong> 、<strong>返回地址</strong>）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</p><ul><li><p><strong>局部变量表：</strong>局部变量表是一组变量值存储空间，用来存放<strong>方法参数</strong>、方法内部定义的<strong>局部变量</strong>。局部变量表的容量是以变量槽（variable slot）为最小的单位。Java虚拟机没有明确规定一个slot所占的空间大小。只是导向性的说了每一个slot能存放8种基本数据类型中的一种(long 和double这种64位的需要两个slot)；</p></li><li><p><strong>操作数栈：</strong>是用来记录一个方法在执行的过程中，<strong>字节码指令向操作数栈中进行入栈和出栈的过程</strong>。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种<strong>字节码指令</strong>往操作数栈中<strong>入栈和出栈</strong>。</p></li><li><p><strong>动态链接：</strong>因为字节码文件中有很多符号的引用，这些符号引用一部分会在<strong>类加载的解析阶段</strong>或<strong>第一次使用</strong>的时候转化成<strong>直接引用</strong>，这种称为<strong>静态解析</strong>；另一部分会<strong>在运行期间</strong>转化为直接引用，称为<strong>动态链接</strong>。</p></li><li><p><strong>返回地址（returnAddress）：</strong>类型（指向了一条字节码指令的地址）</p></li></ul><p><strong>本地方法栈：</strong></p><p>​本地方法栈和虚拟机栈类似，不同的是虚拟机栈服务的是Java方法，而<strong>本地方法栈服务的是Native方法</strong>。在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出<strong>StackOverflowError</strong>和<strong>OOM</strong>异常。</p><p><strong>PC程序计数器：</strong></p><p>​PC，指的是存放下一条指令的位置的这么一个区域。它是一块较小的内存空间，且是<strong>线程私有</strong>的。由于线程的切换，CPU在执行的过程中，一个线程执行完了，接下来CPU切换到另一个线程去执行，另外一个线程执行完再切回到之前的线程，这时需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。</p><p><strong>2、堆内存分配策略</strong> </p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3784749479,768026745&fm=26&gp=0.jpg"></p><ul><li><p>对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次MinorGC。而那些无需回收的存活对象，将会进到 Survivor 的 From 区（From 区内存不足时，直接进入 Old 区）。</p></li><li><p>大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。</p></li><li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p></li></ul><p><strong>3、Full GC触发条件</strong> </p><p>​每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小，则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC</p><p><strong>4、如何判断对象是否存活？回收对象的两次标记过程。</strong> </p><p><strong>引用计数法：</strong></p><p>​给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>​优点：实现简单，判定效率也很高</p><p>​缺点：他很难解决对象之间相互循环引用的问题。</p><p><strong>对象可达性：</strong></p><p>​通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的；</p><p><strong>两次标记过程：</strong></p><p>​对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。</p><p><strong>5、垃圾回收算法以及垃圾回收器介绍，尤其是G1和CMS的优缺点</strong> </p><p><strong>垃圾回收算法</strong>：复制算法、标记清除、标记整理、分代收集</p><p><strong>复制算法：</strong></p><p>​将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收；</p><p>​优点：实现简单，内存效率高，不易产生碎片</p><p>​缺点：内存压缩了一半，倘若存活对象多，Copying 算法的效率会大大降低</p><p><strong>标记清除：</strong></p><p>​标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象</p><p>​缺点：效率低，标记清除后会产⽣⼤量不连续的碎⽚，可能发生大对象不能找到可利用空间的问题。</p><p><strong>标记整理：</strong></p><p>​标记过程仍然与“标记-清除”算法⼀样，再让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存；解决了产生大量不连续碎片问题</p><p><strong>分代收集：</strong></p><p>​根据各个年代的特点选择合适的垃圾收集算法。</p><p>​新生代采用复制算法，新生代每次垃圾回收都要回收大部分对象，存活对象较少，即要复制的操作比较少，一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><p>​老年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</p><p><strong>垃圾收集器：Serial、Parnew、parallel Scavenge、Serialold 、Parnewold、CMS、G1</strong></p><p><strong>Serial：</strong></p><p>​Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。</p><p><strong>Parnew：</strong></p><p>​ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p><p><strong>parallel Scavenge：</strong></p><p>​Parallel Scavenge收集器关注点是吞吐量（⾼效率的利⽤CPU）。CMS等垃圾收集器的关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）；高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。</p><p><strong>Serial old：</strong></p><p>Serial收集器的⽼年代版本，它同样是⼀个单线程收集器，使用标记-整理算法。主要有两个用途：</p><ul><li><p>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</p></li><li><p>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</p></li></ul><p><strong>parallel old：</strong></p><p>​Parallel Scavenge收集器的⽼年代版本。使⽤多线程和“标记-整理”算法。</p><p><strong>CMS：</strong>重要</p><p>​CMS收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p><p>​<strong>初始标记：</strong>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p><p>​<strong>并发标记：</strong>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p><p>​<strong>重新标记：</strong>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</p><p>​<strong>并发清除：</strong>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p><p>​<strong>优点：</strong>并发收集、低停顿</p><p>​<strong>缺点：</strong>对CPU资源敏感；⽆法处理浮动垃圾；使⽤“标记清除”算法，会导致⼤量空间碎⽚产⽣。</p><p><strong>G1：</strong>重要</p><p>​是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征；相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p><p>​【1】基于标记-整理算法，不产生内存碎片。</p><p>​【2】可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p><p>​G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分</strong>和<strong>优先级区域</strong>回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p><p><strong>6、创建一个对象的步骤</strong> </p><p><strong>步骤：类加载检查、分配内存、初始化零值、设置对象头、执行init方法</strong></p><p><strong>①类加载检查：</strong> </p><p>​虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。</p><p><strong>②分配内存：</strong></p><p>​ 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存⼤⼩在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。分配⽅式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。</p><p><strong>③初始化零值：</strong></p><p>​ 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>④设置对象头：</strong> </p><p>​初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p><p><strong>⑤执⾏ init ⽅法：</strong> </p><p>​在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看，对象创建才刚开始， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说，执⾏ new 指令之后会接着执⾏  <init> ⽅法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。</p><p><strong>7、详细介绍类加载过程</strong> </p><p><strong>过程：加载、验证、准备、解析、初始化</strong></p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2723431542,2953407468&fm=26&gp=0.jpg"></p><p><strong>加载阶段：</strong></p><p>​1.通过一个类的全限定名来获取定义此类的二进制字节流。</p><p>​2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>​3.在Java堆中生成一个代表这个类的java.lang.class对象，作为方法区这些数据的访问入口。</p><p><strong>验证阶段：</strong></p><p>​1.文件格式验证（是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理）</p><p>​2.元数据验证（对字节码描述的信息进行语意分析，以保证其描述的信息符合Java语言规范要求）</p><p>​3.字节码验证（保证被校验类的方法在运行时不会做出危害虚拟机安全的行为）</p><p>​4.符号引用验证（虚拟机将符号引用转化为直接引用时，解析阶段中发生）</p><p><strong>准备阶段：</strong></p><p>​准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。将对象初始化为“零”值</p><p><strong>解析阶段：</strong></p><p>​解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p><strong>初始化阶段：</strong></p><p>​初始化阶段时加载过程的最后一步，而这一阶段也是真正意义上开始执行类中定义的Java程序代码。</p><p><strong>8、双亲委派机制，使用这个机制的好处？如何破坏？</strong> </p><p>​每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤ 双亲委派模型 。即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，⾸先会把该请求委派该⽗类加载器的  loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器  BootstrapClassLoader 中。当⽗类加载器⽆法处理时，才由⾃⼰来处理。当⽗类加载器为null时，会使⽤启动类加载器  BootstrapClassLoader 作为⽗类加载器。</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1595226330267&di=5597292eb6bf5505abbec489fd54dacd&imgtype=0&src=http://pics4.baidu.com/feed/ca1349540923dd54fb52494e811379d89c824890.jpeg?token=c280035219d435ec0f1c3a3a0a071101"></p><p><strong>使用好处：</strong></p><p>​此机制保证JDK核心类的优先加载；使得Java程序的稳定运⾏，可以避免类的重复加载，也保证了 Java 的核⼼ API 不被篡改。如果不⽤没有使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我们编写⼀个称为  java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的Object 类。</p><p><strong>破坏双亲委派机制：</strong></p><p>​可以⾃⼰定义⼀个类加载器，重写loadClass方法；</p><p><strong>9、了解下tomcat的类加载机制</strong> </p><p><strong>步骤：</strong></p><ol><li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li><li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li><li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li><li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li><li>加载依然失败，才使用 AppClassLoader 继续加载。</li><li>都没有加载成功的话，抛出异常。</li></ol><p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p><p><strong>10、JVM性能调优，常用命令，以及工具</strong> </p><p>对应进程的JVM状态以定位问题和解决问题并作出相应的优化</p><p><strong>常用命令：</strong>jps、jinfo、jstat、jstack、jmap</p><p><strong>jps：查看java进程及相关信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">jps -l 输出jar包路径，类全名<br>jps -m 输出main参数<br>jps -v 输出JVM参数<br></code></pre></td></tr></table></figure><p><strong>jinfo：查看JVM参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jinfo <span class="hljs-number">11666</span><br>jinfo -flags <span class="hljs-number">11666</span><br></code></pre></td></tr></table></figure><p><strong>jstat：查看JVM运行时的状态信息，包括内存状态、垃圾回收</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">命令格式：<br>jstat [option] LVMID [interval] [count]<br>其中LVMID是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）<br><br>option参数解释：<br>-<span class="hljs-keyword">class</span> <span class="hljs-title class_">class</span> loader的行为统计<br>-compiler HotSpt JIT编译器行为统计<br>-gc 垃圾回收堆的行为统计<br>-gccapacity 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计<br>-gcutil 垃圾回收统计概述<br>-gccause 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因<br>-gcnew 新生代行为统计<br>-gcnewcapacity 新生代与其相应的内存空间的统计<br>-gcold 年老代和永生代行为统计<br>-gcoldcapacity 年老代行为统计<br>-gcpermcapacity 永生代行为统计<br>-printcompilation HotSpot编译方法统计<br></code></pre></td></tr></table></figure><p><strong>jstack：查看JVM线程快照，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">命令格式：<br>jstack [-l] &lt;pid&gt; (连接运行中的进程)<br>jstack -F [-m] [-l] &lt;pid&gt; (连接挂起的进程)<br>jstack [-m] [-l] &lt;executable&gt; &lt;core&gt; (连接core文件)<br>jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt; (连接远程debug服务器)<br><br>option参数解释：<br>-F 当使用jstack &lt;pid&gt;无响应时，强制输出线程堆栈。<br>-m 同时输出java和本地堆栈(混合模式)<br>-l 额外显示锁信息<br></code></pre></td></tr></table></figure><p><strong>jmap：可以用来查看内存信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">命令格式：<br>jmap [option] &lt;pid&gt; (连接正在执行的进程)<br>jmap [option] &lt;executable &lt;core&gt; (连接一个core文件)<br>jmap [option] [server_id@]&lt;remote server IP or hostname&gt; (链接远程服务器)<br><br>option参数解释：<br>&lt;none&gt; to print same info as Solaris pmap<br>-heap 打印java heap摘要<br>-histo[:live] 打印堆中的 java对象统计信息<br>-clstats 打印类加载器统计信息<br>-finalizerinfo 打印在f-queue中等待执行finalizer方法的对象<br>-dump:&lt;dump-options&gt; 生成java堆的dump文件<br>　　　　　　dump-options:<br>　　　　　　live 只转储存活的对象，如果没有指定则转储所有对象<br>　　　　　　format=b 二进制格式<br>　　　　　　file=&lt;file&gt; 转储文件到 &lt;file&gt;<br>-F 强制选项<br></code></pre></td></tr></table></figure><h2 id="四、多线程并发篇"><a href="#四、多线程并发篇" class="headerlink" title="四、多线程并发篇"></a><strong>四、多线程并发篇</strong></h2><p><strong>1、进程线程区别，线程安全和非线程安全区别</strong> </p><p>​进程是程序的运行过程，是资源分配的基本单位，进程中可以包含多个线程，多个线程共享进程中堆、方法区资源</p><p>​线程是cpu任务调度的最小执行单位，每个线程拥有自己独立的程序计数器、虚拟机栈、本地方法栈</p><p><strong>线程安全：</strong>多个线程对同一资源操作，不会互相影响</p><p><strong>非线程安全：</strong>多个线程对同一资源操作，会互相影响</p><p><strong>2、线程状态，start,run,wait,notify,yiled,sleep,join等方法的作用以及区别</strong> </p><p><strong>线程状态：创建、就绪、运行、阻塞、死亡</strong></p><table><thead><tr><th>方法</th><th>作用</th><th>区别</th></tr></thead><tbody><tr><td>start</td><td>启动线程，由虚拟机自动调度执行run()方法</td><td>线程处于就绪状态</td></tr><tr><td>run</td><td>线程逻辑代码块处理，JVM调度执行</td><td>线程处于运行状态</td></tr><tr><td>sleep</td><td>让当前正在执行的线程休眠（暂停执行）</td><td>不释放锁</td></tr><tr><td>wait</td><td>使得当前线程等待</td><td>释放同步锁</td></tr><tr><td>notify</td><td>唤醒在此对象监视器上等待的单个线程</td><td>唤醒单个线程</td></tr><tr><td>notifyAll</td><td>唤醒在此对象监视器上等待的所有线程</td><td>唤醒多个线程</td></tr><tr><td>yiled</td><td>停止当前线程，让同等优先权的线程运行</td><td>用Thread类调用</td></tr><tr><td>join</td><td>使当前线程停下来等待，直至另一个调用join方法的线程终止</td><td>用线程对象调用</td></tr></tbody></table><p><strong>3、wait,notify，notifyAll阻塞唤醒确切过程？</strong> </p><p>在哪阻塞，在哪唤醒？为什么要出现在同步代码块中？</p><p><strong>阻塞：</strong></p><p>​这三个方法的调用都会使当前线程阻塞。该线程将会被放置到对该Object的请求等待队列中，然后让出当前对Object所拥有的所有的同步请求。线程会一直暂停所有线程调度，直到下面其中一种情况发生：</p><p>　　　　① 其他线程调用了该Object的notify方法，而该线程刚好是那个被唤醒的线程；</p><p>　　　　② 其他线程调用了该Object的notifyAll方法；</p><p><strong>唤醒：</strong></p><p>​线程将会从等待队列中移除，重新成为可调度线程。它会与其他线程以常规的方式竞争对象同步请求。<strong>一旦它重新获得对象的同步请求，所有之前的请求状态都会恢复，也就是线程调用wait的地方的状态。线程将会在之前调用wait的地方继续运行下去。</strong></p><p><strong>原因：</strong></p><p>​由于<code>wait()属于Object方法，调用之后会强制释放当前对象锁，所以在wait()</code> 调用时必须拿到当前对象的监视器monitor对象。因此，wait()方法在同步方法&#x2F;代码块中调用。</p><p><strong>4、守护线程，线程中断</strong> </p><p><strong>守护线程：</strong></p><p>​     t.setDaemon(true)为守护线程，也叫精灵线程，若主线程启动t线程,则t线程是主线程的守护线程，当主线程执行完了，则守护线程也随之结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDaemon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadDaemon</span><span class="hljs-params">(String name)</span>&#123;<br><span class="hljs-built_in">super</span>(name);<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程运行了。。。&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDaemon</span>(<span class="hljs-string">&quot;线程一&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDaemon</span>(<span class="hljs-string">&quot;线程二&quot;</span>);<br><span class="hljs-comment">//设置为守护线程</span><br>t1.setDaemon(<span class="hljs-literal">true</span>);<br>t2.setDaemon(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//启动线程</span><br>t1.start();<br>t2.start();<br><span class="hljs-comment">//主线程2s后退出</span><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>线程中断：</strong></p><p>​t.interrupt();调用interrupt()不会让线程立即中断，只是线程的中断状态发生变化，系统会在后续中断该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadInterrupt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadInterrupt</span><span class="hljs-params">(String name)</span>&#123;<br><span class="hljs-built_in">super</span>(name);<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(!interrupted())&#123;<span class="hljs-comment">//中断状态判断</span><br>System.err.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程运行了。。。&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadInterrupt</span>(<span class="hljs-string">&quot;线程一&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadInterrupt</span>(<span class="hljs-string">&quot;线程二&quot;</span>);<br><span class="hljs-comment">//启动线程</span><br>t1.start();<br>t2.start();<br>t1.interrupt();<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5、Java乐观锁机制，CAS思想？缺点？是否原子性？如何保证？</strong> </p><p><strong>java乐观锁机制：</strong></p><p>​乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的。但是乐观锁在更新的时候会去判断数据是否被更新过。乐观锁的实现方案一般有两种（版本号机制和CAS）。乐观锁适用于<strong>读多写少的场景，这样可以提高系统的并发量</strong>。在Java中 <strong>java.util.concurrent.atomic</strong>下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>　　乐观锁，大多是基于数据版本  (Version)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p><strong>CAS思想：</strong></p><p>​CAS就是compare and swap（<strong>比较交换</strong>），是一种很出名的无锁的算法，就是可以不使用锁机制实现线程间的同步。使用CAS线程是不会被阻塞的，所以又称为非阻塞同步。CAS算法涉及到三个操作：</p><p>​需要读写内存值V；</p><p>​进行比较的值A；</p><p>​准备写入的值B</p><p>​当且仅当V的值等于A的值等于V的值的时候，才用B的值去更新V的值，否则不会执行任何操作（比较和替换是一个原子操作-A和V比较，V和B替换），一般情况下是一个<strong>自旋操作</strong>，即<strong>不断重试</strong></p><p><strong>缺点：</strong></p><p>​<a href="https://www.zhihu.com/question/23281499/answer/854522984">ABA问题-知乎</a></p><p>​高并发的情况下，很容易发生并发冲突，如果CAS一直失败，那么就会一直重试，浪费CPU资源</p><p><strong>原子性：</strong></p><p>​功能限制CAS是能保证单个变量的操作是原子性的，在Java中要配合使用volatile关键字来保证线程的安全；当涉及到多个变量的时候CAS无能为力；除此之外CAS实现需要硬件层面的支持，在Java的普通用户中无法直接使用，只能<strong>借助atomic包下的原子类</strong>实现，灵活性受到了限制</p><p><strong>6、synchronized使用方法？底层实现？</strong> </p><p><strong>使用方法：</strong>主要的三种使⽤⽅式</p><p>​<strong>修饰实例⽅法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁</p><p>​<strong>修饰静态⽅法:</strong> 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管new了多少个对象，只有⼀份）。所以如果⼀个线程A调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程B需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。</p><p>​<strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。</p><p>​<strong>总结：</strong>synchronized锁住的资源只有两类：一个是<strong>对象</strong>，一个是<strong>类</strong>。</p><p><strong>底层实现：</strong></p><p>​对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由<code>Mark Word</code> 和 <code>Class Metadata Address</code>组成，<strong>其中<code>Mark Word</code>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</strong>，**<code>Class Metadata Address</code>是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例**。</p><p>​锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁</strong>，其中无锁就是一种状态了。锁的类型和状态在对象头<code>Mark Word</code>中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的<code>Mark Word</code>数据。</p><p>​每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。</p><p><strong>7、ReenTrantLock使用方法？底层实现？和synchronized区别？</strong> </p><p>​由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下三项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。<br><br><span class="hljs-number">2.</span>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数<span class="hljs-literal">true</span>设为公平锁，但公平锁表现的性能不是很好。<br><span class="hljs-number">3.</span>锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像<span class="hljs-keyword">synchronized</span>要么随机唤醒一个线程要么唤醒全部线程。<br>   <br></code></pre></td></tr></table></figure><p><strong>使用方法：</strong></p><p>​基于API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成</p><p><strong>底层实现：</strong></p><p>​ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p><p><strong>和synchronized区别：</strong></p><p>​1、<strong>底层实现</strong>上来说，synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），对象只有在同步块或同步方法中才能调用wait&#x2F;notify方法；ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。synchronized 的实现涉及到锁的升级，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁；ReentrantLock实现则是通过利用CAS（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。</p><p>​3、<strong>是否可手动释放：</strong>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try&#x2F;finally语句块来完成，使用释放更加灵活。</p><p>​4、<strong>是否可中断</strong>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p><p>​5、<strong>是否公平锁</strong>synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。</p><p><strong>8、公平锁和非公平锁区别？为什么公平锁效率低？</strong> </p><p><strong>公平锁：</strong></p><p>​公平锁自然是遵循<strong>FIFO</strong>（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待</p><p>​<strong>优点：</strong>所有的线程都能得到资源，不会饿死在队列中。</p><p>​<strong>缺点：</strong>吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大</p><p><strong>非公平锁：</strong></p><p>​多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><p>​<strong>优点：</strong>可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</p><p>​<strong>缺点：</strong>你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁</p><p><strong>公平锁效率低原因：</strong></p><p>​公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面线程。这种情况下相比较非公平锁多了一次<strong>挂起和唤醒</strong>。</p><p>​<strong>线程切换的开销</strong>，其实就是非公平锁效率高于公平锁的原因，因为<strong>非公平锁减少了线程挂起的几率</strong>，后来的线程有一定几率逃离被挂起的开销。</p><p><strong>9、锁优化。自旋锁、自适应自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、重量级锁解释</strong> </p><p><strong>锁优化：</strong></p><p>​【1】<strong>减少锁的时间：</strong><br>​不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p><p>​【2】<strong>减少锁的粒度：</strong><br>​它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；java中很多数据结构都是采用这种方法提高并发操作的效率，比如：</p><p>​<strong>ConcurrentHashMap：</strong></p><p>​java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组：Segment&lt; K,V &gt;[] segments</p><p>​Segment继承自ReenTrantLock，所以每个Segment是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</p><p>Segment继承自ReenTrantLock，所以每个Segment就是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</p><p>​【3】<strong>锁粗化：</strong><br>​大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度; </p><p>​在以下场景下需要粗化锁的粒度： </p><p>​假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p><p>​【4】<strong>使用读写锁：</strong></p><p>​ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可并发读，写操作使用写锁，只能单线程写；</p><p>​【5】<strong>使用cas：</strong></p><p>​如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择；</p><p><strong>自旋锁：</strong></p><p>​自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做<strong>内核态和用户态之间的切换</strong>进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就<strong>避免用户线程和内核的切换的消耗</strong>。</p><p>​<strong>缺点：</strong>如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销；自旋次数默认值是10</p><p><strong>自适应自旋锁：</strong></p><p>​对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点</p><p><strong>锁消除：</strong></p><p>​锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。</p><p><strong>锁粗化：</strong></p><p>​假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p><p><strong>偏向锁：</strong></p><p>​所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程；也就是说，这个线程已经占有这个锁，当他在次试图去获取这个锁的时候，他会已最快的方式去拿到这个锁，而不需要在进行一些monitor操作，因此这方面他是会对性能有所提升的，因为在大部分情况下是没有竞争的，所以锁此时是没用的，所以使用偏向锁是可以提高性能的；</p><p><strong>重量级锁：</strong></p><p>​重量级锁的加锁、解锁过程和轻量级锁差不多，区别是：竞争失败后，线程阻塞，释放锁后，唤醒阻塞的线程，不使用自旋锁，不会那么消耗CPU，所以重量级锁适合用在同步块执行时间长的情况下。</p><p><strong>10、Java内存模型</strong> </p><p>​Java 内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p>​JMM 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</p><p>​所以，Java 内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。我们前面提到，并发编程要解决<strong>原子性</strong>、<strong>有序性</strong>和<strong>一致性</strong>的问题。</p><p><strong>原子性：</strong></p><p>​在 Java 中，为了保证原子性，提供了两个高级的字节码指令 Monitorenter 和 Monitorexit。这两个字节码，在 Java 中对应的关键字就是 Synchronized。因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。</p><p><strong>可见性：</strong></p><p>​Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。Java 中的 Volatile 关键字修饰的变量在被修改后可以立即同步到主内存。被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 Volatile 来保证多线程操作时变量的可见性。除了 Volatile，Java 中的 Synchronized 和 Final 两个关键字也可以实现可见性。只不过实现方式不同</p><p><strong>有序性</strong></p><p>​在 Java 中，可以使用 Synchronized 和 Volatile 来保证多线程之间操作的有序性。区别：Volatile 禁止指令重排。Synchronized 保证同一时刻只允许一条线程操作。</p><p><strong>11、volatile作用？底层实现？单例模式中volatile的作用？</strong> </p><p><strong>作用：</strong></p><p>​保证数据的“可见性”：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p><p>​禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致</p><p><strong>底层实现：</strong></p><p>​“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p><strong>单例模式中volatile的作用：</strong></p><p>防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;   <span class="hljs-comment">//禁止指令重排</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>         <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>12、AQS思想，以及基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍</strong> </p><p>​AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器，是⼀个⽤来构建锁和同步器的框架，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，如：基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore</p><p>​AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH（虚拟的双向队列）队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。</p><p><strong>lock：</strong></p><p>​是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。默认为非公平锁，但可以初始化为公平锁； 通过方法 lock()与 unlock()来进行加锁与解锁操作；</p><p><strong>CountDownLatch：</strong></p><p>​通过计数法（倒计时器），让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒；该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。</p><p>​假设我们有这么一个场景，教室里有班长和其他6个人在教室上自习，怎么保证班长等其他6个人都走出教室在把教室门给关掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLanchDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 离开了教室...&quot;</span>);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;班长把门给关了，离开了教室...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此时输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> 离开了教室...<br><span class="hljs-number">1</span> 离开了教室...<br><span class="hljs-number">2</span> 离开了教室...<br><span class="hljs-number">3</span> 离开了教室...<br>班长把门给关了，离开了教室...<br><span class="hljs-number">5</span> 离开了教室...<br><span class="hljs-number">4</span> 离开了教室...<br></code></pre></td></tr></table></figure><p>发现班长都没有等其他人理他教室就把门给关了，此时我们就可以使用 CountDownLatch 来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLanchDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                countDownLatch.countDown();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 离开了教室...&quot;</span>);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;班长把门给关了，离开了教室...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此时输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> 离开了教室...<br><span class="hljs-number">1</span> 离开了教室...<br><span class="hljs-number">2</span> 离开了教室...<br><span class="hljs-number">3</span> 离开了教室...<br><span class="hljs-number">4</span> 离开了教室...<br><span class="hljs-number">5</span> 离开了教室...<br>班长把门给关了，离开了教室...<br></code></pre></td></tr></table></figure><p><strong>CyclicBarrier：</strong></p><p>​字面意思是可循环(Cyclic)使用的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。</p><p>我们假设有这么一个场景，每辆车只能坐4个人，当车满了，就发车。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">4</span>, () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;车满了，开始出发...&quot;</span>);<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 开始上车...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    cyclicBarrier.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span> 开始上车...<br>Thread-<span class="hljs-number">1</span> 开始上车...<br>Thread-<span class="hljs-number">3</span> 开始上车...<br>Thread-<span class="hljs-number">4</span> 开始上车...<br>车满了，开始出发...<br>Thread-<span class="hljs-number">5</span> 开始上车...<br>Thread-<span class="hljs-number">7</span> 开始上车...<br>Thread-<span class="hljs-number">2</span> 开始上车...<br>Thread-<span class="hljs-number">6</span> 开始上车...<br>车满了，开始出发...<br></code></pre></td></tr></table></figure><p><strong>Semaphore：</strong></p><p>​信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。</p><p>假设我们有 3 个停车位，6 辆车去抢；指定多个线程同时访问某个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  semaphore.acquire(); <span class="hljs-comment">// 获取一个许可</span><br>                  System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 抢到车位...&quot;</span>);<br>                  Thread.sleep(<span class="hljs-number">3000</span>);<br>                  System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 离开车位&quot;</span>);<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>              &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  semaphore.release(); <span class="hljs-comment">// 释放一个许可</span><br>              &#125;<br>          &#125;).start();<br>      &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**输出</span><br><span class="hljs-comment">Thread-1 抢到车位...</span><br><span class="hljs-comment">Thread-2 抢到车位...</span><br><span class="hljs-comment">Thread-0 抢到车位...</span><br><span class="hljs-comment">Thread-2 离开车位</span><br><span class="hljs-comment">Thread-0 离开车位</span><br><span class="hljs-comment">Thread-3 抢到车位...</span><br><span class="hljs-comment">Thread-1 离开车位</span><br><span class="hljs-comment">Thread-4 抢到车位...</span><br><span class="hljs-comment">Thread-5 抢到车位...</span><br><span class="hljs-comment">Thread-3 离开车位</span><br><span class="hljs-comment">Thread-5 离开车位</span><br><span class="hljs-comment">Thread-4 离开车位</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>13、线程池构造函数7大参数，线程处理任务过程，线程拒绝策略</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 线程池构造函数7大参数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,<span class="hljs-type">int</span> maximumPoolSize,<span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">    TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,</span><br><span class="hljs-params">    RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||maximumPoolSize &lt;= <span class="hljs-number">0</span> ||maximumPoolSize &lt; corePoolSize ||<br>    keepAliveTime &lt; <span class="hljs-number">0</span>)<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>   <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>        <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>        <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>        <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程池大小</td></tr><tr><td>maximumPoolSize</td><td>最大线程池大小</td></tr><tr><td>keepAliveTime</td><td>线程池中超过 corePoolSize 数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true) 使得核心线程有效时间</td></tr><tr><td>TimeUnit</td><td>keepAliveTime 时间单位</td></tr><tr><td>workQueue</td><td>阻塞任务队列</td></tr><tr><td>threadFactory</td><td>新建线程工厂</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略。当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理</td></tr></tbody></table><p><strong>线程拒绝策略：</strong> </p><p>​线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。</p><p>JDK 内置的拒绝策略如下：</p><p>​<strong>AbortPolicy：</strong>直接抛出异常，阻止系统正常运行。</p><p>​<strong>CallerRunsPolicy ：</strong>只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</p><p>​<strong>DiscardOldestPolicy ：</strong>丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p><p>​<strong>DiscardPolicy ：</strong>该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</p><p><strong>线程处理任务过程：</strong></p><ol><li>当线程池小于corePoolSize，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li><li>当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。</li><li>当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。</li><li>当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。</li><li>当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。</li></ol><p><strong>14、Execuors类实现的几种线程池类型，阿里为啥不让用？</strong> </p><ul><li><strong>Executors.newSingleThreadExecutor()：</strong>只有一个线程的线程池，因此所有提交的任务是顺序执行，适用于一个一个任务执行的场景</li><li><strong>Executors.newCachedThreadPool()：</strong>线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除，适用执行很多短期异步的小程序或者负载较轻的服务</li><li><strong>Executors.newFixedThreadPool()：</strong>拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，适用执行长期的任务，性能好很多。</li><li><strong>Executors.newScheduledThreadPool()：</strong>用来调度即将执行的任务的线程池</li></ul><p><strong>因为以上方式都存在弊端：</strong></p><p>​FixedThreadPool 和 SingleThreadExecutor ： 允许请求的<strong>队列⻓度</strong>为 Integer.MAX_VALUE，可能堆积⼤量的请求，从⽽导致OOM。<br>​CachedThreadPool 和 ScheduledThreadPool ： 允许创建的<strong>线程数量</strong>为 Integer.MAX_VALUE，可能会创建⼤量线程，从⽽导致OOM。</p><p><strong>15、线程池大小如何设置？</strong> </p><ul><li><p>CPU 密集型</p></li><li><ul><li>CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</li><li>CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。</li></ul></li><li><p>IO 密集型</p></li><li><ul><li>由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2 </li><li>也可以使用公式：CPU 核数 &#x2F; (1 - 阻塞系数)；其中阻塞系数在 0.8 ～ 0.9 之间。</li></ul></li></ul><p><strong>16、手写简单的线程池，体现线程复用</strong> </p><p><a href="https://blog.csdn.net/hongtaolong/article/details/87808009">https://blog.csdn.net/hongtaolong/article/details/87808009</a></p><p><strong>17、手写消费者生产者模式</strong> </p><p><a href="https://www.cnblogs.com/liuqing576598117/p/11233250.html">https://www.cnblogs.com/liuqing576598117/p/11233250.html</a></p><p><strong>18、手写阻塞队列</strong> </p><p><a href="https://www.cnblogs.com/keeya/p/9713686.html">https://www.cnblogs.com/keeya/p/9713686.html</a></p><p><strong>19、手写多线程交替打印ABC</strong> </p><p><a href="https://blog.csdn.net/xiaokang123456kao/article/details/77331878">https://blog.csdn.net/xiaokang123456kao/article/details/77331878</a></p><h2 id="五、MySQL篇"><a href="#五、MySQL篇" class="headerlink" title="五、MySQL篇"></a><strong>五、MySQL篇</strong></h2><p><strong>1、事务4大特性？这4个特性mysql如何保证实现的？</strong> </p><p><strong>事务4大特性：</strong>原子性、一致性、隔离性、持久性</p><p>​<strong>原⼦性：</strong> 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行</p><p>​<strong>一致性：</strong> 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；</p><p>​<strong>隔离性：</strong> 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</p><p>​<strong>持久性：</strong> ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p><p><strong>实现保证：</strong></p><p>​MySQL的存储引擎InnoDB使用重做日志保证一致性与持久性，回滚日志保证原子性，使用各种锁来保证隔离性。</p><p><strong>2、事务隔离级别，4个隔离级别分别有什么并发问题？</strong> </p><p><strong>读未提交：</strong>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p><strong>读已提交：</strong>允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p><p><strong>可重复读：</strong>同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</p><p><strong>可串行化：</strong>最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及幻读。</p><table><thead><tr><th>隔离级别</th><th>并发问题</th></tr></thead><tbody><tr><td>读未提交</td><td>可能会导致脏读、幻读或不可重复读</td></tr><tr><td>读已提交</td><td>可能会导致幻读或不可重复读</td></tr><tr><td>可重复度</td><td>可能会导致幻读</td></tr><tr><td>可串行化</td><td>不会产⽣⼲扰</td></tr></tbody></table><p><strong>3、Mysql默认隔离级别？如何保证并发安全？</strong> </p><p><strong>默认隔离级别：</strong>可重复读；</p><p>​同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改；</p><p>​可重复读是有可能出现幻读的，如果要保证绝对的安全只能把隔离级别设置成SERIALIZABLE；这样所有事务都只能顺序执行，自然不会因为并发有什么影响了，但是性能会下降许多。</p><p>​第二种方式，使用更新的版本控制。维护一个字段作为updateversion，修改时updateversion也作为一个参数传入，在条件语句中添加例如<code>where id=? and update_version = ?</code> 当然set里面要update_version+1。这样可以控制到每次只能有一个人更新一个版本。</p><p><strong>4、RR和RC如何实现的？RR使用场景？</strong></p><p>​事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。</p><p>​由于RC隔离级别需要保持语句级别的一致性，事务中每一次读取都是访问当前时间点的已提交数据，因此事务中多条查询语句会创建多个不同的ReadView，开销较大，复杂度更高；而对于RR隔离级别，仅需要一个版本的ReadView，消耗更少，因此Mysql默认使用RR隔离级别。</p><p>​RC隔离级别获得的是语句级读一致性；RR隔离级别获得的是事务级读一致性</p><p>​对于RC隔离级别，访问的数据是每次语句执行时间点的数据，而对于RR隔离级别，访问的数据是事务中第一条语句执行时间点的数据。</p><p><strong>5、隔离级别的单位是数据表还是数据行？如串行化级别，两个事务访问不同的数据行，能并发？</strong> </p><p>​读未提交：不加锁</p><p>​读已提交：加行锁，只锁要修改的行</p><p>​可重复读：加行锁，锁定的是查询的行</p><p>​可串行化：加表锁，在读取的每张表上加锁</p><p>​<strong>串行化级别：读不同的行，可以并发</strong></p><p><strong>6、存储引擎Innodb和Myisam的区别以及使用场景</strong> </p><p><strong>Myisam：</strong>支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件</p><p><strong>Innodb：</strong>支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件</p><p><strong>7、 介绍Inodb锁机制，行锁，表锁，意向锁</strong> </p><p><strong>InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁</strong></p><p>InnoDB按照不同的分类的锁：</p><p>共享&#x2F;排它锁(Shared and Exclusive Locks)：行级别锁，</p><p>意向锁(Intention Locks)，表级别锁</p><p>间隙锁(Gap Locks)，锁定一个区间</p><p>记录锁(Record Locks)，锁定一个行记录</p><p><strong>表级锁：</strong></p><p>​Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p><p><strong>行级锁：</strong></p><p>​Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种：</p><p>​<strong>记录锁（Record Lock）:</strong> 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</p><p>​<strong>间隙锁（Gap Lock）:</strong> 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p><p>​<strong>Next-key Lock：</strong> 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p><p><strong>意向锁：</strong></p><p>​当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个<strong>意向共享锁</strong>。如果需要的是某行（或者某些行）的排他锁定，则申请一个<strong>意向排他锁</strong>。</p><p><strong>8、介绍MVCC.</strong> </p><p>​MVCC是一种多版本并发控制机制，在大多数情况下代替行级锁,使用MVCC,能降低其系统开销.</p><p>​MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制.</p><p>​InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.</p><p>​InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.</p><p>​1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.</p><p>​2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</p><p>​原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，我们认为他就是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。</p><p><strong>9、哈希索引是如何实现的？</strong> </p><p>​哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能</p><p><strong>10、数据库索引为什么使用B+树，相对于B树有什么优点？为什么不能红黑树？</strong> </p><p><strong>因为：</strong></p><p>​ B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描</p><p>​相对B树，B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是<strong>为了提高范围查找的效率，解决数据库遍历效率低下问题</strong>；<strong>B+树只有叶节点存放数据，其余节点用来索引，而B树是每个索引节点都会有Data域。</strong></p><p>​在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。</p><p>​<strong>磁盘预读原理</strong>：将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p><p><strong>11、聚簇索引和非聚簇索引区别</strong> </p><p>​<strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</p><p>​<strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置</p><p>​聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p><p><strong>12、回表查询和覆盖索引</strong> </p><p>普通索引 需要扫描两遍索引树</p><p>（1）先通过普通索引定位到主键值id&#x3D;5；</p><p>（2）在通过聚集索引定位到行记录；</p><p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><p><strong>覆盖索引</strong>：如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p><p><strong>实现覆盖索引</strong>：常见的方法是，将被查询的字段，建立到联合索引里去。</p><p><strong>13、如何创建索引？</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段名 数据类型 [完整性约束条件],<br>       ……，<br>[<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] INDEX <span class="hljs-operator">|</span> KEY<br>[索引名](字段名<span class="hljs-number">1</span> [(长度)] [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]) [<span class="hljs-keyword">USING</span> 索引方法]<br>);<br><br>说明：<br><span class="hljs-keyword">UNIQUE</span>:可选。表示索引为唯一性索引。<br>FULLTEXT:可选。表示索引为全文索引。<br>SPATIAL:可选。表示索引为空间索引。<br>INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。<br>索引名:可选。给创建的索引取一个新名称。<br>字段名<span class="hljs-number">1</span>:指定索引对应的字段的名称，该字段必须是前面定义好的字段。<br>长度:可选。指索引的长度，必须是字符串类型才可以使用。<br><span class="hljs-keyword">ASC</span>:可选。表示升序排列。<br><span class="hljs-keyword">DESC</span>:可选。表示降序排列。<br>注：索引方法默认使用B<span class="hljs-operator">+</span>TREE。<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL]  INDEX <span class="hljs-operator">|</span> KEY  [索引名] (字段名<span class="hljs-number">1</span> [(长度)] [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]) [<span class="hljs-keyword">USING</span> 索引方法]；<br><br>或<br><br><span class="hljs-keyword">CREATE</span>  [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL]  INDEX  索引名 <span class="hljs-keyword">ON</span>  表名(字段名) [<span class="hljs-keyword">USING</span> 索引方法]；<br></code></pre></td></tr></table></figure><p><strong>14、如何避免全表扫描？</strong> </p><p>1.对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2.应尽量避免在 where 子句中对字段进行 null 值判断</p><p>3.应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符</p><p>4.in 和 not in 要慎用</p><p>否则将导致引擎放弃使用索引而进行全表扫描</p><p><strong>15、Explain语句各字段的意义</strong> </p><p>参考：<a href="https://www.jianshu.com/p/8fab76bbf448">https://www.jianshu.com/p/8fab76bbf448</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from staff;<br>+----+-------------+-------+------+---------------+------+---------+------+------+-------+<br>| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |<br>+----+-------------+-------+------+---------------+------+---------+------+------+-------+<br>|  1 | SIMPLE      | staff | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |<br>+----+-------------+-------+------+---------------+------+---------+------+------+-------+<br>1 row in set<br></code></pre></td></tr></table></figure><table><thead><tr><th>列</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>查询序号，序号越大越先执行，一样则按顺序执行</td></tr><tr><td>select_type</td><td>查询类型，SIMPLE、PRIMARY、UNION、SUBQUERY等</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>type</td><td>join类型，const，eq_ref，ref等</td></tr><tr><td>possible_keys</td><td>join类型</td></tr><tr><td>key</td><td>实际选择的索引</td></tr><tr><td>ken_len</td><td>索引的长度</td></tr><tr><td>ref</td><td>与索引作比较的列</td></tr><tr><td>rows</td><td>要检索的行数</td></tr><tr><td>Extra</td><td>额外信息</td></tr></tbody></table><p>**16、最左前缀！！联合索引B+树是如何建立的？是如何查询的？当where子句中出现&gt;时，联合索引命中是如何的? ** </p><p>​最左前缀原则主要使用在联合索引中，联合索引的B+Tree是按照第一个关键字进行索引排列的。</p><p>​联合索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p><p>​采用&gt;、&lt;等进行匹配都会导致后面的列无法走索引，因为通过以上方式匹配到的数据是不可知的。</p><p><strong>17、MySQL中一条SQL语句的执行过程</strong> </p><p>参考：<a href="https://zhuanlan.zhihu.com/p/126722329">https://zhuanlan.zhihu.com/p/126722329</a></p><p><strong>查询语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student  A where A.age=&#x27;18&#x27; and A.name=&#x27;张三&#x27;;<br></code></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p><ul><li>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在mysql8.0版本以前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</li><li>通过分析器进行词法分析，提取sql语句的关键元素，比如提取上面这个语句是查询select，提取需要查询的表名为tb_student,需要查询所有的列，查询条件是这个表的id&#x3D;’1’。然后判断这个sql语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li><li>接下来就是优化器进行确定执行方案，上面的sql语句，可以有两种执行方案： a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是18。 b.先找出学生中年龄18岁的学生，然后再查询姓名为“张三”的学生。 那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</li><li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li></ul><p><strong>更新语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update student A set A.age=&#x27;19&#x27; where A.name=&#x27;张三&#x27;;<br></code></pre></td></tr></table></figure><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，mysql 自带的日志模块式binlog（归档日志），所有的存储引擎都可以使用，我们常用的InnoDB引擎还自带了一个日志模块redo log，我们就以InnoDB模式下来探讨这个语句的执行流程。流程如下：</p><ul><li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li><li>然后拿到查询的语句，把 age 改为19，然后调用引擎API接口，写入这一行数据，InnoDB引擎把数据保存在内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录binlog，然后调用引擎接口，提交redo log 为提交状态。</li><li>更新完成。</li></ul><p><strong>18、数据库几大范式</strong> </p><p>参考：<a href="https://blog.csdn.net/w__yi/article/details/19934319?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">数据库范式</a></p><p><strong>第一范式（1NF）列不可分割</strong></p><p><strong>第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]</strong></p><p><strong>第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]</strong></p><p><strong>19、left join,right join,inner join,outer join的含义及区别</strong> </p><p><img src="https://image-static.segmentfault.com/276/780/2767807589-5c122586a23c4_articlex"></p><p>left join(左联接) 返回包括左表中的所有记录和右表中关联字段相等的记录 </p><p>right join(右联接) 返回包括右表中的所有记录和左表中关联字段相等的记录</p><p>inner join(等值连接) 只返回两个表中关联字段相等的行</p><p><strong>20、mysql主从复制过程，binlog记录格式，异步复制、同步复制、半同步复制模式区别</strong> </p><p><strong>MySQl主从复制：</strong></p><ul><li><strong>原理</strong>：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。</li><li><strong>过程</strong>：从库开启一个I&#x2F;O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</li><li><strong>优点</strong>：<ul><li>作为备用数据库，并且不影响业务</li><li>可做读写分离，一般是一个写库，一个或多个读库，分布在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性</li></ul></li></ul><p><strong>binlog记录格式：</strong>statement、row、mixed</p><p>​基于语句statement的复制、基于行row的复制、基于语句和行（mix）的复制。其中基于row的复制方式更能保证主从库数据的一致性，但日志量较大，在设置时考虑磁盘的空间问题</p><p><strong>异步复制：</strong></p><p>​在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能会造成数据的不一致。</p><p><strong>半同步复制：</strong></p><p>​当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，所以这样就保证了一个事务至少有两份日志，一份保存在主库的Binlog，另一份保存在其中一个从库的Relay-log中，从而保证了数据的安全性和一致性。</p><p><strong>全同步复制：</strong></p><p>​指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p><p><strong>21、主从复制或读写分离等数据不一致性问题以及如何解决</strong> </p><p>“主从复制有延时”，这个延时期间读取从库，可能读到不一致的数据。</p><p><strong>半同步复制法：</strong></p><p>​当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，所以这样就保证了一个事务至少有两份日志，一份保存在主库的Binlog，另一份保存在其中一个从库的Relay-log中，从而保证了数据的安全性和一致性。</p><p><strong>全同步复制法：</strong></p><p>​指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p><p><strong>缓存记录写key法：</strong></p><p>​在cache里记录哪些记录发生过的写请求，来路由读主库还是读从库</p><p><strong>22、银行的话，可能会考mysql数据类型，如余额要用decimal</strong> </p><p>​</p><h2 id="六、Redis篇"><a href="#六、Redis篇" class="headerlink" title="六、Redis篇"></a><strong>六、Redis篇</strong></h2><p><strong>1、为什么使用Redis</strong></p><p>​速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；</p><p>​与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><p>​</p><p><strong>2、分布式缓存和本地缓存有啥区别？让你自己设计本地缓存怎么设计？如何解决缓存过期问题？如何解决内存溢出问题？</strong></p><p>​分布式缓存一致性更好一点，用于集群环境下多节点使用同一份缓存的情况；有网络IO，吞吐率与缓存的数据大小有较大关系；</p><p>​本地缓存非常高效，本地缓存会占用堆内存，影响垃圾回收、影响系统性能。</p><p><strong>本地缓存设计：</strong></p><p>​以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p><strong>解决缓存过期：</strong></p><p>​1、将缓存过期时间调为永久</p><p>​2、将缓存失效时间分散开，不要将缓存时间长度都设置成一样；比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><p><strong>解决内存溢出：</strong></p><p>​<strong>第一步</strong>，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p><p>　<strong>第二步</strong>，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</p><p>　<strong>第三步</strong>，对代码进行走查和分析，找出可能发生内存溢出的位置。</p><p><strong>3、redis和<em>Mem</em>cached的区别</strong> </p><table><thead><tr><th>redis</th><th>Memcached</th></tr></thead><tbody><tr><td>内存高速数据库</td><td>高性能分布式内存缓存数据库，可缓存图片、视频</td></tr><tr><td>支持hash、list、set、zset、string结构</td><td>只支持key-value结构</td></tr><tr><td>将大部分数据放到内存</td><td>全部数据放到内存中</td></tr><tr><td>支持持久化、主从复制备份</td><td>不支持数据持久化及数据备份</td></tr><tr><td>数据丢失可通过AOF恢复</td><td>挂掉后，数据不可恢复</td></tr></tbody></table><p><strong>使用场景：</strong></p><p>​1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。<br>​2、如果简单的key&#x2F;value 存储应该选择memcached。</p><p><strong>4、redis常用数据结构和使用场景</strong> </p><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash</p><table><thead><tr><th>类型</th><th>存储值</th><th>应用场景</th></tr></thead><tbody><tr><td>String</td><td>字符串、整数、浮点数</td><td>简单的键值对缓存</td></tr><tr><td>List</td><td>列表</td><td>存储列表型数据结构，例如：评论列表、商品列表</td></tr><tr><td>Set</td><td>无序集合</td><td>适合交集、并集、查集操作，例如朋友关系</td></tr><tr><td>Zset</td><td>有序集合</td><td>去重后排序，适合排名场景</td></tr><tr><td>Hash</td><td>哈希</td><td>结构化数据，比如存储对象</td></tr></tbody></table><p><strong>Redis的应用场景：</strong></p><p><strong>计数器</strong></p><p>​可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><p><strong>缓存</strong></p><p>​将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><p><strong>会话缓存</strong></p><p>​可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><p><strong>其它</strong></p><p>​Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><p><strong>5、Zset底层实现？跳表搜索插入删除过程？</strong> </p><p>​跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度</p><p>​Zset数据量少的时候使用压缩链表ziplist实现，有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。</p><p>​ 数据量大的时候使用跳跃列表skiplist和哈希表hash_map结合实现，查找删除插入的时间复杂度都是O(longN)</p><p><strong>搜索</strong></p><p>​跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 <em>O(logN)，最坏 O(N) 。</em></p><p><strong>插入</strong></p><p>  之前就说了，之所以选用链表作为底层结构支持，也是为了高效地动态增删。单链表在知道删除的节点是谁时，时间复杂度为O(1)，因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。</p><p><strong>删除</strong></p><p>  删除的节点要分两种情况，如果该节点还在索引中，那删除时不仅要删除单链表中的节点，还要删除索引中的节点；另一种情况是删除的节点只在链表中，不在索引中，那只需要删除链表中的节点即可。但针对单链表来说，删除时都需要拿到前驱节点才可改变引用关系从而删除目标节点。</p><p><strong>6、redis过期淘汰策略</strong> </p><p><strong>1）全局的键空间选择性移除</strong></p><p>​<strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。</p><p>​<strong>allkeys-lru</strong>：在键空间中，移除最近最少使用的key。（这个是最常用的）</p><p>​<strong>allkeys-random</strong>：在键空间中，随机移除某个key。</p><p><strong>2）设置过期时间的键空间选择性移除</strong></p><p>​<strong>volatile-lru</strong>：在设置了过期时间的键空间中，移除最近最少使用的key。</p><p>​<strong>volatile-random</strong>：在设置了过期时间的键空间中，随机移除某个key。</p><p>​<strong>volatile-ttl</strong>：在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p><p><strong>总结</strong></p><p>​Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p><p><strong>7、redis持久化机制？都有什么优缺点？持久化的时候还能接受请求吗？</strong> </p><p>持久化就是把内存中的数据持久化到本地磁盘，防止服务器宕机了内存数据丢失</p><p>Redis 提供两种持久化机制 <strong>RDB（默认）</strong> 和 <strong>AOF 机制</strong></p><p><strong>RDB：</strong>是Redis DataBase缩写快照</p><p>​RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p>​<strong>优点：</strong></p><p>​1）只有一个文件 dump.rdb，方便持久化；</p><p>​2）容灾性好，一个文件可以保存到安全的磁盘。</p><p>​3）性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能。</p><p>​4）相对于数据集大时，比 AOF 的启动效率更高。</p><p>​<strong>缺点：</strong></p><p>​1）数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p><p><strong>AOF：持久化</strong></p><p>​AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p><p>​<strong>优点：</strong></p><p>​1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p><p>​2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><p><strong>缺点：</strong></p><p>​1）AOF 文件比 RDB 文件大，且恢复速度慢。</p><p>​2）数据集大的时候，比 rdb 启动效率低。</p><p><strong>8、redis事务</strong> </p><p>​事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p><strong>Redis事务的概念</strong></p><p>​Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p><p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><p><strong>事务命令：</strong></p><p><strong>MULTI：</strong>用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p><p><strong>EXEC：</strong>执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</p><p><strong>WATCH ：</strong>是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p><p><strong>DISCARD：</strong>调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。</p><p><strong>UNWATCH</strong>：命令可以取消watch对所有key的监控。</p><p><strong>9、缓存雪崩和缓存穿透，以及解决方法</strong> </p><p><strong>【1】缓存雪崩：</strong></p><p>​指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>​<strong>解决方案：</strong></p><p>​1）缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p><p>​2）一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</p><p>​3）给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</p><p><strong>【2】缓存穿透：</strong></p><p>​缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>​<strong>解决方案：</strong></p><p>​1）接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p><p>​2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击；</p><p>​3）采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><p><strong>【3】缓存击穿：</strong></p><p>​这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p><p>​<strong>解决方案：</strong></p><p>​1）设置热点数据永远不过期</p><p>​2）加互斥锁，互斥锁</p><p><strong>10、如何保证缓存和数据库的数据一致性？</strong> </p><p><strong>方式一：</strong></p><p>​读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><p><strong>方式二：</strong></p><p>​先更新数据库，假如读缓存失败，先读数据库，再回写缓存的方式实现</p><p><strong>11、redis是单线程还是多线程？为什么那么快？</strong> </p><p>redis是单线程，快的原因：</p><p>​1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</p><p>​2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p><p>​3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>​4）使用多路 I&#x2F;O 复用模型，非阻塞 IO；</p><p>​5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><p><strong>12、五种IO模型的区别</strong> </p><p><strong>阻塞I&#x2F;O：</strong></p><p>​当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p><p><strong>非阻塞I&#x2F;O：</strong></p><p>​在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p><p><strong>多路复用I&#x2F;O（select和poll）：</strong></p><p>​IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。其中，select只负责等，recvfrom只负责拷贝。 IO多路转接是属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率较阻塞IO的高。</p><p><strong>信号驱动I&#x2F;O（SIGIO）：</strong></p><p>​信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。</p><p><strong>异步I&#x2F;O（Posix.1的aio_系列函数）：</strong></p><p>​当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。</p><p><strong>可以看出，阻塞程度：阻塞IO&gt;非阻塞IO&gt;多路转接IO&gt;信号驱动IO&gt;异步IO，效率是由低到高的</strong>。</p><p><strong>13、select、poll、epoll的区别？</strong> </p><p>参考：<a href="https://www.jianshu.com/p/dfd940e7fca2">https://www.jianshu.com/p/dfd940e7fca2</a></p><p><strong>select</strong> 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p>**poll **本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p>**epoll **支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>14、redis热key问题？如何发现以及如何解决？</strong> </p><p>​缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><strong>解决方案：</strong></p><p>​对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p><p><strong>15、redis数据分布方式？有什么优点？一致性hash呢？</strong> </p><p><strong>Hash：</strong></p><p>​客户端分片：哈希+取余</p><p>​节点伸缩：数据节点关系变化，导致数据迁移</p><p>​迁移数量和添加节点数量有关：建议翻倍扩容</p><p>​一个简单直观的想法是直接用Hash来计算，以Key做哈希后对节点数取模。可以看出，在key足够分散的情况下，均匀性可以获得，但一旦有节点加入或退出，所有的原有节点都会受到影响，稳定性无从谈起。</p><p><strong>一致性Hash：</strong></p><p>​客户端分片：哈希+顺时针（优化取余）</p><p>​节点伸缩：只影响邻近节点，但是还是有数据迁移</p><p>​翻倍伸缩：保证最小迁移数据和负载均衡</p><p>​一致性Hash可以很好的解决稳定问题，可以将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到先遇到的一组存储节点存放。而当有节点加入或退出时，仅影响该节点在Hash环上顺时针相邻的后续节点，将数据从该节点接收或者给予。但这有带来均匀性的问题，即使可以将存储节点等距排列，也会在<strong>存储节点个数变化时带来数据的不均匀</strong>。而这种可能成倍数的不均匀在实际工程中是不可接受的。</p><p><strong>16、redis主从复制</strong> </p><p><strong>主从复制原理：</strong></p><p>当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，</p><p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，</p><p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p><p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><p><strong>过程原理</strong></p><p>​1、当从库和主库建立MS关系后，会向主数据库发送SYNC命令</p><p>​2、主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</p><p>​3、当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</p><p>​4、从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</p><p>​5、之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</p><p><strong>缺点</strong></p><p>​所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</p><h2 id="七、Spring-篇"><a href="#七、Spring-篇" class="headerlink" title="七、Spring 篇"></a><strong>七、Spring 篇</strong></h2><p><strong>1、Spring IOC</strong> </p><p>​IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制<br>权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 </p><p>​IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可，完全不⽤考虑对象是如何被创建出来的。</p><p><strong>2、Spring AOP，动态代理</strong></p><p>​AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤<br>的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模<br>块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>​Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK<br>Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候<br>Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，</p><p><strong>3、Bean生命周期</strong> </p><p><strong>单例对象：</strong> singleton           </p><p>出生：当容器创建时对象出生           </p><p>活着：只要容器还在，对象一直或者            </p><p>死亡：容器销毁，对象消亡            </p><p>总结：单例对象的生命周期和容器相同        </p><p><strong>多例对象：</strong> prototype           </p><p>出生: 使用对象时spring框架为我们创建            </p><p>活着：对象只要是在使用过程中就一直活着            </p><p>死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收</p><p><strong>4、Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?</strong> </p><table><thead><tr><th>名称</th><th></th></tr></thead><tbody><tr><td>singleton</td><td>单例对象，默认值的作用域</td></tr><tr><td>prototype</td><td>每次获取都会创建⼀个新的 bean 实例</td></tr><tr><td>request</td><td>每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</td></tr><tr><td>session</td><td>在一次 HTTP session 中，容器将返回同一个实例</td></tr><tr><td>global-session</td><td>将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session</td></tr></tbody></table><p>默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题</p><p><strong>保障线程安全方法：</strong></p><ol><li><p>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</p></li><li><p>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中</p></li></ol><p>  <strong>ThreadLocal</strong>：</p><p>  ​每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</p><p>  ​将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后<strong>在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象</strong>，避免了将这个对象作为参数传递的麻烦。</p><p><strong>5、Spring事务隔离级别和事务传播属性</strong> </p><p><strong>隔离级别：</strong></p><p><strong>1) DEFAULT （默认）</strong><br>        这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。</p><p><strong>2) READ_UNCOMMITTED （读未提交）</strong><br>        这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 </p><p><strong>3) READ_COMMITTED （读已提交）</strong><br>        保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。 </p><p><strong>4) REPEATABLE_READ （可重复读）</strong><br>        这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。</p><p><strong>5) SERIALIZABLE（串行化）</strong><br>        这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。 </p><p><strong>Spring事务传播属性（Propagation）：</strong></p><p><strong>1) REQUIRED（默认属性）</strong><br>        如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 被设置成这个级别时，会为每一个被调用的方法创建一个逻辑事务域。如果前面的方法已经创建了事务，那么后面的方法支持当前的事务，如果当前没有事务会重新建立事务。 </p><p><strong>2) MANDATORY</strong><br>        支持当前事务，如果当前没有事务，就抛出异常。 </p><p><strong>3) NEVER</strong><br>        以非事务方式执行，如果当前存在事务，则抛出异常。 </p><p><strong>4) NOT_SUPPORTED</strong><br>        以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p><p><strong>5) REQUIRES_NEW</strong><br>        新建事务，如果当前存在事务，把当前事务挂起。 </p><p><strong>6) SUPPORTS</strong><br>        支持当前事务，如果当前没有事务，就以非事务方式执行。 </p><p><strong>7) NESTED</strong><br>        支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p><p><strong>6、Spring以及Spring MVC常见注解</strong> </p><p><em><strong>Spring部分：</strong></em></p><p>​<strong>声明bean的注解</strong></p><p>​<strong>@Component</strong> 通⽤的注解，可标注任意类为  Spring 组件</p><p>​<strong>@Service</strong> 在业务逻辑层使用（service层）</p><p>​<strong>@Repository</strong> 在数据访问层使用（dao层）</p><p>​<strong>@Controller</strong> 在展现层使用，控制器的声明（controller层）</p><p>​<strong>注入bean的注解</strong></p><p>​<strong>@Autowired</strong>：可以对类成员变量、方法、构造方法进行标注</p><p>​默认按照类型注入，若要按照名称注入，需要搭配**@Qualifier**注解一起使用</p><p>​<strong>@Resource</strong>：默认按照名称来装配注入</p><p><strong>Spring MVC部分：</strong></p><p>​<strong>@Controller</strong> 声明该类为SpringMVC中的Controller</p><p>​<strong>@RequestMapping</strong> 用于映射Web请求</p><p>​<strong>@ResponseBody</strong> 支持将返回值放在response内，而不是一个页面，通常用户返回json数据</p><p>​<strong>@RequestBody</strong> 允许request的参数在request体中，而不是在直接连接在地址后面。</p><p>​<strong>@PathVariable</strong> 用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p><strong>7、@autowired和@resource的区别？</strong> </p><p><strong>@Autowired</strong>：可以对类成员变量、方法、构造方法进行标注</p><p>​默认按照类型注入，若要按照名称注入，需要搭配**@Qualifier**注解一起使用</p><p><strong>@Resource</strong>：默认按照名称来装配注入</p><p><strong>8、mybatis如何防止sql注入？$和#的区别是什么？传入表名用哪个？</strong> </p><p><strong>防止sql注入：</strong></p><p>​在编写mybatis的映射语句时，尽量采用“#{xxx}”这样的格式</p><p><strong>#和$区别：</strong> </p><table><thead><tr><th>#</th><th>$</th></tr></thead><tbody><tr><td>相当于对数据加上双引号</td><td>相当于直接显示数据</td></tr><tr><td>很大程度上防止SQL注入</td><td>无法防止SQL注入</td></tr><tr><td>#{xxx},使用的是PreparedStatement,会有类型转换，比较安全</td><td>${xxx}，使用字符串拼接，容易SQL注入</td></tr></tbody></table><p>​简单的说就是#{}是经过预编译的，是安全的，**$**{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。</p><p>要实现动态传入表名、列名，需要做如下修改：</p><p><strong>添加属性statementType&#x3D;”STATEMENT”<strong>，</strong>同时sql里的属有变量取值都改成${xxxx}</strong></p><p><strong>9、Spring MVC工作原理</strong> </p><p><img src="https://img-blog.csdn.net/20181022224058617?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F3YWtlX2xxaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><ol><li>客户端（浏览器）发送请求，直接请求到  DispatcherServlet 。</li><li>DispatcherServlet 根据请求信息调⽤  HandlerMapping ，解析请求对应的  Handler 。</li><li>解析到对应的  Handler （也就是  Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li><li>HandlerAdapter 会根据  Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回⼀个  ModelAndView 对象， Model 是返回的数据对象</li><li>ViewResolver 会根据逻辑  View 查找实际的  View 。</li><li>DispaterServlet 把返回的  Model 传给  View （视图渲染）。</li><li>把  View 返回给请求者（浏览器）</li></ol><p><strong>10、SpringBoot自动配置的原理是什么？介绍SpringBootApplication注解.</strong> </p><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(JpaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p><p> <strong>@EnableAutoConfiguration作用：</strong></p><p>它主要利用了一个</p><p>EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration <br></code></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>注解等同于下面三个注解：</p><ul><li><strong>@SpringBootConfiguration：</strong> 底层是<strong>Configuration</strong>注解，说白了就是支持<strong>JavaConfig</strong>的方式来进行配置</li><li><strong>@EnableAutoConfiguration：</strong>开启<strong>自动配置</strong>功能</li><li><strong>@ComponentScan：</strong>就是<strong>扫描</strong>注解，默认是扫描<strong>当前类下</strong>的package</li></ul><p>其中<code>@EnableAutoConfiguration</code>是关键(启用自动配置)，内部实际上就去加载<code>META-INF/spring.factories</code>文件的信息，然后筛选出以<code>EnableAutoConfiguration</code>为key的数据，加载到IOC容器中，实现自动配置功能！</p><p><strong>11、Mybatis和Hibernate的区别</strong> </p><p><strong>Hibernate 框架：</strong> </p><p>​    <strong>Hibernate</strong>是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p><p><strong>Mybatis框架：</strong></p><p>​    <strong>Mybatis</strong>是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p><p><strong>区别：</strong></p><p>  <strong>开发方面</strong></p><p>​    在项目开发过程当中，就速度而言：</p><p>​      hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</p><p>​      Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</p><p>​    但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。</p><p>  <strong>sql优化方面</strong></p><p>​    Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</p><p>​    Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</p><p>  <strong>对象管理比对</strong></p><p>​    Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</p><p>​    Mybatis 需要自行管理 映射关系；</p><p><strong>12、spring中的@Autowired注解原理？</strong> </p><p>​ @Autowired的使用简化了我们的开发，其原理是使用 AutowiredAnnotationBeanPostProcessor 类来实现，该类实现了 Spring 框架的一些扩展接口，通过实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）；通过实现 MergedBeanDefinitionPostProcessor 扩展接口，在 BeanFactory 里面的每个 Bean 实例化前获取到每个 Bean 里面的 @Autowired 信息并缓存下来；通过实现 Spring 框架的 postProcessPropertyValues 扩展接口在 BeanFactory 里面的每个 Bean 实例后从缓存取出对应的注解信息，获取依赖对象，并通过反射设置到 Bean 属性里面。</p><p><strong>13、Spring中用到了哪些设计模式？单例、工厂、代理、适配、观察者之类的说一说就行</strong> </p><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd">spring中的设计模式</a></p><p><strong>单例设计模式 :</strong> Spring 中的 Bean 默认都是单例的。</p><p><strong>⼯⼚设计模式 :</strong> Spring使⽤⼯⼚模式通过  BeanFactory 、 ApplicationContext 创建bean 对象。</p><p><strong>代理设计模式 :</strong> Spring AOP 功能的实现。</p><p><strong>观察者模式：</strong> Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</p><p><strong>适配器模式：</strong>Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</p><h2 id="八、客观题"><a href="#八、客观题" class="headerlink" title="八、客观题"></a>八、<strong>客观题</strong></h2><p><strong>1、100亿黑名单URL，每个64B，问这个黑名单要怎么存？判断一个URL是否在黑名单中</strong> </p><p>​<strong>散列表：</strong></p><p>​如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。</p><p>​<strong>布隆过滤器：</strong></p><p>​它实际上是一个很长的二进制矢量和一系列随机映射函数。</p><p>​它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>​在数组中的每一位都是二进制位。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ul><p><strong>2、2GB内存在20亿整数中找到出现次数最多的数</strong> </p><p>​通常做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某个整数，value记录整数出现的次数。本题的数据量是20亿，有可能一个数出现20亿次，则为了避免溢出，哈希表的key是32位（4B）,value也是 32位（4B），那么一条哈希表的记录就需要占用8B。</p><p>​当哈希表记录数为2亿个时，需要16亿个字节数（8*2亿），需要至少1.6GB内存(16亿&#x2F;2^30,1GB&#x3D;&#x3D; 2 ^30个字节 &#x3D;&#x3D; 10亿)。则20亿个记录，至少需要16GB的内存，不符合题目要求。</p><p>​解决办法是将20亿个数的大文件利用哈希函数分成16个小文件，根据哈希函数可以把20亿条数据均匀分布到16个文件上，同一种数不可能被哈希函数分到不同的小文件上，假设哈希函数够好。然后对每一个小文件用哈希函数来统计其中每种数出现的次数，这样我们就得到16个文件中出现次数最多的数，接着从16个数中选出次数最大的那个key即可。</p><p><strong>3、40亿个非负整数中找到没有出现的数</strong> </p><p>​对于原问题，如果使用哈希表来保存出现过的数，那么最坏情况下是40亿个数都不相同，那么哈希表则需要保存40亿条数据，一个32位整数需要4B，那么40亿*4B &#x3D; 160亿个字节，一般大概10亿个字节的数据需要1G的空间，那么大概需要16G的空间，这不符合要求。</p><p>　　我们换一种方式，申请一个bit数组，数组大小为4294967295，大概为40亿bit，40亿&#x2F;8 &#x3D; 5亿字节，那么需要0.5G空间， bit数组的每个位置有两种状态0和1，那么怎么使用这个bit数组呢？呵呵，数组的长度刚好满足我们整数的个数范围，那么数组的每个下标值对应4294967295中的一个数，逐个遍历40亿个无符号数，例如，遇到20，则bitArray[20] &#x3D; 1；遇到666，则bitArray[666] &#x3D; 1,遍历完所有的数，将数组相应位置变为1。</p><p><strong>4、40亿个非负整数中找到一个没有出现的数，内存限制10MB</strong> </p><p>​本题将内存空间缩小为10MB，对于40亿个数据来说那是明显不够用的，那么我们只有将数据分块处理，分块应该怎么分，分多少块合理呢？根据我做过的题经验来看，10亿个字节的数据大概需要1GB空间处理(如果这个结论不正确欢迎读者指出)，那么10MB内存换算过来就是可以处理1千万字节的数据，也就是8千万bit，对于40亿非负整数如果申请bit数组的话，40亿bit &#x2F; 0.8亿bit &#x3D; 50，那么这样最少也得分50块来处理，处理每块数据的时候几乎用完了内存空间，这样也不太好。看书上解说是分成了64块，至于为什么是64我目前也不是很了解，我只知道最少50块。所以下面就以64块来进行分析解答吧。</p><p>　　首先，将0 - 4294967259这个范围平均分成64个区间，每个区间是67108864个数，为了定位更加准确一些，我们先开辟一个大小为64的整型数组intArray，将40亿个数进行区间划分，第0区间（0-67108863）、第一区间（67108864-134217728）、第i区间（67108864<em>i-67108864</em>(i+1)-1）,……，第63区间（4227858432 - 4294967259）。intArray分别记录每个区间出现的数的个数，肯定至少有一个区间上的计数少于67108864.利用这一点可以快速找出一个没有出现过的数。</p><p>​第一次遍历时，先申请长度为64的整型数组countArr[0..63]，countArr[i]用来统计区间i 上的数有多少。遍历40亿个数，根据当前数是多少来决定哪一个区间上的计数增加。例如，如果当前数是3422552090，3422552090&#x2F;67108864&#x3D;51，所以第51区间上的计数增加countArr[51]++。遍历完40亿个数之后，遍历countArr，必然会有某一个位置上的值(countArr[i])小于67108864，表示第i 区间上至少有一个数没出现过。我们肯定会至少找到一个这样的区间。此时使用的内存就是countArr的大小（64×4B），是非常小的。</p><p>假设我们找到第37区间上的计数小于67108864，以下为第二次遍历的过程：</p><p>1．申请长度为67108864的bit map，这占用大约8MB的空间，记为bitArr[0..67108863]；</p><p>2．再遍历一次40亿个数，此时的遍历只关注落在第37区间上的数，记为num（num&#x2F;67108864&#x3D;&#x3D;37），其他区间的数全部忽略。</p><p>3．如果步骤2的num在第37区间上，将bitArr[num - 67108864*37]的值设置为1，也就是只做第37区间上的数的bitArr映射。</p><p>4．遍历完40亿个数之后，在bitArr上必然存在没被设置成1的位置，假设第i 个位置上的值没设置成1，那么67108864×37+i 这个数就是一个没出现过的数。</p><p><strong>总结一下进阶的解法：</strong></p><p>1．根据10MB的内存限制，确定统计区间的大小，就是第二次遍历时的bitArr大小。</p><p>2．利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。</p><p>3．对这个区间上的数做bit map映射，再遍历bit map，找到一个没出现的数即可。</p><p><strong>5、找到100亿个URL中重复的URL</strong></p><p>​原问题的解法使用解决大数据问题的一种常规方法：把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件。一直进行这种划分，直到划分的结果满足资源限制的要求。首先，你要向面试官询问在资源上的限制有哪些，包括内存、计算时间等要求。在明确了限制要求之后，可以将每条URL通过哈希函数分配到若干机器或者拆分成若干小文件，这里的“若干”由具体的资源限制来计算出精确的数量。 </p><p>​例如，将100亿字节的大文件通过哈希函数分配到100台机器上，然后每一台机器分别统计分给自己的URL中是否有重复的URL，<strong>同时哈希函数的性质决定了同一条URL不可能分给不同的机器；</strong>或者在单机上将大文件通过哈希函数拆成1000个小文件，对每一个小文件再利用哈希表遍历，找出重复的URL；或者在分给机器或拆完文件之后，进行排序，排序过后再看是否有重复的URL出现。总之，牢记一点，很多大数据问题都离不开分流，要么是哈希函数把大文件的内容分配给不同的机器，要么是哈希函数把大文件拆成小文件，然后处理每一个小数量的集合。</p><p><strong>6、海量搜索词汇，找到最热TOP100词汇的方法</strong> </p><p>​最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上，具体多少台机器由面试官规定或者由更多的限制来决定。对每一台机器来说，如果分到的数据量依然很大，比如，内存不够或其他问题，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。</p><p>​处理每一个小文件的时候，哈希表统计每种词及其词频，哈希表记录建立完成后，再遍历哈希表，遍历哈希表的过程中使用大小为100的小根堆来选出每一个小文件的top 100（整体未排序的top 100）。每一个小文件都有自己词频的小根堆（整体未排序的top 100），将小根堆里的词按照词频排序，就得到了每个小文件的排序后top 100。然后把各个小文件排序后的top 100进行外排序或者继续利用小根堆，就可以选出每台机器上的top 100。不同机器之间的top100再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top 100。对于top K 的问题，除哈希函数分流和用哈希表做词频统计之外，还经常用堆结构和外排序的手段进行处理。</p><p><strong>7、40亿个无符号整数，1GB内存，找到所有出现两次的数</strong> </p><p>​对于原问题，可以用bit map的方式来表示数出现的情况。具体地说，是申请一个长度为4294967295×2的bit类型的数组bitArr，用2个位置表示一个数出现的词频，1B占用8个bit，所以长度为4294967295×2的bit类型的数组占用1GB空间。怎么使用这个bitArr数组呢？遍历这40亿个无符号数，如果初次遇到num，就把bitArr[num<em>2 + 1]和bitArr[num</em>2]设置为01，如果第二次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为10，如果第三次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为11。以后再遇到num，发现此时bitArr[num<em>2+1]和bitArr[num</em>2]已经被设置为11，就不再做任何设置。遍历完成后，再依次遍历bitArr，如果发现bitArr[i<em>2+1]和bitArr[i</em>2]设置为10，那么i 就是出现了两次的数。</p><p><strong>8、10MB内存，找到40亿整数的中位数</strong> </p><p>①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以…然后找到中间那个就可以了。但是你以为面试官会给你内存？？ </p><p>②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。 </p><p>  假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。 </p><p>  从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中） </p><p>  现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。 </p><p>  现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。 </p><p>  抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。 </p><p>  按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p><p><strong>9、设计短域名系统，将长URL转化成短的URL.</strong></p><p>（1）利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc。</p><p>（2）将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：<a href="http://t.cn/sBc%E3%80%82">t.cn&#x2F;sBc。</a></p><p>（3）重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -&gt; URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache。</p><p><strong>10、让你系统的设计一个高并发的架构，你会从哪几个方面考虑？</strong> </p><p><strong>系统拆分</strong></p><p>​将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库， 这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><p><strong>缓存</strong></p><p>​缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数 据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻 轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的 读场景，怎么用缓存来抗高并<strong>发。</strong></p><p><strong>MQ</strong></p><p>​MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作 里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统， 你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数 据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你 咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费 后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些 承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机 抗几万并发也是 ok 的，这个之前还特意说过。</p><p><strong>分库分表</strong></p><p>​分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就 将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个 表，每个表的数据量保持少一点，提高 sql 跑的性能。</p><p><strong>读写分离</strong></p><p>​读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都 集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。 读流量太多的时候，还可以加更多的从库。</p><p><strong>ElasticSearch</strong></p><p>​Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支 撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的 查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也 可以考虑用 es 来承载。</p><p><strong>11、假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写</strong> </p><p>可以进行读写分离、加载到缓存</p><p><strong>12、显示网站的用户在线数的解决思路</strong> </p><ol><li><p>维护在线用户表</p></li><li><p>使用Redis统计</p></li></ol><h2 id="九、个人项目"><a href="#九、个人项目" class="headerlink" title="九、个人项目"></a><strong>九、个人项目</strong></h2><h4 id="一、秒杀项目："><a href="#一、秒杀项目：" class="headerlink" title="一、秒杀项目："></a>一、秒杀项目：</h4><p><strong>项目架构介绍：</strong></p><p>​系统主要通过缓存，异步，限流来保证系统的高并发和高可用。</p><p><a href="https://blog.csdn.net/awake_lqh/article/details/83306983">https://blog.csdn.net/awake_lqh/article/details/83306983</a></p><p><strong>1、如何解决超卖？</strong></p><p>mysql乐观锁+redis预减库存+redis缓存卖完标记 </p><p><strong>2、如何解决重复下单？</strong></p><p>mysql唯一索引+分布式锁 </p><p><strong>3、如何防刷？</strong></p><p>IP限流+验证码 </p><p><strong>4、热key问题如何解决？</strong></p><p>redis集群+本地缓存+限流+key加随机值分布在多个实例中 </p><p><strong>5、消息队列的作用？如何保证消息的不丢失？</strong></p><p>异步削峰；发送方开启confirm+消息队列持久化+消费方关闭自动ACK,确保消费成功之后自动调用API进行确认。 </p><p><strong>6、缓存和数据库数据一致性如何保证？</strong></p><p>秒杀项目不用保证，其他项目就用延时双删或者先更新数据再是缓存失效，为防缓存失效这一信息丢失，可用消息队列确保。 </p><p>7、压测没有？用什么压测？什么情况？ </p><p>8、系统瓶颈在哪？如何查找，如何再优化？</p><p>1.秒杀流程<br>2.库存预减用的是哪个redis方法<br>3.如果项目中的redis服务挂掉，如何减轻数据库的压力<br>4.如何避免消息队列的消费方重复消费消息<br>5.消息的消费结果如何返回给消息发送方<br>6.说一下你的秒杀系统设计，怎么解决超卖的<br>7.你说你用到了redis，redis有哪些数据结构，你为什么要用redis，哪里用到了，为什么说redis快，多路io复用详细原理可以说说嘛？<br>8.redis，深入讲一讲，并说一下它的应用场景<br>9.秒杀系统怎么做的，架构图画了一下<br>10.秒杀模块怎么设计的，如何压测，抗压手段，如何保证数据库与redis缓存一致的,消息队列怎么用的<br>11.秒杀系统服务器抗压思路，从哪些方面去优化<br>12.如何解决超卖<br>13.讲讲你做的秒杀项目<br>14.你的秒杀项目，别说你里面的优化，你还有什么优化策略吗？多服务器负载均衡，把秒杀商品平均分给服务器。<br>15.秒杀项目部分实现怎么做的<br>16.秒杀系统的前端设计怎么做？<br>17.说说秒杀如何实现的？（用redis预库存的减少，然后方式异步消息队列rabbitMQ中）<br>18.如何解决商城中超卖问题？秒杀场景呢？<br>19.秒杀过程中怎么保证redis缓存和数据库的一致性<br>20.具体的秒杀细节怎么做的？秒杀的核心技术在哪儿？你怎么保证的？<br>21.秒杀商品的库存放在哪里，如何保证redis和DB的一致性<br>22.设计秒杀方案（从高并发、快速响应、高可用三方面回答，高并发（增加网络带宽、DNS域名解析分发多台服务器、使用前置代理服务器ngnix、CDN内容分发、数据库查询优化（读写分离、分库分表）），快速响应（缓存服务器（memcached、redis）、能使用静态页面就用静态页面，减少容器解析、把常访问的图片等内容缓存）、高可用（热备，如数据库服务器的热备、集群监控（如使用zabbix，重点关注IO、内存、带宽和机器load）））<br>23.秒杀时如果机器资源有限怎么办<br>24.秒杀接口防刷怎么做<br>25.如何防止超卖和少卖<br>26.秒杀系统场景下怎么防止超卖，redis和数据库数据不一致怎么办，以什么为准<br>27.秒杀流程图 如何保证不超卖 以及对应SQL</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Collection</title>
    <link href="/2022/11/08/Collection/"/>
    <url>/2022/11/08/Collection/</url>
    
    <content type="html"><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Collection接口声明了下列实例方法, 在所有的集合实现类中都可以使用</p><blockquote><p>注意集合中的元素都是对象</p></blockquote><table><thead><tr><th>方法</th><th>作用</th><th>形参</th></tr></thead><tbody><tr><td>add</td><td>添加一个对象进集合中</td><td>Object o</td></tr><tr><td>addALL</td><td>把集合c中的元素添加到另一个集合中</td><td>Collection c</td></tr><tr><td>clear</td><td>删除集合的所有元素</td><td>无</td></tr><tr><td>size</td><td>返回集合元素个数</td><td></td></tr><tr><td>contains</td><td>检查集合是否包含指定对象</td><td></td></tr><tr><td>containsAll</td><td>检查是否包含另一个集合的所有元素</td><td></td></tr><tr><td>isEmpty</td><td>检查集合是否为空</td><td></td></tr><tr><td>iterator</td><td>返回一个迭代器, 用于遍历集合</td><td></td></tr><tr><td>remove</td><td>删除指定元素</td><td></td></tr><tr><td>removeAll</td><td>将集合c中的元素从原集合删除</td><td></td></tr><tr><td>retainAll</td><td>将集合c中的元素在原集合中保留</td><td></td></tr><tr><td>toArray</td><td>将集合转换为数组</td><td></td></tr></tbody></table><p>集合类还有一个抽象方法forEach, 可以通过实现该方法来实现集合的变量</p><h1 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h1><p>iterator接口有四个实例方法</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>hasNext</td><td>判断迭代器是否还能指向下一个元素</td></tr><tr><td>next</td><td>将迭代器向后移动一位, 并返回移动后指向的元素</td></tr><tr><td>remove</td><td>删除迭代器当前指向的元素</td></tr></tbody></table><p>还有一个不常用的方法forEachRemaining, 用于遍历集合</p><blockquote><p>注意迭代器没有提供方法来修改元素, 只能删除元素或者读取元素值</p></blockquote><p><strong>迭代器在迭代过程中, 集合不能发生任何修改. 否则将抛出异常</strong></p><blockquote><p>意味着remove方法不能用于hasNext和next组成的遍历语句中</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bug学习</title>
    <link href="/2022/11/08/Bug%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/08/Bug%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Bug学习"><a href="#Bug学习" class="headerlink" title="Bug学习"></a>Bug学习</h1><h2 id="多表联查时报空指针错误。"><a href="#多表联查时报空指针错误。" class="headerlink" title="多表联查时报空指针错误。"></a>多表联查时报空指针错误。</h2><p>真实原因：service层涉及BigDecimal的计算时，部分数据为null。<br>排查过程：首先查看sql语句与vo的对应情况<br>未发现不对应的字段。上升至mapper查看多参<br>是否有加@Param注解。已加。再上升至service<br>层，debug断点排查出计算时测试数据不完整为null。<br>解决方案：1、计算之前所有涉及计算的数据均增加非空判断，若为空则赋予初始值。<br>2、方案2，在数据库字段中设置默认值，因部分字段涉及库存及其他计算，故舍弃此方案。<br>3、方案3，在entity中通过@value设置默认值。因可能影响其他方法中的数据使用故舍弃。</p><pre><code class="hljs">1.springboot-web默认使用jackson，而jackson不支持yyyy-MM-dd HH:mm:ss格式的转换。而Fastjson（阿里的）支持。</code></pre><p>解决方法：<br>1.重写jackson反序列化，自定义类继承JsonDeserializer并重写deserializer方法；并在属性上加注@JsonDeserialize(using &#x3D; 自定义类.class)<br>2.使用jackson注解，不需要重写反序列化。@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING, pattern &#x3D; “yyyy-MM-dd HH:mm:ss”, timezone &#x3D; “GMT+8”)<br>3.添加fastjson依赖，使用fastjson注解。@JSONField(format &#x3D; “yyyy-MM-dd HH:mm:ss”)<br>以上都是单个的，不好用<br>4.可以排除jackson依赖，添加fastjson依赖。主启动类设置排除jackson自动配置等。但是太麻烦。简单的是，添加jastjson依赖，并返回一个使用了fastjson的HttpMessageConverters（Bean）<br>以上只能负责反序列化<br>序列化需要：fastJsonConfig.setDateFormat(“yyyy-MM-dd”);</p><p>问题：’build.plugins.plugin.version’ for org.springframework.bootspring-boot-maven-plugin is missing. @ com.woniu:cms sys:1.0-SNAPSHOT,</p><p>原因：core微服务的pom文件里，&lt;parent&gt;标签应该写cms_client的，但是写成了cms_sys的了</p><p>一：单独的微服务swagger没有问题，但是网关的swagger访问报错<br>异常原因：网关的yml配置文件配置的路由中，放置服务的顺序不对，第一个定义的微服务没有启动，所以根本进不去swagger<br>解决方法：把启动的微服务配置放在最前面，网关的swagger就可以访问了<br>二：springboot启动异常（The alias ‘*‘ is already mapped to the value ‘com.*）<br>出现异常原因<br>①：是因为配置文件中typeAliasesPackage中配置的包名有问题，在同一个包下有相同的类名<br>三：Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed<br>异常原因：@MapperScan(“com.wn.soft.core”)注解的包路径扫描范围太大了，将包路径下的所有接口再编译后都生成实现类，导致启动springboot项目后所有使用了@Autowired注解的类都出现找到两个bean的问题，一个是接口的bean，一个是该接口实现类的bean<br>解决方法：@MapperScan注解的包路径扫描范围缩小，细粒度扫描到指定的包，修改为@MapperScan(“com.wn.soft.core.mapper”)<br>    一：重启微服务经常报nacos连接超时错误<br>异常原因：服务器内存不足，nacos进程经常被杀死<br>解决方法：修改nacos配置文件，把占用内存改小一点；或者先用本地的nacos<br>二：测试springboot项目出现Test Ignored.<br>异常原因：测试文件路径与项目文件路径不一致。<br>解决方法：在微服务中，测试类要放在starter启动模块下，而不是core代码模块中，并且路径要和项目文件路径一致<br>三：No qualifying bean of type ‘com.wn.common.api.utils.BusinessNoUtil’ available: expected at least 1 bean which qualifies as autowire candidate.<br>异常原因：工具类放在公共模块并使用@Common注入到SpringIOC容器中，在core模块导入公共模块，编写代码时使用工具类会报在IOC容器中找不到<br>解决方法：在启动类的注解上添加扫描公共模块<br>四、测试查询所有方法接口时报No serializer found for class and no properties discovered to create BeanSerializer<br>异常原因：这种问题一般都是在对象转换json字符串的时候会遇到，多数是这两种原因：（1）利用jackson类对数据对象进行转jackson。（2）controller层 通过@Response进行注解的类返回。根本原因是：转换无法找到对应的字段。<br>我的原因：测试查询所有方法时有把实体对象转换成VO对象，转换不对<br>解决方法：（1）可以直接对字段 private修改成public。（2）在类上面加上@Data注解。（3）加上public 的get set 方法。<br>我的解决方法：在VO对象上加上@Data注解<br>    在财务类中导入config jar包会使getway内置的web与spring-boot-starter-web依赖冲突报错，改为web flux依旧报错。解决方法：1.  通过exclusions剔除spring-boot-starter-web。2.不导入config，在启动类模块中添加需要的配置类 java.sql.SQLIntegrityConstraintViolationException:  违反唯一约束条件报错。在循环插入数据时主键重复。解决方式，将new对象操作放入循环里，报错解决。（也许是mp发现传入对象是同一个对象的原因）使用openfeign调用文档上传接口时报415错误，服务提供者报FileUploadException: the request was rejected because no multipart boundary was found；是因为使用了RequestParam的原因。<br>@RequestPart主要用来处理content-type为multipart&#x2F;form-data或multipart&#x2F;mixed stream发起的请求，可以获取请求中的参数，包括普通文本、文件或复杂对象比如JSON、XML等，针对复杂对象，需要明确对应的content-type。<br>@RequestParam默认主要来处理query parameters, form data,and parts in multipart requests, 且是 key-value键值对这种文本,要区分</p><pre><code class="hljs">一、项目启动的时候出现了org.springframework.context.ApplicationContextException:Failed to start bean &#39;webServerstartStop&#39;;nested exception is java.lang.reflect.UndeclaredThrowableException的错误，我的解决方法是先去pom文件导依赖，然后从本地的nacos改为组里的nacos。                                                        二、上述问题解决好了之后又出现了com.mysql.cj.exceptions.ConnectionIsClosedException:No operations allowed after connection closed.这个问题，这个问题的出现应该是网络波动的问题，暂时重新测试了几次还是没有解决。</code></pre><p>org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘getCurrentUser’ defined in class path resource [com&#x2F;wn&#x2F;device&#x2F;core&#x2F;jwt&#x2F;GetUser.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.wn.iip.sysuser.core.entity.MemberUser]: Factory method ‘getCurrentUser’ threw exception; nested exception is java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.<br>类GetUser放进容器中，创建bean报错，因为方法中需要请求request，但是初始化时并没有请求过来，所以初始化容器报错,加上@Lazy注解解决问题2022-09-20 15:48:57.977 ERROR 9280 — [ctor-http-nio-4] a.w.r.e.AbstractErrorWebExceptionHandler : [4aa86855-38]  500 Server Error for HTTP POST “&#x2F;device-service&#x2F;gateway&#x2F;auth&#x2F;add”</p><p>io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection timed out: no further information: &#x2F;26.26.26.1:9001<br>    Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:<br>Error has been observed at the following site(s):<br>    |_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]<br>    |_ checkpoint ⇢ HTTP POST “&#x2F;device-service&#x2F;gateway&#x2F;auth&#x2F;add” [ExceptionHandlingWebHandler]<br>Stack trace:<br>Caused by: java.net.ConnectException: Connection timed out: no further information<br>链接失败，每次调用远程接口时就会出现</p><p>华为云使用vsftpd+nginx搭建图片服务器遇到问题，BUG详情：ftp无法连接，远程主机关闭连接。。。解决思路：1、查看服务器安全组是否开放20-21端口，2、查看服务器是否开启防火墙，3、查看linux的安全级别是否允许ftp被外部访问，4、用户名和密码是否匹配，5、vdftpd.conf配置是否正确（此配置错一处都会出现大问题。所有配置都对也还是会有可能出现无法登录的问题）                                                                            上传图片后nginx无法正常访问图片，错误信息403：原因，未给nginx设置用户组权限遇到问题：java:程序包xxx不存在，依赖解析错误     BUG详情可以通过ctrl+点击进入到依赖所在位置，但是你无法下载过来使用，执行了maven clean ，maven install，maven依赖没有标红，但启动就报错。      解决方案：在原依赖所在父包使用clean清理项目再install下载每个包都进行这样的操作BUG详情：maven依赖冲突，微服务与公共模块使用lombok版本不一致，解决方案：使用相同版本               </p><p>BUG详情：swagger配置无法注入到spring容器，项目无法启动，依赖删了重新导，重新建立配置文件    BUG详情：网关knfe4j文档请求异常，yml配置类中服务名不匹配，微服务有新建接口未使用swagger的Api注解</p><p>端口中使用openfeign调用他人微服务时，openfeign之前查询自身的sql语句没问题，但是运行到调用相应其他微服务feign中的接口时报错。<br>错误：Method Not Allowed<br>解决方案：我先认为是别人端口处的方法未写“RequestParam”，加入过后测试并未改变，于是根据百度上说的我又将自己方法处的方法注解改为RequestMapping，问题得到解决。<br>总结：我的方法与openfeign的方法需要method保持一致，如果不一致他就无法识别应用，因此，例如，如果我们的修改方法需要调用它的查询方法，我们需要先查询，将数据存到前端暂时，再从前端取来数据传到修改中使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/11/08/Docker/"/>
    <url>/2022/11/08/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>docker是基于Go语言开发的虚拟容器引擎, 实现了对cgroup，namespeace，rootfs三个内核资源的虚拟化(隔离和控制)</p><blockquote><p>由于cgroup和namespage这两个内核特性是基于Linux的, 因此docker的虚拟化也是基于linux的</p></blockquote><p>虚拟机和容器的区别</p><table><thead><tr><th>虚拟机</th><th>容器</th></tr></thead><tbody><tr><td>安全性高, 与宿主机相互独立</td><td>安全性低, 会影响到宿主机</td></tr><tr><td>整个计算机虚拟化(包括内存 网络 硬盘 cpu)</td><td>namespace(用户空间)的虚拟化</td></tr><tr><td>开销高</td><td>开销低</td></tr><tr><td>包含模拟层和管理层</td><td>直接调用操作系统的接口</td></tr></tbody></table><blockquote><p>早期docker的底层是linux系统提供的LXC(内核容器虚拟化) ,现代的docker已经不需要使用lxc, 而是使用go从底层重新实现</p></blockquote><p>docker是一个高级容器引擎, 将容器的复杂操作进行封装, 使容器的创建和管理简单化</p><p>docker优点: 简单, 高性能, 组装化, 实现了运行环境的移植性缩短了应用开发上线的周期时间(一次封装，到处运行)</p><p>docker推荐一个容器只运行一个</p><p>docker的镜像代表一个应用环境, 通过镜像可以创建容器并运行, 通过同一个镜像产生的容器的运行环境完全相同, 容器的特点是可读可写</p><p>docker常用命令:</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>v</td><td>显示docker的版本</td></tr><tr><td>container list -a</td><td>列出所有的容器</td></tr><tr><td>start 容器名</td><td>启动容器</td></tr><tr><td>stop 容器</td><td>停止容器运行</td></tr><tr><td>rm 容器名</td><td>删除容器</td></tr><tr><td>rmi 镜像名</td><td>删除镜像</td></tr><tr><td>exec -it 容器名 &#x2F;bin&#x2F;bash</td><td>进去容器中(进入bash)</td></tr><tr><td>run  镜像:版本</td><td>根据镜像启动一个容器</td></tr><tr><td>search 镜像名</td><td>搜索对应名称的镜像</td></tr><tr><td>pull 镜像:版本</td><td>远程拉取镜像</td></tr><tr><td>images</td><td>列出本地仓库中的所有镜像</td></tr><tr><td>build -f 指定的dockerfile路径 -t 自定义镜像:版本</td><td>根据dockerfile生成一个镜像</td></tr><tr><td>commit 容器id 镜像名称:版本号</td><td>根据容器生成镜像</td></tr><tr><td>save -o ab.tar 镜像名称:版本号</td><td>将镜像导出为压缩文件</td></tr><tr><td>load -i ab.tar</td><td>根据压缩文件导入镜像</td></tr></tbody></table><p>docker run参数:</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-i</td><td>保留交互界面</td></tr><tr><td>-d</td><td>启动守护进程</td></tr><tr><td>-t &#x2F;bin&#x2F;bash</td><td>在容器启动后进入命令行</td></tr><tr><td>-p host端口:容器端口</td><td>端口映射</td></tr><tr><td>-v 主机目录:容器目录</td><td>文件目录映射</td></tr><tr><td>–name 容器名称</td><td>设置容器名称</td></tr><tr><td>-e</td><td>设置环境</td></tr></tbody></table><p>docker镜像:</p><p>linux的文件系统有两部分: bootfs和rootfs</p><blockquote><p>bootfs: boot文件系统, 包含bootloader和kernel, 在系统启动时被加载</p><p>rootfs: root文件系统, 根文件目录, 包含系统启动后才运行的标准文件</p></blockquote><p>linux不同发行版本的bootfs基本相同, 但是rootfs(配套软件)的区别很大</p><p>docker镜像的底层是自定义的rootfs文件, 被称为base image, 同时镜像也依赖于host的bootfs</p><blockquote><p>tomcat容器的分层架构</p></blockquote><p><img src="/2022/11/08/Docker/image-20220722153250677.png" alt="image-20220722153250677"></p><p>使用一个镜像创建并启动容器时, docker会在镜像的文件系统顶层加载一个可读写文件系统, 这个文件系统就是容器 </p><blockquote><p>多个相同镜像的容器会共用同一个镜像作为底层文件系统,只有顶层的可读写文件系统是不同的</p></blockquote><p><strong>镜像的文件系统对于容器来说是只读的</strong></p><p><strong>dockerfile</strong>用于根据配置的参数创建自定义的镜像</p><p>dockerfile可以分为4部分: 基础镜像 维护者信息 镜像创建时的操作指令 容器启动时的操作指令 </p><p>dockerfile内容:</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>MAINTAINER 作者名</td><td>设置作者信息</td></tr><tr><td>ENV 键 值</td><td>设置环境变量</td></tr><tr><td>RUN command</td><td>构建镜像时运行指定的bash命令</td></tr><tr><td>ADD source_path dest_path</td><td>将指定路径的文件或目录拷贝到镜像中的路径, 会自动解压, 或者下载url</td></tr><tr><td>COPY source_path dest_path</td><td>跟add类似, 但没有自动解压功能</td></tr><tr><td>WORKDIR path_dir</td><td>指定dockerfile运行命令的工作目录</td></tr><tr><td>CMD command</td><td>设置容器运行时会自动执行的bash命令</td></tr></tbody></table><p><strong>docker-compose</strong></p><p>docker-compose用于根据配置的参数创建容器</p><blockquote><p>docker-compose.yaml</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.9&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">my-nginx-service:</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">my-website</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">my-nginx-image:latest</span><br>    <span class="hljs-attr">cpus:</span> <span class="hljs-number">1.5</span><br>    <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">2048m</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:80&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DML</title>
    <link href="/2022/11/08/DML/"/>
    <url>/2022/11/08/DML/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h1><table><thead><tr><th>关键字</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>table</td><td>表</td><td>存储数据的逻辑单元</td></tr><tr><td></td><td>数据字典</td><td>系统表, 存储数据库的信息</td></tr><tr><td>constraint</td><td>约束</td><td>进行数据校验, 确保符合限制</td></tr><tr><td>view</td><td>视图</td><td>表中数据的逻辑展示, 本身不存储数据</td></tr><tr><td>index</td><td>索引</td><td>提高数据库的查询性能</td></tr><tr><td>function</td><td>函数</td><td>对数据库中的数据进行计算, 具有一个返回值</td></tr><tr><td>procedure</td><td>存储过程</td><td>进行完整的业务处理, 没有返回值, 但是可以有传出参数</td></tr><tr><td>tigger</td><td>触发器</td><td>相当于事件监听器, 在数据库发生事件时触发执行逻辑处理</td></tr></tbody></table><blockquote><p>数据的列被称为字段, 行称为记录</p></blockquote><p>数据库对象都可以通过create语句+关键字来创建</p><p>drop语句和alter语句也是可以操作多种数据库对象</p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>mysql支持4种约束</p><table><thead><tr><th>约束名</th><th>作用</th></tr></thead><tbody><tr><td>not null</td><td>非空</td></tr><tr><td>unique</td><td>唯一</td></tr><tr><td>primary key</td><td>主键</td></tr><tr><td>foreign key</td><td>外键</td></tr></tbody></table><p>约束也分为单列约束和多列约束</p><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><p>DML:  数据库操作语言(Data Manipulation language)</p><blockquote><p>用于对表进行增删改 CUD create update delete </p></blockquote><blockquote><p>DQL用于查数据</p></blockquote><blockquote><p>插入数据</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#往test2中插入两行数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test2(id,age)<span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>#省略式写法插入数据<br>#不推荐使用<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test2 <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&quot;小白&quot;),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,&quot;小白2&quot;);<br></code></pre></td></tr></table></figure><blockquote><p>修改数据</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#将id<span class="hljs-operator">=</span><span class="hljs-number">3</span>的那行数据修改<br><span class="hljs-keyword">update</span> test2 <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">9</span>,name<span class="hljs-operator">=</span>&quot;小黑&quot; <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><blockquote><p>删除数据</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">#将id<span class="hljs-operator">=</span><span class="hljs-number">4</span>那行数据删除<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test2 <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">4</span>;<br>#将id为<span class="hljs-number">1</span>或<span class="hljs-number">2</span>的数据都删除<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test2 <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">or</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>#将id为<span class="hljs-number">1</span>或<span class="hljs-number">2</span>的数据都删除<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test2 <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>#将id不等于<span class="hljs-number">3</span>的行都删除<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test2 <span class="hljs-keyword">where</span> id<span class="hljs-operator">!=</span><span class="hljs-number">3</span>;<br>#将id不等于<span class="hljs-number">3</span>的行都删除<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> id<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br>#将test2表的所有数据删除<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> test2;<br>#将整个表重置为初始化状态<br><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> test2;<br>#从test3中导出数据并去重后创建新表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test4 <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test3);<br></code></pre></td></tr></table></figure><p><strong>delete from是逐行将整个表的数据删除, 有日志可以恢复</strong></p><p><strong>truncate table是直接将整个表重置, 速度最快, 但是操作不可恢复</strong></p><p>注意where语句后面是接boolean表达式, 可以使用逻辑判断符</p><blockquote><p>注意*只能用于select语句后面匹配任意列</p><p>%只能用于where like后面用于匹配单元格</p></blockquote><p>&#x3D;和:&#x3D;</p><blockquote><p>在SQL中单等号用于比较是否相等</p><p>:&#x3D;冒号等号用于赋值运算</p></blockquote><p>查询语句中可以嵌套子查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#嵌套子查询语句<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test4)t <span class="hljs-keyword">where</span> t.age<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>查询语句的结果是一个集合, 可以进行数学的并(union)运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">from</span> ... minus <span class="hljs-keyword">select</span> ... <span class="hljs-keyword">from</span> ...;<br></code></pre></td></tr></table></figure><blockquote><p>mysql不支持对select的结果集进行交(intersect)  差(minus) 运算</p></blockquote><p>并运算需要满足:</p><ol><li>两个结果集的列数量相等</li><li>两个结果集的数据类型必须一一相等</li></ol><p><strong>限制查询</strong></p><p>限制查询也被称为分页查询, 在mysql中通过limit关键字实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#从查询结果的<span class="hljs-number">0</span>号位(第一条数据)开始返回<span class="hljs-number">3</span>条数据<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test4 <span class="hljs-keyword">where</span> id<span class="hljs-operator">%</span><span class="hljs-number">2</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age limit <span class="hljs-number">0</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>上述SQL语句底层执行顺序和原理</p><p><strong>总体上可以视为从左向右执行</strong></p><blockquote><p>注意select筛选字段语句是紧跟在where之后执行即可</p></blockquote><p>1.读取整个表 2.where语句 3.select语句(筛选段) 4. order语句 5.limit语句</p><ol><li>读取test4表, 完整复制到内存中</li><li>执行where语句, 在上一步的内存表中筛选数据到新的内存表</li><li>执行selet语句, 从上一步的表中筛选对应的列到新的内存表</li><li>执行order语句, 对上一步的表进行排序, 排序好后存到新的内存表</li><li>执行limit语句, 对上一步的表进行分页后存到新的表打印给用户</li></ol><p>where语句可以用的运算符</p><table><thead><tr><th>运算符</th><th>功能</th></tr></thead><tbody><tr><td>&lt;&gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D;</td><td>关系运算符</td></tr><tr><td>+ - * %</td><td>算数运算符</td></tr><tr><td>and</td><td>并且, 需要两个条件都满足才执行</td></tr><tr><td>or</td><td>或者, 只需要满足一个条件才执行</td></tr><tr><td>not</td><td>取否(等同于java中的叹号)</td></tr><tr><td>between … and …</td><td>小于等于</td></tr><tr><td>in (,)</td><td>在括号内的范围进行匹配</td></tr><tr><td>like ‘%’</td><td>等同于通配符* 匹配多个任意字符</td></tr><tr><td>like ‘_’</td><td>等同于通配符. 匹配单个任意字符</td></tr><tr><td>is null</td><td>匹配空值</td></tr><tr><td>is not null</td><td>匹配非空值</td></tr><tr><td>limit  a,b</td><td>从查询结果的a号位(第一条数据)开始返回b行数据</td></tr></tbody></table><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><p>DQL: 数据库查询语言(Data Query Language)</p><blockquote><p>DQL语句都是select … from语句</p></blockquote><p>公司里80%的业务都是使用select语句查数据</p><p><strong>注意 select语句可以用算数运算符</strong></p><p><strong>where语句可以用算数运算符和逻辑运算符还有and or关键字</strong></p><p><strong>where语句不能作为单独的语句, 必须作为条件语句与修改语句或者查找语句搭配使用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">#将表中的所有数据打印出来<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student_info;<br>#将名字为小白的行的id加上<span class="hljs-number">1</span>, stu_name打印<br><span class="hljs-keyword">select</span> id<span class="hljs-operator">+</span><span class="hljs-number">1</span>,stu_name <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">where</span> stu_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;小白&#x27;</span>;<br>#按照age升序(从小到大)<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test4 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br>#按照age升序(从小到大)<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test4 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span>;<br>#按照age降序(从大到小)<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test4 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span>;<br>#复合排序, 按照age降序, age相同时按照id降序<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test4 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span>,id <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><table><thead><tr><th>语句</th><th>结果对象</th></tr></thead><tbody><tr><td>创建语句</td><td></td></tr><tr><td>create database …</td><td>database</td></tr><tr><td>create table …</td><td>table</td></tr><tr><td>修改表(对列进行操作)语句</td><td></td></tr><tr><td>alter … add …</td><td>column</td></tr><tr><td>alter … add constraint …</td><td>约束</td></tr><tr><td>修改行操作语句</td><td></td></tr><tr><td>update … set …</td><td>all row</td></tr><tr><td>update … set … where …</td><td>row</td></tr><tr><td>插入语句</td><td></td></tr><tr><td>insert into … values …</td><td>row</td></tr><tr><td>删除语句</td><td></td></tr><tr><td>delete from …</td><td>all row</td></tr><tr><td>delete from … where …</td><td>row</td></tr><tr><td>查找语句</td><td></td></tr><tr><td>select … from …</td><td>打印</td></tr><tr><td>select … from … where …</td><td></td></tr><tr><td>select … from … order by …</td><td>指定一列作为(默认)升序排列</td></tr><tr><td>select … from … order by … asc</td><td>指定一列作为(默认)升序排列</td></tr><tr><td>select … from … order by … desc</td><td>指定一列作为(默认)降序排列</td></tr><tr><td>select distinct … from …</td><td>查找结果去重复行后再打印(不会修改数据库源数据)</td></tr><tr><td>匹配语句(不能单独使用)</td><td></td></tr><tr><td>where</td><td>筛选条件</td></tr><tr><td>where … like …(通配符%_)</td><td>筛选条件</td></tr><tr><td>分组语句(不能单独使用)</td><td></td></tr><tr><td>group by …</td><td></td></tr><tr><td>group by … having …</td><td></td></tr></tbody></table><p><strong>sql中的字符串值必须用’’单引号括起来</strong></p><p>通配符%_既可以单独使用也可以在字符串中搭配使用</p><p>注意sql语句中如果一次用到多个值, 一般使用逗号,作为分割</p><p>mysql中还可以使用反斜线作为转义字符,可以使通配符作为普通字符进行匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#匹配name等于_\<span class="hljs-operator">%</span>小白的行<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;\_\\\%小白&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="mysql函数"><a href="#mysql函数" class="headerlink" title="mysql函数"></a>mysql函数</h1><blockquote><p>mysql中的数据类型分为数值类型 字符类型 日期类型</p><p>所以mysql中提供了对应的转换函数来完成类型转换</p></blockquote><p>SQL中的函数分为单行函数和多行函数(聚合函数)</p><blockquote><p>分别处理单行数据和多行数据</p></blockquote><p>mysql中的函数按照功能又能分为5种:</p><p>转换函数位函数流程控制函数加密解密函数 信息函数</p><h1 id="多行函数-聚合函数"><a href="#多行函数-聚合函数" class="headerlink" title="多行函数(聚合函数)"></a>多行函数(聚合函数)</h1><table><thead><tr><th>聚合函数</th><th>作用</th><th>操作对象</th></tr></thead><tbody><tr><td>count()</td><td>统计多少条数据</td><td>单列或多列</td></tr><tr><td>sum()</td><td>求和</td><td>单列</td></tr><tr><td>avg()</td><td>求平均值</td><td>单列</td></tr><tr><td>max()</td><td>求最大值</td><td>单列</td></tr><tr><td>min()</td><td>求最小值</td><td>单列</td></tr></tbody></table><p><strong>聚合函数只能统计单列数据, 不能统计多列数据, 所以不能使用*通配符</strong></p><blockquote><p>除了count()函数可以用</p></blockquote><p><strong>聚合函数不会统计列中为null数据</strong></p><blockquote><p>SQL中一列数据被称为一个字段</p></blockquote><p>可以使用ifull(列,默认值)函数给列中的null重新赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(ifnull(age,<span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> 平均年龄<br></code></pre></td></tr></table></figure><blockquote><p>多行函数测试</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#统计test4中总共有多少条数据, 注意limit语句是最后执行不会影响到<span class="hljs-built_in">count</span>()函数<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total <span class="hljs-keyword">from</span> test4 limit <span class="hljs-number">0</span>,<span class="hljs-number">3</span>;<br>#统计年龄大于<span class="hljs-number">20</span>岁的人数<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total_20_age <span class="hljs-keyword">from</span> stu_info <span class="hljs-keyword">where</span> age<span class="hljs-operator">&gt;=</span><span class="hljs-number">20</span>;<br>#统计表中有多少行数据<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> test;<br>#统计age字段有多少行非<span class="hljs-keyword">null</span>数据<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(age) <span class="hljs-keyword">from</span> test;<br></code></pre></td></tr></table></figure><blockquote><p>SQL不允许有整行都是null的数据</p></blockquote><h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><p><strong>注意group by和having语句都必须与聚合函数搭配使用</strong></p><p>分组查询的语句为group by</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#按照性别分组再统计每个性别的人数<br><span class="hljs-keyword">select</span> gender,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;<br></code></pre></td></tr></table></figure><p>mysql5.7前, select只能跟字段或聚合函数</p><p>mysql5.7后, select还可以跟group_concat()函数</p><blockquote><p>group_concat()函数的对象是字段</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br></code></pre></td></tr></table></figure><p>having语句用于对聚合函数的结果进行筛选</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#统计各班级的人数, 并筛选出人数大于<span class="hljs-number">3</span>的班级<br><span class="hljs-keyword">select</span> class_name,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> test <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> class_name <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h1 id="SQL总结"><a href="#SQL总结" class="headerlink" title="SQL总结"></a>SQL总结</h1><p>最简SQL语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段或(函数加字段) <span class="hljs-keyword">from</span> 表名; <br></code></pre></td></tr></table></figure><p>完整SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段或(函数加字段) <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 查询条件 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 字段 <span class="hljs-keyword">having</span> 过滤条件 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段 limit (a,b)<br></code></pre></td></tr></table></figure><p><strong>执行顺序从左向右</strong></p><blockquote><p>除了select字段语句是在where后执行, 但是实际上不影响最终结果</p></blockquote><blockquote><p>mysql5.7以上同时使用order by和limit语句时, 如果order by的列存在重复值, 会造成多页面数据重复</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student_info(<br>id <span class="hljs-type">int</span>,<br>stu_no <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>stu_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>,<br>birthday <span class="hljs-type">date</span>,<br>telphone <span class="hljs-type">int</span>,<br>deucation_level <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>fk_class_id <span class="hljs-type">int</span><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> class_info(<br>id <span class="hljs-type">int</span>,<br>class_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>class_leader <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br><br><span class="hljs-keyword">create</span> database szdx <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&#x27;utf8mb4&#x27;</span><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> class_info(id,class_name,class_leader) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1班&#x27;</span>,<span class="hljs-string">&#x27;大白&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;2班&#x27;</span>,<span class="hljs-string">&#x27;大白2&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3班&#x27;</span>,<span class="hljs-string">&#x27;大白3&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student_info(id,stu_name,age,fk_class_id,gender) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,&quot;小白&quot;,<span class="hljs-number">13</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;男&#x27;</span>),(<span class="hljs-number">2</span>,&quot;小白2&quot;,<span class="hljs-number">14</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;男&#x27;</span>),(<span class="hljs-number">3</span>,&quot;小白3&quot;,<span class="hljs-number">15</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;男&#x27;</span>),(<span class="hljs-number">4</span>,&quot;小白4&quot;,<span class="hljs-number">16</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> gender<span class="hljs-operator">=</span><span class="hljs-string">&#x27;男&#x27;</span>;<br><br><span class="hljs-keyword">update</span> student_info <span class="hljs-keyword">set</span> gender<span class="hljs-operator">=</span><span class="hljs-string">&#x27;男&#x27;</span>;<br><span class="hljs-keyword">update</span> student_info <span class="hljs-keyword">set</span> gender<span class="hljs-operator">=</span><span class="hljs-string">&#x27;女&#x27;</span>,age<span class="hljs-operator">=</span><span class="hljs-number">18</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">%</span><span class="hljs-number">2</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student_info <span class="hljs-keyword">add</span> gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> class_info <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> <span class="hljs-keyword">primary</span> key(id);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student_info <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> <span class="hljs-keyword">primary</span> key(id);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student_info <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> <span class="hljs-keyword">foreign</span> key(fk_class_id) <span class="hljs-keyword">references</span> class_info(id);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DDL</title>
    <link href="/2022/11/08/DDL/"/>
    <url>/2022/11/08/DDL/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>SQL: 结构化查询语言(Structured Query Language)</p><p>SQL数据库: 关系型数据库, 关注于数据间的关系</p><p>NO-SQL数据库: 非关系型数据库, 关注于存储数据本身</p><p>SQL语言分为: DDLDMLDQLDCL 事务控制语句</p><p>DDL:  数据库定义语言(Data Definition Language)</p><blockquote><p>用于建库建表</p></blockquote><p>DML:  数据库操作语言(Data Manipulation language)</p><blockquote><p>用于对表进行增删查改</p></blockquote><p>DQL:  数据库查询语言(Data Query Language)</p><blockquote><p>在表中查询数据[重点学习]</p></blockquote><p>DCL:  数据库控制语言(Data Control language)</p><blockquote><p>用于设定权限(数据库 表 数据)</p></blockquote><table><thead><tr><th>分类</th><th>关键字</th></tr></thead><tbody><tr><td>DDL</td><td>create  update  delete</td></tr><tr><td>DML</td><td>create  alter  drop  truncate</td></tr><tr><td>DQL</td><td>select</td></tr><tr><td>DCL</td><td>grant  revoke</td></tr><tr><td>事务控制语句</td><td>commit  rollback  savepoint add constraint</td></tr></tbody></table><p>查询语句是最复杂功能最丰富的SQL语句(面试重点)</p><p><strong>SQL语句的关键字不区分大小写</strong></p><blockquote><p>注意标识符是区分大小写的</p></blockquote><p>标识符命名规则:</p><ol><li>以字母开头</li><li>由字母 数字和三个特殊符号组成 #_$</li><li>多个单词用_分割开组成</li></ol><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><p>DDL是数据库定义语言, 用于对数据库进行增删查改</p><table><thead><tr><th>DDL命令</th><th>功能</th></tr></thead><tbody><tr><td>create</td><td>创建数据库或者数据库对象</td></tr><tr><td>drop</td><td>删除数据库或者数据库对象</td></tr><tr><td>alter</td><td>更改数据库结构或属性</td></tr><tr><td>truncate</td><td>删除表的所有记录, 包括分配的内存空间</td></tr><tr><td>comment</td><td>添加注释</td></tr><tr><td>rename</td><td>重命名数据库对象</td></tr></tbody></table><p>数据库对象: </p><table><thead><tr><th>名称</th><th>英文</th></tr></thead><tbody><tr><td>表</td><td>table</td></tr><tr><td>索引</td><td>index</td></tr><tr><td>函数</td><td>function</td></tr><tr><td>视图</td><td>view</td></tr><tr><td>存储过程</td><td>store procedure</td></tr><tr><td>触发器</td><td>trigger</td></tr></tbody></table><p><strong>MYSQL不支持重命名数据库, 但是可以将数据库复制到新命名的数据库</strong></p><blockquote><p>Data Definition Language </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建一个test数据库, 设置其字符集为utf8mb4<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>utf8mb4等同于java中的utf<span class="hljs-number">-8</span>, 四个字节存储空间<br><span class="hljs-keyword">create</span> database test <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&#x27;utf8mb4&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>utf8在数据库只有3个字节, 尽量使用utf8mb4</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改数据库的字符集<br><span class="hljs-keyword">alter</span> database test <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> <span class="hljs-string">&#x27;utf8mb4&#x27;</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除数据库<br><span class="hljs-keyword">drop</span> database test;<br></code></pre></td></tr></table></figure><blockquote><p>在test数据库中创建stu_info表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>进入test数据库进行操作<br>use test;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建空的stu_info表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu_info();<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建有数据的teacher_info表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> teacher_info(<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>列名 数据类型(size) [约束],<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>size<span class="hljs-operator">=</span><span class="hljs-number">20</span>代表有<span class="hljs-number">20</span>个字符<br>teacher_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>数据类型不需要添加size<br>age <span class="hljs-type">int</span>,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>小数点数<br>    test_price <span class="hljs-type">decimal</span>,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">default</span>设置默认值约束, 不设置默认值会为空(<span class="hljs-keyword">null</span>)<br>    test_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;小白&#x27;</span>,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>大文本类型<br>    test_text text,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>图片文件(二进制文件)<br>    test_img <span class="hljs-type">blob</span>,<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">2</span>),<br>work_no <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><blockquote><p>修改表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改表名teacher_info为new_teacher_info<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher_info rename <span class="hljs-keyword">to</span> new_teacher_info;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>向表中添加列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher_info <span class="hljs-keyword">add</span> birthday <span class="hljs-type">date</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher_info change birthday teacher_birthday <span class="hljs-type">int</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher_info <span class="hljs-keyword">drop</span> birthday;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除表<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> teacher_info;<br></code></pre></td></tr></table></figure><h1 id="MYSQL数据类型"><a href="#MYSQL数据类型" class="headerlink" title="MYSQL数据类型"></a>MYSQL数据类型</h1><p>mysql中的数据类型主要有3种数值类型 字符串类型  日期类型</p><table><thead><tr><th>类型</th><th>具体类型</th></tr></thead><tbody><tr><td>数值类型</td><td>严格数值类型 近似数值类型</td></tr><tr><td>字符串类型</td><td>char, varchar, binary, varbinary, blob, text, enum, set</td></tr><tr><td>日期类型</td><td>datetime, timestamp, date, time, year</td></tr></tbody></table><p><strong>mysql支持所有标准sql数值类型</strong></p><p>严格数值类型:integer(int) smallint decimal(dec) numeric</p><p>近似数值类型:float real double precision</p><p>字符串类型:</p><blockquote><p>varchar:  变长字符串char:  定长字符串</p><p>blob:  二进制长文本数据text:  长文本数据</p><p>char(30)代表其可以存储30个字符, 并非代表字节个数</p></blockquote><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><p>DML用于表操作</p><blockquote><p>Data Manipulation Language</p></blockquote><h1 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h1><p>ER图: 实体关系图(Entity Relationship图)</p><p>ER图是需求分析的结果</p><p>用于描述实体间的关系, 通过ER图可以设计对应的数据库</p><p>ER图的组成部分: 矩形椭圆菱形</p><blockquote><p>矩形表示实体</p><p>椭圆表示属性(实体的属性)</p><p>菱形表示关系(实体间的关系)</p></blockquote><p><img src="/2022/11/08/DDL/image-20220524144901109.png" alt="image-20220524144901109"></p><blockquote><p>ER图一般由产品经理在需求分析阶段提供, 用于设计对应的数据库</p></blockquote><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束(constraint)是对数据库数据做的限制</p><p>可以用于限制一列的数据或者一行的数据</p><p>主键约束: primary key</p><p><strong>主键必须是唯一的, 不能为空, 尽量避免修改主键</strong></p><blockquote><p>注意多个列可以组合构成主键, 被称为复合主键</p></blockquote><blockquote><p>创建带约束的表</p></blockquote><p>外键可以有重复值, 可以为空(即使主键是非空的),</p><p>外键必须对应另外一个表的主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_info(<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置自增<br>id <span class="hljs-type">int</span> auto_increment,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置非空<br>user_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置唯一<br>login_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span>,<br>telephone <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span>,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置默认<br>edu_school <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span>(<span class="hljs-string">&#x27;蜗牛学苑&#x27;</span>),<br>fk_role_id <span class="hljs-type">int</span>,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置主键<br><span class="hljs-keyword">primary</span> key(id),<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置外键<br><span class="hljs-keyword">foreign</span> key(fk_role_id) <span class="hljs-keyword">references</span> role_info(id)<br>);<br></code></pre></td></tr></table></figure><blockquote><p>在表中增加约束</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>主键约束<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test5(<br>pk_id <span class="hljs-type">int</span>,<br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>约束是一个独立语句应该用逗号分隔开<br><span class="hljs-keyword">primary</span> key(pk_id)<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将id设置为主键<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test8 <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(id);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除表的主键约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test8 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>在表里增加列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test9 <span class="hljs-keyword">add</span> ok2 <span class="hljs-type">int</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将ok列设置为唯一的, 不允许有重复值<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test9 <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span>(ok);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将ok2列的默认值设置为<span class="hljs-keyword">default</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test9 <span class="hljs-keyword">alter</span> ok2 <span class="hljs-keyword">set</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将ok列重新定义(重命名并设置属性和注释)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>注释一般在定义表的时候给列添加, 并非设计成可以用语句单独修改<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test9 change `ok` `ok3` <span class="hljs-type">int</span> comment &quot;id of test&quot;;<br></code></pre></td></tr></table></figure><p>对于外键约束, mysql会默认进行级联检查</p><blockquote><p>可以用SQL语句将级联检查报错机制改为自动级联删除, 级联更新机制</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> cascade <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> cascade;<br></code></pre></td></tr></table></figure><blockquote><p>级联检查机制对于大数据量的表来说效率低, 耗费时间</p><p>所以一般不添加外键约束, 使用自定义列作为无约束’外键’, 不属于SQL范畴的外键</p></blockquote><h1 id="数据库范式-Normalization"><a href="#数据库范式-Normalization" class="headerlink" title="数据库范式(Normalization)"></a>数据库范式(Normalization)</h1><p>数据库范式有 1NF 2NF 3NF BCNF 4NF 5NF 6NF</p><p><strong>范式中1NF 2NF 3NF是最重要的</strong></p><p>第一范式: 原子性, 每一列都不能再被拆分</p><p>第二范式: 1NF的基础上, 所有列必须与主键有关系(相关)</p><blockquote><p>要求一个表中必须有主键(必须是单列主键, 不能是复合主键), 所有的列都必须与主键有关系</p></blockquote><blockquote><p>主键必须是每行信息的唯一标识</p><p>所有的列都必须与主键有关系</p></blockquote><p>第三范式: 1NF 2NF的基础上要求, 所有列必须跟主键有直接关系, 不能是间接关系</p><blockquote><p>间接关系: 属性A依赖于属性B再依赖于主键</p></blockquote><p>解释:</p><blockquote><p>遵循第一范式时要根据系统实际需求来合理设计,  例如地址属性中如果’城市’部分经常被访问, 那么需要将地址中的城市等部分拆分开来存储才算满足数据库第一范式</p></blockquote><blockquote><p>第二范式: 不能将可以存储成多个表的数据保存在同一个表里, 例如商场数据库中, 商品信息和订单信息应该用两个不同的表来存储, 减少数据库冗余才算满足第二范式</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DCL</title>
    <link href="/2022/11/08/DCL/"/>
    <url>/2022/11/08/DCL/</url>
    
    <content type="html"><![CDATA[<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p>DLC: 数据库控制语言, 通常由DBA用于管理数据库权限</p><blockquote><p>Data Controller Language</p></blockquote><p>作用: 管理数据库的权限</p><blockquote><p>管理用户访问和操作特定数据库或表的权限</p></blockquote><p>面试题:</p><p>在公司内不能用数据库root账号进行开发</p><blockquote><p>按照团队分: 开发 测试 运维</p><p>也会按照项目分</p></blockquote><p><strong>一般不能将数据库访问权限提供给第三方使用</strong></p><p>需要提供数据给第三方时可以通过api</p><p><strong>表权限有四种: 增删查改 insert delete select update</strong></p><p>**增删查改的英文为CRUD: create read update delete</p><blockquote><p>DCL语句</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#将woniuxy数据库的所有表的所有权限授权给用户<span class="hljs-keyword">user</span>@任何IP地址<br>#注意数据库的权限需要通过用户名和登陆的IP地址进行双重认证<br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> woniuxy.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br>#注意mysql8不允许在<span class="hljs-keyword">grant</span>命令中新建用户, 所以下行<span class="hljs-keyword">sql</span>命令会报错<br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> woniuxy.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;new_user&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>#刷新权限<br>flush privileges;<br></code></pre></td></tr></table></figure><blockquote><p>移除权限</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#移除增改删权限<br><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">insert</span>,<span class="hljs-keyword">update</span>,<span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> woniuxy.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;user&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br>#刷新权限<br>flush privileges;<br></code></pre></td></tr></table></figure><blockquote><p>SQL命令创建用户</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#查询系统表中的密码限制的环境变量<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;validate_password%&#x27;</span>;<br>#创建一个test用户,设置密码<span class="hljs-number">12345678</span>aA<span class="hljs-operator">!</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> test identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;12345678aA!&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图 view被称为虚拟表, 视图本身不存储数据, 仅仅存储查询语句从数据库中读取数据并展示</p><blockquote><p>所以当数据库中的数据发生变化时, 表展示的数据也会变化</p></blockquote><blockquote><p>创建一个表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">#创建一张v_test表, 存储woniuxy数据库中test表的id字段数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> v_test <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> woniuxy.test;<br>#跟子查询一样, 视图也可以作为查询语句的数据源<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> v_test;<br>#删除视图<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> v_test;<br></code></pre></td></tr></table></figure><p><strong>查询语句的返回结果本质就是一个临时视图(行内视图)</strong></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>常见的函数: <strong>注意函数的操作对象一般为单个字段</strong></p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>count</td><td>计数</td></tr><tr><td>sum</td><td>求和</td></tr><tr><td>avg</td><td>求平均值</td></tr><tr><td>max</td><td>求最大值</td></tr><tr><td>min</td><td>求最小值</td></tr><tr><td>ifnull</td><td>筛选并保留空值</td></tr><tr><td>group_concat</td><td>将某个字段的多行记录合并为一行记录, 用逗号分割</td></tr></tbody></table><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p><strong>字符串函数的操作对象可以为字段或字符串</strong></p><p><strong>字符串函数不会操作数据源本身, 仅仅是将操作结果打印出来</strong></p><p>字符串函数有</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>concat(a,b)</td><td>拼接a和b</td></tr><tr><td>substr( … from … for …)</td><td>截取</td></tr><tr><td>trim( a from b)</td><td>从b中删除a(删除位置是开头和结尾,可以匹配多个, 不会删除中间被其他字符包围的a)</td></tr><tr><td>trim(a)</td><td>删除a中的空格</td></tr><tr><td>uuid()</td><td>没有操作对象, 直接返回一个36位的随机码(字符串)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">#将id字段和stu_name字段合并为一列新记录, 并且插入字符串<br><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;id:&#x27;</span>,id,<span class="hljs-string">&#x27;  姓名:&#x27;</span>,stu_name) <span class="hljs-keyword">from</span> stu_info;<br>#删除stu_name的空格并输出<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(stu_name) <span class="hljs-keyword">from</span> stu_info;<br>#删除学生姓名开头或结尾的<span class="hljs-string">&#x27;张&#x27;</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">TRIM</span>(<span class="hljs-string">&#x27;张&#x27;</span> <span class="hljs-keyword">from</span> stu_name) <span class="hljs-keyword">from</span> stu_info;<br></code></pre></td></tr></table></figure><p>常用日期函数</p><blockquote><p>下列三个函数都没有操作对象, 直接返回一个表示当前时间的字符串</p></blockquote><table><thead><tr><th>函数</th><th>格式</th></tr></thead><tbody><tr><td>now()</td><td>yyyy-MM-dd hh:mm:ss</td></tr><tr><td>curdate()</td><td>yyyy-MM-dd</td></tr><tr><td>curtime()</td><td>hh:mm:ss</td></tr></tbody></table><p>year() month() day() 分别读取对象中的年份 月份 日</p><p><strong>dual表是一个虚拟表, 不包含任何数据 仅仅用于使sql命令符合语法要求</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">#获取当前的年份<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(now()) <span class="hljs-keyword">from</span> dual;<br>#获取当前的月份<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">month</span>(now()) <span class="hljs-keyword">from</span> dual;<br>#获取当前的天数<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">day</span>(now()) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><p>一个完整的软件系统应该包含程序(计算逻辑)和数据</p><p>DBMS通过提供函数提供了计算能力, 而不仅仅是存储数据</p><p><strong>数据库自定义函数仅仅需要了解, 不需要深究</strong></p><p>调用自定义函数必须使用select语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> test_max(id) <span class="hljs-keyword">from</span> test;<br></code></pre></td></tr></table></figure><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>一般的函数都只能通过select语句调用, 意味着其返回结果只能打印出来而不能存储到数据库中</p><p>存储过程是一个特殊的函数,不需要通过select语句执行</p><p>可以使用存储过程来修改数据库</p><blockquote><p>delimiter语句用于声明函数或存储过程的开始和结束</p></blockquote><p>delimiter $$ … $$ delimiter;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter $$<br>#声明存储过程<br>#<span class="hljs-keyword">in</span>表示输入参数 <span class="hljs-keyword">out</span>表示输出参数 <span class="hljs-keyword">inout</span>表示该参数可以输入也可以输出<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> test(<span class="hljs-keyword">in</span> id <span class="hljs-type">int</span>,<span class="hljs-keyword">in</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<span class="hljs-keyword">out</span> res <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span> <br>... #<span class="hljs-keyword">sql</span>命令<br><span class="hljs-keyword">end</span>$$<br>delimiter;<br></code></pre></td></tr></table></figure><blockquote><p>调用存储过程</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">#<span class="hljs-variable">@res</span>表示全局参数<br><span class="hljs-keyword">call</span> test(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;小白&#x27;</span>,<span class="hljs-variable">@res</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@res</span>;<br></code></pre></td></tr></table></figure><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>mysql中常用的约束有4种</p><table><thead><tr><th>关键字</th><th>限制</th></tr></thead><tbody><tr><td>not null</td><td>非空</td></tr><tr><td>unique</td><td>唯一</td></tr><tr><td>primary key</td><td>主键</td></tr><tr><td>foreign key</td><td>外键</td></tr></tbody></table><blockquote><p>auto_increment和default并非约束, 而是添加新数据的逻辑, 不会对字段数据进行完整性检查</p></blockquote><p>主键约束 primary key</p><p>主键约束包含了非空约束和唯一约束, 意味着主键必须是非空且唯一的</p><p>一个表只允许有一个主键</p><p>主键可以是一个字段或者多个字段组成(复合主键)</p><p>约束分为列级(字段)约束和表级约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(<br>    #列级约束<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br>    #创建表级约束并设置约束名test<br>    <span class="hljs-keyword">constraint</span> test <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br>    #创建表级约束, 多个字段作为复合主键<br>    <span class="hljs-keyword">primary</span> key(id,name)<br>);<br>#用<span class="hljs-keyword">alter</span> ... modify ... 语句修改列定义来添加列级约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test modify id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key;<br>#添加新的主键约束前必须先删除旧主键约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br>#删除约束名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">drop</span> index test;<br>#用<span class="hljs-keyword">alter</span> ... <span class="hljs-keyword">add</span> ... 语句来添加表级约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(id);<br></code></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务(Transaction)</p><p>事务是数据库操作的执行基本单位, 事务可以包含一个或多个sql语句</p><p>早期的mysql存储引擎不支持事务, 现在mysql默认使用的InnoDB引擎提供了良好的事务支持</p><p>面试题: myisam和innodb的区别</p><table><thead><tr><th>特性</th><th>innodb</th><th>myisam</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>256TB</td></tr><tr><td>事务支持</td><td>支持</td><td>不支持</td></tr><tr><td>外键支持</td><td>支持</td><td>不支持</td></tr><tr><td>数据缓存支持</td><td>支持</td><td>不支持</td></tr><tr><td>默认储存引擎版本</td><td>mysql5.5及之后</td><td>mysql5.5之前</td></tr><tr><td>事务多线程安全</td><td>支持表锁</td><td>支持行锁</td></tr><tr><td>每个表对应的文件数目</td><td>2个(frm,ibd)</td><td>3个(frm,myd,myi)</td></tr><tr><td>默认索引结构</td><td>树形(B+树)</td><td>hash</td></tr></tbody></table><table><thead><tr><th>特性</th><th>树形索引</th><th>hash索引</th></tr></thead><tbody><tr><td>聚簇</td><td>支持</td><td>不支持</td></tr><tr><td>范围查找</td><td>支持</td><td>不支持</td></tr></tbody></table><blockquote><p>myisam其实支持树结构索引, 但是没有用树作为默认索引结构</p><p>innodb不支持hash索引</p></blockquote><p><strong>mysql作为DBMS有三层架构</strong></p><ol><li>连接层 处理客户端连接和鉴权认证</li><li>服务层 负责查询语句(select语句)的解析 优化 缓存, 还有内置函数和存储过程的实现</li><li>存储引擎  负责数据库中数据的存储 提取(write read)</li></ol><p><img src="/2022/11/08/DCL/image-20220527154444039.png" alt="image-20220527154444039"></p><p><strong>存储引擎是DBMS架构的最底层并且最核心的组成部分, 直接负责事务的实现</strong></p><blockquote><p>执行sql命令时会自动生成事务,自动提交</p></blockquote><blockquote><p>mysql手动声明事务</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#声明事务开始<br><span class="hljs-keyword">start</span> transaction;<br>#<span class="hljs-keyword">start</span> transaction等同于<span class="hljs-keyword">begin</span>语句<br>#<span class="hljs-keyword">rollback</span>;语句会上面的所有语句注释掉, 必须进行新的声明(<span class="hljs-keyword">begin</span>)<br>#一条或多条<span class="hljs-keyword">sql</span>语句<br>... <br>#提交事务, 将<span class="hljs-keyword">sql</span>命令的执行结构写入数据库<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>事务必须满足四特性: ACID</p><table><thead><tr><th>特性</th><th>要求</th><th>英文</th></tr></thead><tbody><tr><td>原子性</td><td>事务不可再分</td><td>atomicity</td></tr><tr><td>一致性</td><td>同一事务的数据准确无误, 不能有差异</td><td>consistency</td></tr><tr><td>隔离性</td><td>不同事务间相互独立, 互不干扰</td><td>isolation</td></tr><tr><td>持久性</td><td>一条事务被commit后存储到磁盘中, 在执行新事务前数据不能被修改</td><td>durability</td></tr></tbody></table><blockquote><p>事务要保证正确可靠必须具备ACID四特性</p></blockquote><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引: index</p><p>可以通过索引快速查找到数据库中的数据</p><p><strong>索引可以提高数据库的查询效率</strong></p><blockquote><p>hash索引结构</p></blockquote><p><img src="/2022/11/08/DCL/image-20220527175935911.png" alt="image-20220527175935911"></p><p>hash索引结构不支持范围查找和聚簇索引</p><p>innoDB是用B+树结构作为索引结构</p><blockquote><p>B+树索引结构</p></blockquote><p><img src="/2022/11/08/DCL/image-20220527180430136.png" alt="image-20220527180430136"></p><blockquote><p>B+树索引(并且主键作为索引)可以将其余数据都聚合到索引叶子节点上, 这被称为聚簇索引</p><p>B+树索引支持范围查询, 搜索效率高</p></blockquote><p>聚簇: 索引和数据放在同一个区域中</p><p>非聚簇: 索引和数据放在不同的区域</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>b树: b-tree</p><p>b树是一种特殊的自平衡搜索树</p><blockquote><p>注意b树不是二叉树, 可以有多个子节点</p></blockquote><p><strong>二叉树适合将数据存储到内存中</strong></p><p>而B树的数据一般保存到磁盘中</p><p>B树的设计思想是尽量减少树的高度(减少磁盘的访问次数)</p><blockquote><p>内存的数据访问时间非常快,适合进行多次访问</p><p>而磁盘的数据访问时间非常慢, 需要尽量减少访问次数</p></blockquote><p>树状数据的操作(搜索 插入 删除 求最大值或最小值)所需磁盘时间为O(h)</p><blockquote><p>h为树的高度</p></blockquote><p>B树的节点数目需要尽可能接近或等同于磁盘块大小(block)</p><blockquote><p>block是磁盘读写的基本单位</p></blockquote><p>自平衡二叉搜索树(如红黑树, AVL树), 由于其节点最多只能有两个子节点, 导致其高度很高, 需要频繁进行数据访问</p><p>而B树的高度尽可能的降低, 所以其数据访问次数会比二叉树低很多</p><p><strong>B树的操作(搜索 插入 删除)时间复杂度为O(log n)</strong></p><p>B树特性:</p><ol><li>所有</li></ol><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是一种特殊的B树, B+树只能用叶子来存储数据指针</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DP(动态规划)</title>
    <link href="/2022/11/08/DP(%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)/"/>
    <url>/2022/11/08/DP(%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)/</url>
    
    <content type="html"><![CDATA[<h1 id="DP-动态规划"><a href="#DP-动态规划" class="headerlink" title="DP(动态规划)"></a>DP(动态规划)</h1><blockquote><p>从算法的优化角度</p></blockquote><p>暴力递归遍历 -&gt; 记忆化搜索 -&gt; 动态规划</p><blockquote><p>也可以认为是从个例情况的遍历到对一个集合(多个例)的枚举</p></blockquote><p>在用动态规划解决问题前, 可以先写一个暴力递归的解决版本, 然后将暴力递归进一步优化为动态规划</p><p>动态规划以解决背包问题而闻名</p><p>动态规划是递归(函数调用自身)的一种特殊优化, 可以用于解决递归问题</p><p>动态规划可以理解为将问题划分为数个子问题, 然后通过递归将子问题的结果存储起来</p><p><strong>如何确定一个问题可以用动态规划解决</strong></p><p>一般DP的问题都可以用粗暴遍历所有的情况来解决, 但是这样做会导致时间复杂度和空间复杂度非常高</p><blockquote><p>状态亦可以被称为最优解</p></blockquote><p>因此DP从一个已知的状态出发, 根据会出现的情况计算出下一个状态, 直到达到目标状态</p><p>动态规划使用的前提是无后效性: 状态的唯一性, 不受前路径和后路径的影响</p><p>动态规划解决问题的关键是定义状态, 找到已有的状态以及不同状态间的转移方程</p><p>转移方程: 用于将通过计算将一个状态转换为另一条状态, </p><p>动态规划一般有两种模式:  表模式备忘录模式</p><p>表模式: 从下到上, 从底部开始计算状态, 从最底部的状态dp[0]开始通过状态转移方程逐渐转移到目标状态dp[n]</p><blockquote><p>表模式中状态的转移是顺序的</p></blockquote><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Tabulated version to find factorial x.</span><br><span class="hljs-type">int</span> dp[MAXN];<br><br><span class="hljs-comment">// base case</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i&lt; =n; i++)<br>&#123;<br>    dp[i] = dp[i-<span class="hljs-number">1</span>] * i;<br>&#125;<br></code></pre></td></tr></table></figure><p>备忘录(记忆)模式: 从上到下</p><blockquote><p>记忆模式中, 状态可以是非顺序转换的</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>0疯狂Java学习笔记</title>
    <link href="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>所有的类都是引用类型</p><p>一个对象可以有多个引用, 当对象不存在引用时, 会被GC(垃圾回收器)回收销毁其内存空间</p><p>将一个数组变量指向另一个数组变量时, 需要两个数组的类型相兼容</p><p>Java中没有从底层实现真正的多维数组, </p><p>例如:在Java里面的二维数组本质还是一维数组, 其数组元素储存引用变量, 引用变量指向另外的一维数组</p><p>如何定义多维数组: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type[][] arrName;<br></code></pre></td></tr></table></figure><p>初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">arrName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">type</span>[length][]<br></code></pre></td></tr></table></figure><p>上述语句实际上相当于初始化了一个一维数组, 该一维数组的长度为length, 其数组元素为引用类型, 被系统自动初始化赋值为null</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220427102048009.png" alt="image-20220427102048009"></p><blockquote><p>注意上图中定义了一个元素为对象的数组, 其数值在内存的存储方式如图所示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>][];<br></code></pre></td></tr></table></figure><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220427102324663.png" alt="image-20220427102324663"></p><blockquote><p>上图中该二维数组进行了(一维)初始化, 其堆内存存储方式跟一维数组非常类似</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220427102454276.png" alt="image-20220427102454276"></p><blockquote><p>上图显示了二维数组对其数组元素进行了(二维)初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220427103350502.png" alt="image-20220427103350502"></p><blockquote><p>Java里面的三维数组也是一维数组, 其数组元素是二维数组, 二维数组里面的数组元素是一维数组, 所以Java多维数组的本质都是一维数组</p></blockquote><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>在Array类里面的static修饰的方法可以直接调用来操作数组</p><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(type[] a, type key)</span> <br></code></pre></td></tr></table></figure><p>可以用二分法在a数组中查找key, 返回其出现过的索引值 由于二分法的要求,a数组中的元素必须是从小到大排序才能正确查找 如果不包含则返回一个负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(type[] a, <span class="hljs-type">int</span> formIndex, <span class="hljs-type">int</span> toIndex, type key)</span><br></code></pre></td></tr></table></figure><p>与前一个方法类似, 但是搜索范围限制在 formIndex到toIndex里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type[] copyOf(type[] originalArray, <span class="hljs-type">int</span> length)<br></code></pre></td></tr></table></figure><p>将originalArray数组复制为length长度的新数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type[] copyOfRange(type[]originalArryay, <span class="hljs-type">int</span> form, <span class="hljs-type">int</span> to)<br></code></pre></td></tr></table></figure><p>与前方法类似, 但是将复制范围限制在form到to的索引范围内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(type[] a,type[] a2)</span><br></code></pre></td></tr></table></figure><p>如果两个数组的长度和数组元素一一对应相同,则返回true 否则返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(type[] a,type value)</span><br></code></pre></td></tr></table></figure><p>将a数组中的元素都赋值为value(注意这里的value需要是type类型的具体值)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(type[] a,<span class="hljs-type">int</span> formIndex,<span class="hljs-type">int</span> toIndex,type value)</span><br></code></pre></td></tr></table></figure><p>与上一方法类似, 但是仅仅将索引范围内的元素赋值为value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(type[] a)</span><br></code></pre></td></tr></table></figure><p>对a数组中的数组元素进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(type[] a, <span class="hljs-type">int</span> formIndex, <span class="hljs-type">int</span> toIndex)</span><br></code></pre></td></tr></table></figure><p>与上一方法类似,但是仅对范围内的元素进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">toString</span><span class="hljs-params">(type[] a)</span><br></code></pre></td></tr></table></figure><p>将数组的元素按顺序拼接为字符串并返回, 每个元素中间用逗号和空格进行分割</p><p>在Java8中, 对Array类的功能进行了增强, 添加了新的工具方法(这些方法支持利用CPU的并发处理性能)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">parallelSort</span><span class="hljs-params">(type[] a)</span><br></code></pre></td></tr></table></figure><p>与sort方法类似, 但是增加了对并发运算的支持</p><blockquote><p>用parallel开头的方法都表示该方法增加了对并行计算的支持</p></blockquote><h1 id="类-class"><a href="#类-class" class="headerlink" title="类(class)"></a>类(class)</h1><p>类是一种特殊的数据类型, 在Java里面使用类定义的变量都是引用变量(全局变量)</p><p>类用于描述具有相同特征(相似属性)的某一类对象</p><p>对象是类的实例</p><p>在Java中对象是通过调用对应类的构造器类创建的</p><blockquote><p>面向对象三大特征: 封装 继承 多态</p></blockquote><p>Java提供了三种访问控制修饰符来实现封装</p><p>private protected public</p><p>extends关键字来实现继承</p><p>通过继承, 子类可以继承父类中的成员变量(类中方法外的变量)和方法</p><p>访问控制允许的情况下, 子类实例(对象)可以直接调用父类中方法</p><blockquote><p>继承是实现类复用的重要手段, 类的复用也可以通过组合关系来实现 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br></code></pre></td></tr></table></figure><p>上述代码将子类的对象赋值给了父类变量, 使得该变量具有了多态性</p><blockquote><p>如果是用组合关系来实现复用, 无法这样子来实现多态</p><p>灵活性差</p></blockquote><p>Java中通过构造器来对类的实例进行初始化, 构造器支持重载</p><p>如果多个重载的构造器包含相同的代码, 可以考虑将代码块放入类的初始化代码块中</p><blockquote><p>类的初始化代码块的执行会早于构造器</p></blockquote><p><strong>当一个子类被初始化时, 系统会自动初始化它的所有父类</strong></p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>在Java中, 类是一种引用变量</p><p>面向对象程序设计的重要概念: 类 对象</p><blockquote><p>对象是类的实例 类是对象的抽象</p></blockquote><p>类的修饰符有 public final abstract, 也可以不加修饰符</p><p>类包含三种最常见的成员: 构造器 成员变量 方法</p><p>如果一个类不包含任何成员, 则其为空类</p><p>static修饰的成员不能访问非static成员, 只能访问其他用static修饰的成员</p><p>Java中通过new 关键字来调用对应类的构造器, 构造器会返回该类的一个实例</p><p>构造器是类创建对象的默认途径</p><p>没有构造器的类通常无法创建实例</p><p>如果没有自定义的构造器, 系统会自动为类生成一个构造器</p><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><p>成员变量的修饰符有public, protected, private, static, final</p><p>(public protected private)三个修饰符只能出现其中之一</p><blockquote><p>Java中的方法组成成分: 修饰符 方法名 形参列表</p><p>代码块 返回值</p></blockquote><p>static修饰的成员代表它属于类本身, 不属于单个实例.</p><p>所以static修饰的方法和成员变量也称为类方法 类变量</p><p>没有static修饰的方法 成员变量只能在类的单个实例里面调用(对象), 也叫做实例方法 实例变量</p><blockquote><p>在大部分中文资料里面将static修饰的成员称为静态成员 (静态方法 静态变量), 但实际上特性跟动态没有相反的意思</p></blockquote><p>静态成员无法直接访问非静态成员</p><h1 id="构造器-构造方法"><a href="#构造器-构造方法" class="headerlink" title="构造器(构造方法)"></a>构造器(构造方法)</h1><p>构造器是一个特殊的方法(构造方法)</p><p>构造器不能声明返回值的类型, 也不能用void关键字来修饰</p><p>构造器执行步骤:</p><ol><li><p>申请整个对象的空间</p></li><li><p>分配属性空间</p></li><li><p>给属性赋值(自动赋值或者显示赋值)</p><blockquote><p>注意自动赋值是给数值型赋0或0.0, boolean赋false, 引用型赋null</p></blockquote></li><li><p>执行构造器中除了赋值的代码</p></li></ol><blockquote><p>实例初始化块在第二步之后,第三步之前执行</p><p>任何显式赋值都会导致自动赋值取消</p><p>自动赋值只会对对未赋值的属性进行操作</p></blockquote><p>因为一旦用类型关键字来声明后, Java不会将其当作构造方法来执行, 而是作为普通方法来执行</p><p>构造方法的语法结构包括: 修饰符 构造方法名 形参列表</p><blockquote><p>系统默认提供的构造方法是不带形参的</p></blockquote><p>Java中的类可以用来:</p><p>定义变量</p><p>创建对象</p><p>调用类方法或者访问类变量</p><blockquote><p>无符号右移&gt;&gt;&gt; </p></blockquote><p>栈内存: 存储局部变量</p><p>堆内存: 储存全局变量(类变量)</p><p>Java里面的引用相当于C语言中的指针</p><blockquote><p>指针: 储存了内存的地址值, 可以通过该地址值访问实际的对象</p></blockquote><p>但是Java的引用对指针操作进行了封装, 减少了烦琐操作, 提高了编程效率</p><blockquote><p>当一个对象没有任何引用变量指向它时, 该对象将被GC回收, 释放它占用的内存空间</p><p>将一个对象的所有引用变量都赋值为null时, 将导致没有任何引用变量指向该对象</p></blockquote><p><strong>this</strong>关键字总是指向调用该方法的对象</p><p>在构造器中this会引用该构造器正在初始化的对象</p><p>在方法中this会引用调用该方法的对象</p><p>this关键字主要用于在类中的一个方法里面访问该类的其他方法或类变量(避免需要重复创建对象来调用其他方法)</p><p>在Java中一个类的类成员可以直接调用其他成员, 相当于省略了this前缀(和加上this的效果是完全一样的)</p><p><strong>注意在static修饰的方法中是不允许使用this关键字的</strong></p><blockquote><p>遵循了类成员(static 静态)无法访问非类成员(非static 非静态)的语法规定(静态成员无法访问非静态成员)</p></blockquote><p>当一个类中的方法里有局部变量和全局变量同名, 会导致全局变量被覆盖掉, 这时必须使用this关键字才能访问全局变量</p><p>从功能上来看, 面向对象中的方法类似于结构化程序里面的函数, 但是Java里面的方法不能独立于对象, 必须定义在类里面</p><p>被static修饰的方法属于该类, 没有static修饰的方法属于该类的实例(对象)</p><p>Java中方法的特点:</p><ol><li>不能独立于类, 只能在类里面定义</li><li>只能属于类或者属于类的实例</li><li>不能独立执行, 只能被类或对象调用</li></ol><p>调用方法传给方法的参数值为实参</p><p>方法中负责接收的变量(参数)也被称为形参</p><p>Java中只有一种参数传递方式: 值传递</p><blockquote><p>值传递实际上将实参的数值赋值给了形参, 对形参做的操作不会对实参产生影响</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220428112756882.png" alt="image-20220428112756882"></p><blockquote><p>上图表示了从main方法中将a, b参数传递给swap方法中的a, b参数时, 内存空间中值的储存方式</p><p>注意每个方法在执行时, 都会创建属于该方法的栈(stack)内存</p></blockquote><p>但是如果传入的值是引用变量时, 虽然实参跟形参实际上还是两个不同的引用变量, 但是它们都指向同一个对象(内存地址)</p><p>所以对形参进行操作时, 实际上会访问该形参指向的对象进行操作, 导致访问实参时候也会发现该对象在操作后会发生的改变</p><blockquote><p>要注意的时, 如果是将形参重新指向其他对象或者直接置为null, 不会对形参的指向产生影响</p></blockquote><p>在Java1.5中, 增加了新功能: 允许定义形参个数不定(可变)的方法,在形参类型后加… 表达该形参可以接受多个参数值, 并且多个参数值会作为数组传入</p><blockquote><p>注意类型必须指定, 个数可以不定</p><p>并且一个方法只能有一个个数可变的形参</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, String... books)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, String[] books)</span>;<br></code></pre></td></tr></table></figure><p>上述两行代码定义的方法对于编译器来说参数相同, 不可以能进行方法重载</p><p>两个方法里都可以把books作为数组处理. 但是调用它们时候必须用不同的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">test1(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;哈利波特&quot;</span>,<span class="hljs-string">&quot;简爱&quot;</span>);<br>test2(<span class="hljs-number">5</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;哈利波特&quot;</span>,<span class="hljs-string">&quot;简爱&quot;</span>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>写代码时候最好选用一种默认的风格</p><p>比如循环尽量用for循环去写</p><p>for循环里面的条件语句尽量使用&lt;&gt;大于小于号而不是大于等于小于等于&lt;&#x3D; &gt;&#x3D;号</p></blockquote><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归就是在一个方法里面调用方法它本身</p><blockquote><p>递归一定要向已知方向递归, 防止出现死循环</p></blockquote><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>Java允许同一个类里有多个重名的方法, 但是要求重名的方法对应的形参列表不能相同</p><p>如果一个类中包含多个方法名相同, 但是形参列表不同的方法, 就称为方法重载</p><p>(返回值不同不能作为方法重载的条件)</p><p>在Java中确定一个方法需要<strong>三要素</strong></p><ol><li>调用者 方法的所属者, 可以是类或对象</li><li>方法名 方法对应标识符</li><li>形参列表 调用方法时候, 实参的值将被赋值给形参</li></ol><p>形参个数可变的方法也可以被重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String... args)</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String args)</span>&#123;&#125;<br><span class="hljs-comment">//public void test(String[] args)&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>第二行代码传入参数只有一个, 可以作为test方法的方法重载</p><p>但是第三行代码不行</p><blockquote><p>不建议重载形参个数可变的方法, 因为会导致程序可读性的下降</p></blockquote><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Java中变量分为局部变量和成员变量</p><p>局部变量有形参 方法内定义的局部变量 (代码块内定义的代码)</p><p>成员变量有 实例变量 static类变量(都是在方法外定义的变量)</p><blockquote><p>注意: static类变量的生存周期和其所属的类相同</p><p>但是非static变量的生命周期是和其所属的实例相同的</p></blockquote><blockquote><p>类的生命周期: 类加载, 类验证, 类准备, 类解析, 类初始化…..</p></blockquote><p>类变量: 类成员变量</p><p>实例变量: 实例成员变量</p><p>两者统称成员变量</p><blockquote><p>当一个实例修改非static变量时候不会影响到同一个类的其他实例</p><p>但是当其修改static变量时候, 由于修改的是类成员变量, 会导致该类的其他实例读取该变量时候也会发现被修改了</p></blockquote><p><strong>成员变量会被系统自动初始化, 初始化的默认赋值与数组动态初始化的赋值规则完全相同</strong></p><blockquote><p>Java中可以通过实例来修改static修饰的成员变量, 但是这种做法会导致代码的可读性, 明确性都受到影响</p><p>建议使用通过类来修改static变量的做法替换</p></blockquote><blockquote><p>尽量避免在编程时候出现局部变量与成员变量同名的情况, 提高代码的可读性</p></blockquote><p>局部变量的生命周期:</p><ol><li>形参的作用域为整个方法</li><li>方法内定义的变量的作用域为从定义它的那段代码开始, 到方法结束</li><li>代码块的局部变量 作用域: 从定义它的代码开始到代码块结束</li></ol><p>局部变量除了形参, 都必须显式初始化后才能使用</p><p>成员变量不需要显式初始化, 系统提供的构造器会自动将其初始化</p><p>两个成员变量的标识符不允许相同</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220429100028459.png" alt="image-20220429100028459"></p><p>上图展示了类成员变量和实例成员变量在内存空间中的储存差别</p><p>引用变量里面保存的是对应实例的内存地址</p><blockquote><p>栈内存里面的变量一般不需要GC进行内存回收, 因为它的内存空间会随着方法或代码块的运行结束而销毁</p></blockquote><p>局部变量只能保存基本类型数值或者实例的引用</p><p>所以局部变量所需的内存空间很小</p><p>无脑使用成员变量不符合软件开发规范将导致</p><ol><li>成员变量的作用域过大, 程序的内聚性降低</li><li>成员变量的生存时间过长, 导致内存开销变大</li></ol><p>需要用到成员变量的常见情形:</p><ol><li>多个方法都需要用到该变量值</li><li>该变量用于描述一个类的固有信息</li></ol><p>良好的软件开发规范应该是尽可能的缩小一个变量的作用域, 不占用多余的内存时间</p><p><strong>引用类型的数组初始化时将每个数组元素赋值null</strong></p><p>使用前需要遍历一遍数组, 将每个引用遍历都new 一个对象</p><h1 id="隐藏和封装"><a href="#隐藏和封装" class="headerlink" title="隐藏和封装"></a>隐藏和封装</h1><p>Java中的类和实例的成员变量可以进行封装来向外界隐藏对象的内部信息</p><p>面向对象三大基本特征: 封装(Encapsulation) 继承(implement) 多态(polymorphism)</p><p>封装: 将对象的内部进行隐藏, 不允许外部程序直接访问成员变量, 在类的内部提供对应的方法来实现对成员变量的操作</p><p>封装可以实现:</p><ol><li>对类外面隐藏类的实现细节</li><li>提供方法来操作成员变量, 在方法里面可以加入安全限制逻辑</li><li>保证成员变量的完整性</li><li>提高代码的可维护性</li></ol><p>封装在Java里面通过访问控制修饰符来实现</p><p>Java里面有3种访问控制符: private protected public</p><p>还有一种情况是不加任何访问控制符的默认级别</p><p>访问控制级别从小到大</p><p>private -&gt; default -&gt; protected -&gt; public</p><p>访问控制级别表</p><table><thead><tr><th>范围</th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>同一个包</td><td></td><td>1</td><td>1</td><td>1</td></tr><tr><td>子类中</td><td></td><td></td><td>1</td><td>1</td></tr><tr><td>代码中任何类里面</td><td></td><td></td><td></td><td>1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码定义了一个Outer外部类和Inner内部类</p><p>访问控制符中, private和protected不能用于修饰外部类</p><blockquote><p>访问控制符可以用于控制类的成员能否被其他类访问</p></blockquote><blockquote><p>访问控制符可以用于修饰类成员和类本身</p></blockquote><blockquote><p>对于外部类, 只有一种访问修饰符可以用public</p><p>两种状态: 默认 public</p></blockquote><p>一份Java源代码文件中, 如果所有类都没有用public修饰, 则源代码文件名可以取任意的.</p><p>一个Java源代码中只能有一个public修饰的类, 且文件名必须与public修饰的类名相同</p><p>JavaBean规范: Java类的每个成员变量都用private修饰符修饰, 并且每个成员变量都需要提供对应的setter getter方法(必须是用public修饰的)</p><p>模块化程序设计特点:</p><ol><li>高内聚 (尽量将模块的内部数据, 功能实现向外界隐藏, 避免受到外界干扰)</li><li>低耦合 (提供封装好的方法给外部使用)</li></ol><p>访问控制符使用建议:</p><ol><li>大部分的成员变量都用private修饰, 仅当成员变量被static修饰时或者作为全局变量使用时才考虑用public修饰</li><li>如果一个类中的方法是提供给其子类重写用的, 应该用protected修饰</li><li>类的构造器应该用public修饰, 来运行其他类创建该类的实例, 大部分外部类也应该用public修饰</li></ol><h1 id="package"><a href="#package" class="headerlink" title="package"></a>package</h1><p>package(包)提供了类的多层命名空间, 用于解决类文件管理问题, 命名冲突</p><p>将一组功能相关的类放在同一个package下, 就组成了逻辑上的类库单元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> packageName;<br></code></pre></td></tr></table></figure><p>上述代码应该放在源代码的第一行, 意味着该源代码中定义的所有类都属于这个包</p><p>一个源文件只能对应一个包</p><blockquote><p>当源文件没有显式指定对应包名时, 则该源文件属于默认包</p></blockquote><blockquote><p>同一个包中的类文件不需要放在同一目录下(只需要它们都在CLASSPATH包含的目录下即可)</p><p>不同包的类文件不能放在同一目录下, 避免类名冲突</p></blockquote><blockquote><p>javac -d . Hello.java</p><p>使用-d选项编译时, 会自动建立包结构对应的文件目录结构</p><p>这样子避免了同名类文件的冲突, 同名类文件无法在同一目录下存放</p></blockquote><p>Array常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br>System.out.println(Arrays.toString(arrayName));<br>java.util.Arrays.toString(arrayNmae);<br></code></pre></td></tr></table></figure><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220505095746576.png" alt="image-20220505095746576"></p><blockquote><p>标准Java项目文件夹结构</p></blockquote><p>按照行业标准, 包名应该只由小写字母组成, 并且应该由有意义的单词组成</p><blockquote><p>调用另一个包包含的类时, 需要在类名前加上包前缀来调用</p><p>类全名: 包名+类名</p><p>当两个类处于同一个包中时,可以省略包名</p></blockquote><p>使用包名时必须写全名, 不可省略任何部分</p><p>一个源代码只能包含一个package语句</p><p>import语句应出现在package语句之后, 类定义语句之前</p><p>impoer语句可以用*来导入该包下面的所有类, 但是子包不会被导入</p><blockquote><p>在Java中, 父包与子包之间没有任何关系</p><p>仅仅作为认知</p><p>在Java中包名是一个整体, 不可进行缩写, 只能整个省略</p></blockquote><p>在Java中会默认导入java.lang中的所有的包</p><p>因此在java.lang下面的所有类如 String System都不需要显示导入就可以直接使用</p><blockquote><p>当import的包里面含有重名的类时候, 必须使用包名+类名来导入类</p></blockquote><p>java1.5中增加了静态导入的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Arrays.toString;<br></code></pre></td></tr></table></figure><p>静态导入只能用于导入指定类中的静态成员</p><p>静态导入在源代码文件中应该于普通导入处于同一位置</p><blockquote><p>使用静态导入可以省略包名以及类名, 直接使用导入的静态成员</p></blockquote><blockquote><p>接口和枚举都是一种特殊类</p></blockquote><p><strong>Java常用类库包</strong></p><p>java.lang 包含了java的核心类如String Math System Thread 默认被所有的Java源代码文件导入</p><p>java.util 包含了大量工具类 集合框架类 如: Arrays List Set</p><p>java.net 包含网络编程相关类</p><p>java.io 包含IO(输入&#x2F;输出)编程相关类</p><p>java.text 包含格式化相关的类</p><p>java.sql 包含数据库编程相关的类</p><p>java.awt 包含可视化窗口相关的类</p><p>java.swing 包含Swing GUI编程相关的类</p><h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><blockquote><p>一个类可以有多个构造器(构造器重载:类似于方法重载)</p></blockquote><p>自动初始化:</p><p>将整数型赋0 浮点数型赋0.0</p><p>布尔型 false 引用类型赋 null</p><p>Java程序创建对象的流程:</p><p>new 关键字调用构造器</p><p>系统分配对象的内存空间, 进行默认初始化</p><blockquote><p>疑问: 这里是默认构造器的本质吗?</p></blockquote><p>执行自定义构造器</p><p>返回对象的地址(相当于返回一个引用变量)</p><p><strong>当自定义构造器提供时, 系统将不会提供默认构造器(无参数构造器)</strong></p><p>用权限修饰符修饰构造器可以控制类的对象创建权限</p><p>protected使得只有子类可以调用该类的构造器</p><p>private可以阻止其他类调用该类的构造器</p><p>构造器重载: 一个类中包含多个构造器, 构造器的形参列表互不相同</p><p>构造器重载使得Java的同一个类可以包含多个初始化逻辑, 有多种方式来初始化对象</p><blockquote><p>构造器必须与类名相同</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> num02)</span>&#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//this();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中, 构造器用this关键字调用了其他构造器</p><p>注意一个构造器里面仅可调用一次</p><blockquote><p>之所以提供构造器重载的特性是为了实现代码的可复用性</p><p>避免出现重复的代码段 降低代码维护成本</p></blockquote><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote><p>面向对象三大特征: 继承 封装 多态</p></blockquote><p>继承是实现代码复用的重要手段</p><p>Java中的继承为单继承, 一个子类只能有一个父类</p><blockquote><p>Java舍弃了C++中复杂的多继承特性</p></blockquote><blockquote><p>但是也可以通过父类继承间接父类, 来使得子类间接继承多个(间接)父类</p></blockquote><p><strong>在Java中如果一个类没有显示指定一个类作为直接父类, 则会默认指定java.lang.Object类为其直接父类</strong></p><p><strong>java.lang.Object是Java中所有类的直接&#x2F;间接父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClass</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>上述代码中通过extends关键字, SubClass类继承了父类SuperClass</p><blockquote><p>extends原意为扩展, 所以也可以说子类是对父类的扩展</p></blockquote><blockquote><p>注意Java中子类无法继承父类的构造器</p></blockquote><p>derive(派生) 父类派生了子类</p><p>extends(继承) 子类继承了父类</p><p>derive extends都是描述同一动作, 但是角度&#x2F;方向不同</p><p>子类大部分情况下都是在父类的基础上增加新的成员变量和方法</p><p>但是存在例外情况: 方法重写(覆盖) (Override)</p><p>方法重写(override)与方法重载(overload)是完全不同的概念</p><p>方法重写:</p><p>子类中存在于父类同名的方法称为方法重写</p><p>方法重写规则: 两同两小一大</p><p>两同: 方法名 形参列表必须相同 (是否被static修饰符修饰也需要保持一致)</p><p>两小: 子类中的方法返回值<strong>类型</strong>必须小于或等于父类方法的返回值类型</p><p>子类方法抛出的异常类也应该比父类方法更小或相等</p><p>一大: 子类方法的访问权限应该比父类方法的更大或相等</p><blockquote><p>注意父类中用private修饰的方法对于子类来说是不存在的(隐藏) 这时候在子类中定义同名的方法不是方法重写</p></blockquote><p>super关键字用于在子类中调用被覆盖的父类方法</p><blockquote><p>super关键字不能出现在static修饰的方法中</p><p>但是可以调用被static修饰的方法</p></blockquote><p>super关键字也可以用于在子类中调用被隐藏的父类变量</p><blockquote><p>当子类中定义了与父类重名的变量时会导致父类变量被隐藏, 子类可以通过super关键字调用被隐藏的父类变量</p></blockquote><p>程序查找变量的顺序(优先级)为:</p><ol><li>找该方法中的局部变量</li><li>找该类中的成员变量</li><li>找父类中的成员变量</li><li>按结构遍历所有间接父类的成员变量直至最终的java.lang.Object</li><li>最终仍无法找到变量将出现编译错误</li></ol><p>找到同名变量后不会再执行后续步骤</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220505172804617.png" alt="image-20220505172804617"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Son s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><span class="hljs-comment">//int num=s.tag;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>((Parent)s).tag<br></code></pre></td></tr></table></figure><p>上述代码显示了在创建子类对象后, 用(Parent)来调用父类中被隐藏的变量</p><p><strong>子类可以用super关键字来调用父类的构造器</strong></p><blockquote><p>使用this或super关键字调用构造器必须出现在构造器执行体第一行, 因此不能同时出现</p></blockquote><p><strong>子类构造器一定会调用父类构造器一次</strong></p><p>三种情况:</p><ol><li>用super关键字调用父类构造器</li><li>用this关键字调用本类中另一个构造器, 另一个构造器调用父类构造器</li><li>以上两种情况都没有发生时, 系统默认调用父类无参数构造器</li></ol><p><strong>创建一个对象时, 一定是从对应类所在的继承树最顶层类的构造器开始依次向下执行, 因此最开始一定会执行java.lang.Object类的构造体, 最后才会执行本类的构造器</strong></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>Java中的引用变量同时有两个类型: 编译时类型 运行时类型</p><p>编译时类型由声明时使用的类型决定</p><p>运行时类型由该变量指向的对象决定</p><p>当编译时类型与运行时类型不同时, 就可能出现多态</p><p>多态是什么:将父类类型变量指向其子类对象</p><p>多态的特征: 同类型的变量, 调用同一方法时出现不同的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">FatherClass polymophicVar=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SonClass</span>();<br></code></pre></td></tr></table></figure><p>它的编译类型为FatherClass 运行类型是SonClass</p><p>当使用polymophicVar调用子类中覆盖了父类的方法时, 会出现多态</p><p>注意: ploymophicVar只能调用父类中的存在方法, 调用方法时会表现出子类中覆盖方法的行为 </p><blockquote><p>可以通过反射来执行子类中的方法</p></blockquote><blockquote><p>由于子类实质上是特殊的父类, 因此子类对象可以直接赋值给父类引用变量, 这时不会发生任何类型转换, 系统会自动完成 向上转型(upcasting)</p></blockquote><blockquote><p>注意实例变量没有多态性, 用ploymophicVar只能调用父类中的实例变量, 不能调用子类中的实例变量</p></blockquote><blockquote><p>本质是引用变量只能调用其编译时类型具有的方法, 但是在运行方法时会优先执行它运行时类型里面的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>(<span class="hljs-type">double</span>)a;<br></code></pre></td></tr></table></figure><p>上述代码使用了强制类型转换符将a变量从int类型转换为double类型</p><p>使用强制类型转换时注意:</p><p>基本数据类型只能在整数型 字符型 浮点型之间进行相互转换, 布尔类型无法转换</p><p>引用类型的转换只能在具有继承关系的两个类型间进行</p><blockquote><p>将父类类型实例强制转换成子类类型时, 其运行时类型必须是子类类型, 否则会发生ClassCastException错误</p></blockquote><h1 id="强制转换符"><a href="#强制转换符" class="headerlink" title="强制转换符"></a>强制转换符</h1><p>(type)</p><p>强制转换符可以用于基本数据类型之间(除了boolean)</p><p>强制转换符用于对象时, 要求两个类型必须为继承关系</p><h1 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Father f1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br>Son s1=(Son)f1;<br><span class="hljs-comment">//上述代码会抛出java.lang.ClassCastException错误</span><br>Son s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>Father fs=(Father)s2;<br><span class="hljs-comment">//正确的多态实现</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br><span class="hljs-keyword">if</span> (f1 <span class="hljs-keyword">instanceof</span> Son) &#123;<br>    <span class="hljs-type">Son</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Son) f1;<br>&#125;<br><span class="hljs-comment">//可以用instanceof运算符来判断是否可以成功转换, 避免抛出ClassCastException错误</span><br><span class="hljs-comment">//上述if判断将为false, 不会执行代码块里面的内容</span><br></code></pre></td></tr></table></figure><p>instanceof运算符: 当前面的操作数是后面操作数的同一个类 子类 实现类的实例则返回true, 否则返回false</p><p>要求前面的操作数为实例&#x2F;对象, 后面的操作数为类</p><p>instanceof运算符一般与(type)强制转换符配合使用, 先用instanceof判断是否可以进行强制转换, 再用强制类型转换符进行转换, 保证代码的健壮性</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>在Java中继承和组合都能实现类的复用, 但是继承破坏了封装, 组合能实现更好的封装</p><p>在继承关系中, 子类可以直接访问父类的内部成员变量和方法 造成严重耦合 </p><p>为了保证封装性, 在设计父类时应该</p><ol><li>将所有成员变量用private修饰, 向子类隐藏, 避免子类可以直接访问父类成员变量</li><li>父类的内部方法应该使用private修饰, 如果需要被外部调用应该用public修饰, 不希望被子类重写的话需要使用final修饰符. 希望被重写但不希望被外部类访问可以用protected</li><li>避免在父类构造器中调用会被子类重写的方法</li></ol><p>用final修饰符修饰的类无法被其他类继承</p><p>也可以通过用private修饰类中所有的构造器, 保证无法被继承</p><p>一般需要用到子类的情形:</p><p>需要增加子类特有的属性或方法</p><blockquote><p>继承与组合所需要的系统开销本质上没有区别</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beat</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span>&#123;<br>        beat();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Bird b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>        b.breath;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>继承代码示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beat</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span>&#123;<br>        beat();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>&#123;<br>    <span class="hljs-comment">//将父类手动组合到子类中, 实际上它们没有继承动作</span><br>    <span class="hljs-keyword">private</span> Animal a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bird</span><span class="hljs-params">(Animal a)</span>&#123;<br>        <span class="hljs-built_in">this</span>.a=a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span>&#123;<br>        a.breath();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Animal a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        Bird b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>(a);<br>        <span class="hljs-comment">//由于自定义了构造器, 此时必须将Animal类型对象传入才可以创建Bird对象</span><br><span class="hljs-comment">//        Bird b=new Bird();</span><br>        b.breath();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上述代码中Bird类和Animal类是组合关系</p></blockquote><p>虽然继承和组合可以实现相同的功能, 但是实质上它们表达了不同的概念</p><blockquote><p>继承:is a(子类是一种特殊的父类)</p><p>组成:has a(部分组成整体)</p></blockquote><h1 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h1><p>类的四种组成成员: 成员变量 方法 构造器 初始化块</p><p>(都可以有多个, 也可以没有)</p><p>一个类中的多个初始化块会按照先后顺序执行</p><p>初始化块里面可以包含任何执行语句</p><p>初始化块如果被static修饰, 则称为静态初始化块</p><p>初始化块不能有标识符来标记,因此初始化块无法被调用, 对于类外界来说是隐形的</p><p>初始化块在创建对象时会隐式执行, 并且在构造器之前执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;&#125;<br>    &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的Person类包含两个初始化块</p><p>一个静态初始化块和一个非静态初始化块</p><p>**在Java中创建一个对象时, 系统会首先为该对象的所有实例变量(非成员变量)分配内存</p><p>接着开始执行初始化</p><p>Java中对象初始化步骤执行顺序是:</p><ol><li>声明实例变量时指定的初始化值进行赋值或者执行初始化块 由于它们是相同的优先级, 所以执行顺序要看在代码中的先后顺序</li><li>最后再执行构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span>&#123;<br>    <span class="hljs-comment">//第一步执行</span><br>    <span class="hljs-type">int</span> age=<span class="hljs-number">18</span>;<br>    &#123;<br>        <span class="hljs-comment">//第二步执行 同优先级看先后顺序</span><br>        age=<span class="hljs-number">19</span>;<br>    &#125;<br>    Girl()&#123;<br>        <span class="hljs-comment">//第三步执行</span><br>        age=<span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>初始化块与构造器的不同之处:</strong></p><ol><li>执行顺序的不同</li><li>初始化块可以有多个,每次创建对象都必须执行所有的构造器</li><li>构造器可以有多个, 但是创建对象时候只会执行被调用的构造器</li></ol><p>可以将多个构造器中的相同代码提取到初始化块中,</p><p>可以有效提高代码复用性, 程序的维护性</p><blockquote><p>普通初始化块会按照继承关系, 从Java.lang.Object类开始从上到下执行,</p><p>从上到下执行时, 会执行java.lang.Object的普通初始化块和构造器, 再到下一个间接父类的初始化块和构造器</p></blockquote><blockquote><p>初始化块在经过编译后会加到每个构造器的执行块代码前面, 所以本质上初始化块是构造器的补充</p></blockquote><h1 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h1><p>static修饰的初始化块称为静态初始化块</p><p>静态初始化块在类初始化时就会执行, 通常用于对类变量进行初始化, 不能对实例变量进行初始化处理</p><p>static初始化块属于类的静态成员, 类的静态成员不能访问非静态成员</p><blockquote><p>注意构造器是不能被静态修饰符修饰的, 因此静态初始化块可以在类初始化时执行, 但是构造器不能</p></blockquote><p>只有类初始化完成后, 程序才能开始使用这个类</p><blockquote><p>疑问: 当父类中自定义了构造器, 不提供无参构造器时, 子类会如何调用父类的构造器</p><p>会报错, 必须提供无参构造器才能被子类继承</p></blockquote><p><strong>类的初始化</strong></p><p>仅当对象第一次被创建时候, 会执行类的初始化(执行静态初始化块)</p><p>当类初始化过一次后, 该类会一直保留在jvm中直到程序结束, 所以后面再次创建对象时无须再对该类进行初始化</p><blockquote><p>继承和组合都是属于Java提供的类复用机制</p></blockquote><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>Java中的8个基本类型都有对应的包装类</p><blockquote><p>8种基本数据类型: byte short char int long float double boolean</p></blockquote><p>包装类可以将基本数据类型的值转换成对象使用</p><p>并且JDK1.5提供了自动装箱和自动拆箱的功能</p><p>允许同类型的包装类对象和基本类型变量间可以直接赋值</p><p><strong>final关键字类似于C++中的const, 被final修饰符修饰的变量 方法 类 将不允许再发生修改</strong></p><p>通过final关键字可以实现不可变类, 使系统安全性加强</p><p>abstract用于定义抽象类</p><p>interface用于定义接口</p><p>抽象类主要是用作多个类的模板</p><p>接口用于定义多个类应该遵循的规范</p><p>java8更新了Lambda表达式</p><p>enum关键字用于创建枚举类</p><p>枚举类是一种不能自由创建对象的类, 适合用于实例有限并且已经确定的类 如: 行星 季节</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>除了int和char的对应包装类为其单词全写外, 其他包装类都是首字母大小即可</p><p>在Java1.5提供自动装箱(Autoboxing)和自动拆箱(AutoUnboxing)之前必须使用包装类中的valueOf()和xxxValue()方法来实现基本数据类型和包装类对象的相互转换</p><p>如图:</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220506173943789.png" alt="image-20220506173943789"></p><p>在包装类中, 还提供了将字符串和其他基本类型进行相互转换的方法</p><ol><li>parseXxx(String s) :除了Character类的所有包装类都提供该方法</li><li>valueOf(String s)</li></ol><p>将基本类型变量与””空字符串进行拼接操作, 会自动将基本类型变量转换为字符串, 更方便</p><blockquote><p>包装类作为引用变量可以直接与基本类型变量进行比较(发生了自动拆箱)</p><p>两个包装类对象引用变量进行比较时, 只有两个引用变量是指向同一个对象时才会返回true</p></blockquote><p>JDK1.5后的自动装箱有缓存机制, -128~127之间的整数装箱成Integer实例后将存储到一个cache数组中, 第二次使用时将直接从cache数组中取出不再重复创建</p><p>所以-128~127自动装箱创建的实例进行相等比较将返回true</p><blockquote><p>byte范围-128~127</p></blockquote><p><strong>为什么byte的范围是-128~127</strong></p><p>0000 0000</p><p>byte</p><p>00000000</p><p>符号位占一位 存储数值的位有7位</p><p>2^(8-1)-1</p><p>128-1&#x3D;127</p><blockquote><p>Java使用二进制补码来存储负数</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220507111215881.png" alt="image-20220507111215881"></p><p>正数和负数在计算机底层均以补码的形式存储</p><p>2*(9-1)-1&#x3D;255</p><p>255&#x3D;128+127</p><blockquote><p>-128以8位2进制表示: 1000 0000</p><p>1000 0000补码</p><p>0111 1111 +1</p><p>1000 0000</p><p>负数补码计算方式</p><p>正数的补码是其本身</p></blockquote><p>Java7中提供了包装类对象的比较方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.compare(Integer val1, Integer vla2)<br><br>Integer.compare(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//输出1</span><br>Integer.compare(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//输出-1</span><br>Integer.compare(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//输出0</span><br></code></pre></td></tr></table></figure><p>Java7中还为Character包装类增加了大量工具方法, 用于对字符进行判断</p><p>Java8为整数包装类提供了无符号运算方法</p><p>如:</p><p>static String toUnsignedString(int&#x2F;long i):</p><p>将int&#x2F;long整数转换为无符号整数对应的字符串</p><blockquote><p>这些方法好像有字符串拼接, 强制转换等替代方法可以实现相同的功能</p></blockquote><blockquote><p>注意将负数转换成无符号整数时, 不会是直接取其绝对值, 而是将其补码的符号位1作为数值位, 作为原码计算出对应的无符号整数 </p></blockquote><p>如8位byte存储的-3</p><p>原码: 1000 0011</p><p>补码: 1111 1100+1</p><p>1111 1101</p><p>其无符号整数为253</p><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object类是所有类的父类, 所以Object类中提供的方法会被所有类继承</p><p>Object类中提供了toString() 实例方法, 其返回值为”类名+@+hashCode”</p><p>在自定义类中可以重写toString()方法来实现自定义功能</p><blockquote><p>数组类重写了toString()方法, 可以将数组元素作为字符串输出</p></blockquote><p><strong>当&#x3D;&#x3D;运算符的操作数包含引用变量时, 必须是两个有父子关系的对象才能进行比较, 或者是相同类的对象</strong></p><blockquote><p>这里的父子关系不可以是间接父子关系, 必须是直接父子关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;her&quot;</span>;<br><span class="hljs-comment">//直接量 直接使用常量池管理, 将常量池中的对象给s1引用变量</span><br>String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;he&quot;</span>);<br><span class="hljs-comment">//先使用常量池管理对象, 再调用String类构造器创建新的String对象给s2引用变量</span><br><span class="hljs-comment">//new String(&quot;he&quot;)会产生两个对象</span><br></code></pre></td></tr></table></figure><p>上述代码使用了两种方式赋值给字符串变量</p><blockquote><p>常量池 (constant pool): 用于管理编译时已经创建并保存在类文件(.class)中的数据, 通常包括 常量(类 方法 接口中) 字符串常量</p></blockquote><p>用new String(“”)创建的字符串对象将保存在堆内存(运行时内存区), 但是常量池中的对象将在编译时就确定并保存, 不需要在运行时候再创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">1</span>==<span class="hljs-number">1.0</span>);<br><span class="hljs-comment">//输出ture</span><br>System.out.println(<span class="hljs-number">65</span>==<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-comment">//输出true</span><br></code></pre></td></tr></table></figure><p>Object类提供了equals()实例方法用于将两个对象进行比较 注意equals()方法的判断逻辑和要求与使用&#x3D;&#x3D;运算符进行两个对象的比较时是完全相同的</p><blockquote><p>实际上Object类提供的equals()仅仅对两个引用变量指向的对象内存地址进行比较, 地址相同就返回true</p></blockquote><blockquote><p>String类已经重写了equals()方法, 只要两个字符串的内容是相同的, 就返回true</p></blockquote><blockquote><p>instanceof运算符与equals方法不同, instanceof运算符的操作数为前面实例 后面类</p><p>equals为两个对象的比较</p></blockquote><p>equals方法重写一般要遵循下面的原则:</p><p>自反性: x.equals(x)一定返回true</p><p>对称性: 如果x.equals(y)为true, 则y.equals(x)一定为true</p><p>传递性: 对于x, y, z, 如果x.equals(y)为true, x.equals(z)为true, 则y.equals(z)为true</p><p>一致性:对于x ,y, 如果用于对比的信息没有改变, 那么x.equals(y)的结果不会发生改变</p><p>如果x不为null, x.equals(null)一定为false</p><h1 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h1><p>用static修饰的成员叫做类成员</p><p>Java中类有5种成员: 成员变量  方法 构造器 初始化块 内部类</p><p>内部类包括接口 枚举 </p><p>用static修饰的类成员属于整个类</p><p>非static成员属于单个实例&#x2F;对象, 为实例&#x2F;对象成员</p><p><strong>类成员变量存储在元空间中</strong></p><p><strong>实例成员变量存储在堆内存(运行时内存)中</strong></p><blockquote><p>在大部分的语言中都不允许通过对象来访问类变量, Java虽然可以通过对象来访问类变量, 但是不建议使用这个特性</p></blockquote><blockquote><p>规范的编程应该是只通过对象来访问实例成员</p><p>访问类成员只通过类来访问</p></blockquote><blockquote><p>在Java中null对象可以正常访问其所属的类成员</p><p>但是试图访问null对象的实例成员时, 将引发NullPointerException错误, 表示null对象实际上是不存在的</p></blockquote><h1 id="单例类-Singleton"><a href="#单例类-Singleton" class="headerlink" title="单例类(Singleton)"></a>单例类(Singleton)</h1><p>一个始终只能创建一个实例的类就是单例类</p><p>单例类通常的设计:</p><ol><li>将类的构造器都用private修饰起来, 防止被其他类调用</li><li>提供一个用public static修饰的类方法来创建对象</li><li>使用一个用private static修饰的成员变量来缓存上述方法创建的对象, 保证只有一个实例能够被创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-comment">//隐藏构造器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    提供类方法创建并缓存对象<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>            instance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码实现了一个单例类</p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>final关键字可用于修饰类 变量 方法</p><p>当变量用final修饰时, 该变量一旦被赋予了初始值, 则不能再被重新赋值</p><p>成员变量被final修饰时, 该变量不会被系统自动初始化赋值, 必须在特定位置进行显式指定初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num1=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//类变量可以在声明时赋值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num2;<br>    <span class="hljs-keyword">static</span>&#123;<br>        num2=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//类变量可以在静态初始化块赋值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num5=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//实例变量可以在声明时赋值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num3;<br>    &#123;<br>        num3=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//实例变量可以在非静态初始化块赋值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num4;<br>    TestClass()&#123;<br>        num4=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//实例变量还可以在构造器中进行初始化赋值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码展示了final类变量的两个赋值地点, final实例变量的三个赋值地点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num5;<br>    &#123;<br><span class="hljs-comment">//    System.out.println(num5);</span><br>        test();<br>        num5=<span class="hljs-number">6</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(num5);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>();<br>        <span class="hljs-comment">//将输出0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码显示了final成员变量可以在初始化被方法访问, 并且输出0, 这是Java的设计缺陷</p><p><strong>final局部变量</strong></p><p>final局部变量只能进行一次赋值</p><p>final局部变量作为形参时, 会在值传递时被系统赋值, 不能再次赋值</p><p><strong>final基本类型变量和final引用变量的区别</strong></p><p>final基本类型变量只能进行一次赋值</p><p>final修饰引用变量时, 该引用变量所指向的对象地址无法再次改变, 也就是说无法重新指向其他的对象. </p><p>但是注意引用变量指向的对象本身是不受final修饰符影响, 可以正常修改</p><p>当一个变量满足三个条件时, 其相当于一个直接量, 成为宏变量</p><ol><li>被final修饰</li><li>声明时指定了初始值</li><li>初始值在编译时就被确定</li></ol><p>宏变量在代码中出现的地方会被编译器直接替换成对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner2</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test43</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        Outer.Inner inner= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() ;<br>        Outer.Inner inner0= out.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() ;<br>        Outer.<span class="hljs-type">Inner2</span> <span class="hljs-variable">inner2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>final方法</strong></p><p>当父类中的方法用final修饰时, 子类不能重写该方法</p><p>与private的隐藏不同, final修饰的方法如果被子类重写将造成编译错误</p><p>但是如果方法同时被final 和 private修饰时, 方法对于子类来说将是隐藏状态, 不再是方法重写而是定义了新的方法, 可以正常运行</p><p>final不会影响方法重载</p><p><strong>final类</strong></p><p>final修饰的类将不可被继承</p><h1 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h1><p>Java的八种基本数据类型对应的包装类和java.lang.String类都属于不可变类</p><p>不可变类的实例创建后不能改变其实例变量</p><p>自定义不可变类应该遵循下列规则:</p><ol><li><p>成员变量用private 和 final修饰</p></li><li><p>提供带参构造器来根据参数初始化成员变量</p></li><li><p>提供getter方法, 不提供setter方法, 因为final成员变量不能二次修改</p></li><li><p>必要时需要重写hashCode()和equals()方法</p><blockquote><p>java.lang.String类已经重写了hashCode()和equals()方法</p></blockquote></li></ol><p>JavaBean是可变类的代表, 可变类的实例变量都是可变的</p><p><strong>可以使用数组来实现缓存实例的不可变类</strong></p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220509142526572.png" alt="image-20220509142526572"></p><p>使用数组来实现实例的缓存池, 当缓存池满时, 采用先进先出的队列规则来移出旧对象</p><p>缓存实例的不可变类通常会提供valueOf()方法来获取缓存池中的实例</p><blockquote><p>java.lang.Integer类也提供valueOf()方法来从缓存池中获取实例</p></blockquote><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>为什么需要设计抽象类：因为多态实现的父类类型 引用变量虽然是指向子类对象， 但是无法通过该引用变量调用父类中没有， 但是子类中有的方法。 抽象类可以设计出无方法体， 仅有方法名的类模板可以解决该方法</p><p>抽象类提供了子类的通用方法，并将方法执行体留给子类实现 </p><p>抽象类是模板模式的一种实现</p><p>抽象方法和抽象类必须使用abstract修饰</p><p>一个类中含有抽象方法, 则该类必须为抽象类</p><p>但是用abstract修饰的抽象类可以不含抽象方法</p><p><strong>抽象类不能实例化，只能被子类继承</strong></p><p>抽象方法和抽象类的规则:</p><ol><li><p>抽象方法和抽象类必须使用abstract修饰, 抽象方法不能有方法体(具体代码块)</p></li><li><p>抽象类不能被实例化, 意味着它的构造器无法被new 关键字调用来创建实例</p></li><li><p>抽象类可以包含普通类中的五种成分: 成员变量 方法 构造器 初始化块 内部类(接口, 枚举)</p><blockquote><p>抽象类的构造器不能创建实例, 但是可以被子类调用(在子类创建实例时, 会按照继承树的顺序调用父类和间接父类中的构造器和初始化块)</p></blockquote></li><li><p><strong>含有抽象方法的类必须被abstract修饰</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>abstract和static不能修饰同一个方法， 但是可以修饰同一个内部类</p><p>abstract和private也不能修饰同一个方法</p></blockquote><h1 id="接口（interface"><a href="#接口（interface" class="headerlink" title="接口（interface)"></a>接口（interface)</h1><p>接口是一种特殊的抽象类</p><p>Java9允许在接口中自定义默认方法、类方法、私有方法</p><p>接口不提供任何实现的方法，只定义行为规范（一组公用的方法）</p><p>体现了规范与实现分离的设计规则</p><p>采用接口可以让程序有更好的扩展性和可维护性</p><p>接口使用interface代替class声明</p><p><strong>接口是一种特殊的抽象类， 所以接口本质是一种特殊的类</strong></p><ol><li>接口可以用的修饰符跟外部类一样，只能用public或者省略为默认权限</li><li>接口的命名与类名遵循相同的规则</li><li><strong>接口可以有多个直接父接口， 但是接口与类之间不能有继承关系</strong></li></ol><p>接口里面只有三种成员： 成员变量（只有静态常量final static) 方法（抽象实例方法、类方法、默认方法、私有方法） 内部类（内部接口、枚举）</p><p>不能含有构造器、初始化块</p><blockquote><p>注意普通的类可以包含内部接口</p></blockquote><p>接口的成员都只能用public权限， 可以省略public修饰符（除了私有方法）</p><blockquote><p>Java9中增加了私有方法的支持， 使用private修饰符可以声明私有方法，private static声明私有类方法 </p></blockquote><blockquote><p>私有方法通常作为工具方法被接口中的其他方法调用</p></blockquote><p>接口中的变量只有公开静态常量, 所以可以省略 public static final修饰符</p><p>接口中的普通方法不能有方法体实现， 但是类方法 默认方法 私有方法都必须有方法体实现</p><p><strong>Java8增加了支持接口定义默认方法和类方法</strong></p><blockquote><p>Java8支持接口定义默认方法, 默认方法可以有多个, 默认方法必须用default修饰, default不可省略</p><p>并且总是被public修饰, public可以省略</p><p>不可被static修饰</p></blockquote><p><strong>注意public default修饰符不可以在class类中修饰方法, 只可以用于接口中的默认方法</strong></p><p>默认方法为实例方法, 所以只能通过子类的对象来调用</p><p>类方法必须用static修饰, 并且默认被public修饰, 可以直接使用接口来调用类方法</p><p>接口中的抽象方法不允许有方法体(花括号), 但是默认方法 类方法 私有方法(Java9中添加)都必须有方法体(花括号)</p><p><strong>接口是一种特殊的类, 因此接口类不可以与普通类同名, Java源代码文件名必须与public接口同名</strong></p><p><strong>接口支持多继承, Java中的普通类只支持单继承</strong></p><p>意味着一个接口可以有多个直接父接口</p><p>接口继承时, 将会获得子接口中的所有抽象方法 类方法 默认方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InterfaceA</span>, InterfaceB&#123;&#125;<br></code></pre></td></tr></table></figure><p>上述代码的InterfaceC同时继承了InterfaceA和InterfaceB</p><p>接口可以作为多态中的父类类型</p><p>接口主要用于:</p><ol><li>定义变量</li><li>调用其他接口中的常量</li><li>被其他类实现</li></ol><p>普通类继承接口必须使用implements(实现)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span>, InterfaceB<br></code></pre></td></tr></table></figure><p>一个类只能有一个父类, 但是可以同时实现多个接口</p><blockquote><p>被称为Java的模拟多继承</p></blockquote><p><strong>注意当类implements接口时. 需要实现接口中的所有抽象方法, 如果有抽象方法未实现时, 该类必须为抽象类</strong></p><p><strong>接口相当于一个彻底抽象的抽象类(只有抽象方法, 私有方法对子类隐藏)</strong></p><blockquote><p>由于接口可以被继承的方法都是public, 所以子类实现接口方法时也只能用public修饰符</p><p>public修饰符是权限最大的修饰符</p></blockquote><p>Object类是接口类的唯一间接父类</p><p>可以用向上转型将接口类型引用变量赋予Object类型引用变量</p><h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><p>接口和抽象类的相同特征:</p><ol><li>都不能被实例化, 只能被实现或继承</li><li>都可以包含抽象方法, 普通类不能含有抽象方法, 必须将继承的抽象方法实现</li></ol><p>接口和抽象类的设计目的差别巨大:</p><ol><li>接口体现规范标准, 接口的改变将可能导致实现该接口的类都需要重写</li><li>抽象类体现模板式设计, 抽象类只是一个中间产品, 需要进一步完善实现</li></ol><p>接口和抽象类的用法有差异:</p><ol><li><p>抽象类可以有普通方法(包含方法体), 但是接口不能有</p></li><li><p>接口只能有static final变量 (类常量), 抽象类可以定义普通成员变量</p></li><li><p>接口不能有构造器和初始化块, 抽象类可以有构造器和初始化块 </p><blockquote><p>抽象类中的构造器和初始化块是提供给子类调用的</p></blockquote></li><li><p>普通类继承抽象类为单继承, 但是可以实现implement多个接口(模拟多继承)</p></li></ol><h1 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h1><p>接口是一种规范与实现分离的设计</p><blockquote><p>利用接口可以降低程序模块间的耦合性,提高系统可扩展性和可维护性</p></blockquote><blockquote><p>简单工厂(Factory)模式和命令模式都是遵循了面向接口编程思想的设计模式</p></blockquote><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类也被称为嵌套类, 它放在另一个类内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>    <span class="hljs-comment">//定义了一个非static内部类Inner</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInner</span>&#123;&#125;<br>    <span class="hljs-comment">//定义了一个static内部类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内部类特点:</p><ol><li>内部类可以提供更好的封装</li><li>内部类可以访问外部类私有(private)成员, 因为内部类本身被视为private成员的一部分, 但是外部类无法访问内部类的成员</li><li>特殊内部类: 匿名内部类适合用于仅需要创建一次类的用途</li><li>外部类不能用的修饰符private protected static可以用于内部类</li><li>只有static修饰的内部类才能有static成员</li></ol><blockquote><p>注意在一个源文件里可以定义多个外部类, 它们都是相互独立的</p></blockquote><p>外部类的上级单元是包</p><p><strong>外部类只有两个不同的作用域: 同一个包内, 任何位置 分别对应default(包权限)和public(任何位置)权限</strong></p><blockquote><p>同一个包内的不同源文件属于同一个作用域</p></blockquote><p>内部类有4个作用域, public(任何位置) protected (父子类) default(同一个包) private(同一个类)</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220510153945868.png" alt="image-20220510153945868"></p><p>static内部类可以包含非static成员, 但是static成员不能访问非static成员</p><blockquote><p>外部类不能被static修饰</p></blockquote><blockquote><p>接口也可以定义内部接口, 但是一般开发中不需要用到内部接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner2</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test43</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        Outer.Inner inner= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() ;<br>        <span class="hljs-comment">//创建外部类对象来创建非static内部类对象</span><br>        Outer.Inner inner0= out.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() ;<br>        <span class="hljs-comment">//调用已存在外部类对象来创建非static内部类对象</span><br>        Outer.<span class="hljs-type">Inner2</span> <span class="hljs-variable">inner2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner2();<br>        <span class="hljs-comment">//直接通过外部类来创建static内部类对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内部类的调用必须在前面加上其外部类的前缀</strong></p><p><strong>创建内部类对象前必须先创建外部类对象</strong></p><p><strong>非static内部类的构造器必须由外部类对象来调用</strong></p><blockquote><p>意味着</p><ol><li>非static内部类创建对象需要先创建&#x2F;存在有外部类对象</li><li>非static内部类被继承的子类创建对象时也需要由外部类对象来调用</li></ol></blockquote><blockquote><p>在方法中定义的类为局部(方法)内部类, 实际开发中很少用到</p></blockquote><blockquote><p>扩展: 局部(方法内)变量</p></blockquote><blockquote><p>由于同一个类中的多个局部内部类可以同名,所以javac会将局部内部类的class文件命名时加上数值</p><p>OuterClass$NInnerClass.class</p></blockquote><p><strong>多态就是指调用相同名字的方法会表现出不同的行为</strong></p><p>Java中有两种类型的多态: 编译时多态(static)(静态和运行时多态(no-static)(动态)</p><p>编译时多态: 方法重载</p><p>运行时多态: 方法重写</p><blockquote><p>? 运算符多态不确定</p></blockquote><blockquote><p>Polymorphism is the ability to process objects differently on the basis of their class and data types</p></blockquote><p>面向对象编程(OOP) :Object-oriented programming </p><p>在Java中多态有三种类型的实现方式:</p><ol><li><p>方法重写(override) 子类重写超类的同名方法</p></li><li><p>方法重载(overload) 同名不同参数列表的方法 </p></li><li><p>运算符重载 同一种运算符会因为操作数类型不同导致运算方式不同</p><blockquote><p>例如+运算符不仅用于加法运算, 还可以用于字符串拼接 </p><p>运算符 &amp; | !可以用于逻辑运算和按位运算</p></blockquote></li></ol><p><strong>面向对象的四个基本概念: 封装 继承 多态 抽象</strong></p><p>面向对象的三个基本特征: 封装 继承 多态</p><p>encapsulation inheritance polymorphism</p><p>继承(inherit)与派生(derive)是同一现象的不同方向</p><p>抽象 abstract</p><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类没有类名, 直接用花括号声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-comment">//内部类Inner</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>    &#123;<br>        <span class="hljs-comment">//初始化块</span><br>    &#125;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//静态初始化块</span><br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//创建匿名内部类实例</span><br>        Outer out=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>() &#123;<br>            <span class="hljs-comment">//匿名内部类的类体</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意不要将初始化块跟匿名内部类弄混</p></blockquote><blockquote><p>抽象类中可以没有抽象方法, 但是有抽象方法的类一定是抽象类</p></blockquote><ol><li>匿名内部类一定是非抽象类</li><li>匿名内部类只能用系统默认提供的构造器或者从父类中继承的自定义构造器, 但是可以自定义初始化块</li></ol><p>匿名内部类必须在定义时实现一个接口或者继承父类, 而且只能实现或继承一次</p><p><strong>匿名内部类通常用于定义一个一次性使用的类</strong></p><p>匿名内部类只能创建一个对象</p><blockquote><p>类似于单例类(Singleton)</p><p>但是单例类可以重复使用, 匿名内部类只能使用一次, 由于没有类名所以无法再次调用匿名内部类</p></blockquote><p><strong>匿名内部类会继承父类中的有参构造器</strong></p><p>**普通的子类只会调用父类中的无参构造器</p><p><strong>匿名内部类必须实现继承的所有的抽象方法, 也可以重写普通方法</strong></p><p>匿名内部类访问的局部变量必须被final修饰</p><p>Java8提供了effectively final功能, 会自动将匿名内部类访问的局部变量用final修饰</p><blockquote><p>意味着匿名内部类可以访问没有被显式final修饰的局部变量, 但是一旦访问该局部变量会被系统自动用final修饰</p></blockquote><p>匿名内部类无法访问已经被指定初始值的局部变量, 因为该变量已无法被自动用final修饰</p><h1 id="Lambda-闭包"><a href="#Lambda-闭包" class="headerlink" title="Lambda(闭包)"></a>Lambda(闭包)</h1><p><strong>Lambda表达式是Java中的函数式编程特性</strong></p><blockquote><p>函数式编程是指将函数作为基本运算单位, 意味着函数可以作为变量来使用(接收函数, 返回函数)</p></blockquote><p>Lambda是Java8的一个重大更新</p><p>Lambda表达式相当于创建了一个匿名方法</p><p>Lambda只能用来实现单方法接口的实例化(一个接口中只有一个方法)</p><p>lambda表达式的有点:</p><ol><li>可以简化匿名内部类的代码, 减少生成内部类文件</li><li>将函数作为变量传递, 为Java提供了函数式编程的支持</li></ol><p>lambda可以用于替代匿名内部类对象</p><blockquote><p>只有一个抽象方法的接口被称为函数式接口</p></blockquote><p>lambda表达式允许将代码块作为实参传给一个方法</p><p>Lambda表达式有三部分:</p><ol><li><p>形参列表</p></li><li><p>箭头(-&gt;) </p></li><li><p>代码块</p><p>**代码块必须包含return语句)</p><blockquote><p>当lambda表达式的代码块只有一条语句时, 会将该语句返回值自动return</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;<br><span class="hljs-comment">//    void test();</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test15</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Hello h=(num)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;;<br>    &#125;<br>    <span class="hljs-comment">//省略写法, 也是语法正确的</span><br>    Hello h=num -&gt; System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">//注意当没有形参时, 不可以省略圆括号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码用lambda实现了一个接口的实例化</p><p><strong>Lambda表达式所创建的对象的目标类型(target type)为函数式接口( functional interface)</strong></p><p>函数式接口: 一个接口只能有一个抽象方法, 但是可以包含多个默认方法 类方法 私有方法</p><blockquote><p>Java8中为函数式接口提供了注解@FunctionalInterface</p><p>该注解放在接口声明之前, 用于提示编译器检查该接口必须是函数式接口, 如果不是的话会造成编程报错</p></blockquote><p>Lambda表达式的限制条件:</p><ol><li>目标必须是函数式接口类型</li><li>一个Lambda表达式只能实现一个方法, 只能为函数式接口创建对象</li><li>Lambda表达式的形参列表必须与该函数</li></ol><p>常见使用场景:</p><ol><li><p>将lambda表达式赋值给函数接口类型的变量</p></li><li><p>将lambda作为函数式接口类型的参数传给一个方法</p></li><li><p>将lambda表达式进行强制转换为函数接口类型后再使用</p><blockquote><p>如传给Object类型引用变量</p></blockquote></li></ol><p>Java8在java.util.function包中提供了大量预定义的函数接口</p><p>4类典型的接口:</p><ol><li>XxxFunction</li><li>XxxConsumer</li><li>XxxPredicate</li><li>XxxSupplier</li></ol><h2 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h2><p>lambda表达式有更加简洁的写法</p><table><thead><tr><th>种类</th><th>示例</th><th>对应的表达式</th><th>说明</th></tr></thead><tbody><tr><td>类方法</td><td>类名::类方法</td><td>() -&gt; class.staticMethod()</td><td></td></tr><tr><td>实例方法</td><td>对象::实例方法</td><td>() -&gt; 对象.noStaticMethod()</td><td></td></tr><tr><td></td><td>类名::实例方法</td><td>(b,….) -&gt; a.noStaticMethod(b,…)</td><td></td></tr><tr><td>引用构造器</td><td>类名::new</td><td>() -&gt; new Class()</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello2</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">helloHo</span><span class="hljs-params">(Ho a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ho</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Ho</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> i1)</span> &#123;&#125;<br><br>    Ho() &#123;&#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;&#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticHello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test16</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Ho</span> <span class="hljs-variable">ho</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ho</span>();<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> (a, b) -&gt; Ho.staticHello(a, b);<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h6</span> <span class="hljs-operator">=</span> Ho::staticHello;<br>        <span class="hljs-comment">//类方法</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h3</span> <span class="hljs-operator">=</span> (a, b) -&gt; ho.hello(a, b);<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h7</span> <span class="hljs-operator">=</span> ho::hello;<br>        <span class="hljs-comment">//特定对象的实例方法</span><br>        Hello2 h8=(a,b,c)-&gt;a.hello(b,c);<br>        Hello2 h9=Ho::hello;<br>        <span class="hljs-comment">//某类对象的实例方法</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h4</span> <span class="hljs-operator">=</span> (a, b) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ho</span>(a, b);<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h5</span> <span class="hljs-operator">=</span> Ho::<span class="hljs-keyword">new</span>;<br>        <span class="hljs-comment">//引用构造器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>lambda和匿名内部类有相同之处:</p><ol><li>两者都可以直接访问接口中默认被final修饰的变量</li><li>两者对应的实例都可以调用接口中继承的默认方法</li></ol><p>两者的区别:</p><ol><li>匿名内部类可以为任何接口 抽象类 普通类创建实例, lambda表达式只能创建函数接口的实例</li><li>匿名内部类的代码块可以调用接口的默认方法, lambda表达式的代码块不能调用默认方法</li></ol><p>在Arrays类中的有些类方法需要Comparator, XxxOperator, XxxFunction等函数接口的实例, 可以用lambda表达式来实现, 使代码更简洁</p><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>枚举类是指实例固定并且数量有限的类</p><p>JDK1.5增加了对枚举类的支持</p><p>1.5之前可以手动设计一个类实现枚举</p><p>可以按照一下规则来设计枚举类</p><ol><li>用private修饰构造器, 使其无法用new关键字调用创建实例</li><li>将该类的所有实例都用public static final修饰的类常量来保存</li><li>提供static方法来给外部获取匹配实例</li></ol><p>由于自定义枚举类的代码量较大, Java5中新增了enum关键字来声明枚举类, 提高开发效率</p><blockquote><p>enum的地位与class interface相同</p></blockquote><p><strong>enum枚举类是一种特殊的类</strong></p><p><strong>一个java源文件只能有一个被public修饰的类或枚举类或接口, 并且源文件名应该与类名或枚举类名或接口名相同</strong></p><p>枚举类和普通类的区别:</p><ol><li><p>枚举类可以实现多个接口, 但是不能继承其他父类</p><blockquote><p>因为枚举类默认继承了Java.lang.Enum类,并非Object类</p></blockquote></li><li></li></ol><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>StringBuilder类是具有缓冲能力的字符串处理类</p><p>特点: 长度和内容都是可变的</p><p>常用方法:</p><p>append</p><p>insert</p><p>setCharAt</p><p>replace</p><p>deleteChatAt</p><p>delete</p><p>capacity</p><p>length</p><p>reverse</p><p>indexOf</p><p>lastIndexOf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;a1234a&quot;</span>);<br>      <span class="hljs-comment">//创建一个内容为a1234a的StringBuilder对象</span><br>      System.out.println(sb);<br>      sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>      <span class="hljs-comment">//将另一个字符串,或者基本数据类型加入到原字符串的末尾</span><br>      System.out.println(sb);<br>      sb.insert(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br>      <span class="hljs-comment">//在index位置插入字符串或基本数据类型数值, 原来位置的字符向后移</span><br>      System.out.println(sb);<br>      sb.setCharAt(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br>      <span class="hljs-comment">//将index所在位置的字符替换为字符串或基本数据类型</span><br>      System.out.println(sb);<br>      sb.replace(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;d&quot;</span>);<br>      <span class="hljs-comment">//先删除startIndex到EndIndex-1的内容</span><br>      <span class="hljs-comment">//然后插入子字符串</span><br>      System.out.println(sb);<br>      sb.deleteCharAt(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//删除字符串中index对应字符</span><br>      System.out.println(sb);<br>      sb.delete(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>      <span class="hljs-comment">//删除startIndex到EndIndex-1的内容</span><br>      System.out.println(sb);<br>      System.out.println(sb.capacity());<br>      <span class="hljs-comment">//输出sb底层char[]数组的长度</span><br>      System.out.println(sb.length());<br>      <span class="hljs-comment">//输出内容字符长度</span><br>      System.out.println(sb.reverse());<br>      <span class="hljs-comment">//将字符串反转</span><br>      System.out.println(sb.indexOf(<span class="hljs-string">&quot;a&quot;</span>));<br>      <span class="hljs-comment">//输出第一个匹配到的字符串的第一个字符所在index</span><br>      sb.append(<span class="hljs-string">&#x27;a&#x27;</span>);<br>      System.out.println(sb);<br>      System.out.println(sb.lastIndexOf(<span class="hljs-string">&quot;aa&quot;</span>));<br>      <span class="hljs-comment">//输出第二个匹配到的字符串的第一个字符所在index</span><br></code></pre></td></tr></table></figure><p><strong>注意StringBuffer中也有跟StringBuilder相同功能的同名方法</strong></p><p><strong>StringBuffer和StringBuilder的方法会操作对象本身, 但是String中的方法不会操作对象, 而是返回一个新的String类对象</strong></p><p><strong>StringBuffer和StringBuilder两个属性length和capacity, 都是可变的, capacity代表对象的底层存储数组的长度(容量) 通常比length大, 而且该属性由系统自动操作, 程序无须关心</strong></p><p>可以用length()和setLength(int len)方法来获取长度或修改长度</p><p>String对象没有capacity属性, 只有length属性</p><p><strong>Java中有三种类来封装字符串: String StringBuffer StringBuilder</strong></p><p>区别: String类是固定的, 一旦创建不可再次改变</p><p>StringBuffer和StringBuilder类类似, 两个类都是可变的, 并且两者的方法和构造器基本相同, 但是只有StringBuffer是线程安全</p><p>StringBuffer类可以通过toString()方法转换成对应的String对象</p><p>StringBuilder的性能较高</p><p>创建一个内容可变的字符串对象时, 应该优先考虑使用StringBuilder</p><blockquote><p> Java中有CharSequence接口, 该接口被字符串的三种类都实现了, 可以视为Java中的字符串通用接口</p></blockquote><p>Java8中, 三个类都是使用char[]数组来存储字符串, 因此字符串中的每个字符占两个字节大小</p><p>Java9改进了三个类, 使用byte[]数组和encoding-flag字段来存储字符, 使得每个字符只占一个字节, 节省了内存空间</p><p>但是改进不会影响三个类的功能方法的使用</p><h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p>String类有大量构造器来创建对象</p><p>常用的构造器有:</p><p>String() 返回一个0长度的对象</p><p>String(String original) 用字符串直接量创建对象</p><p>String(StringBuffer buffer) 将StringBuffer类对象转换成String对象</p><p>String(StringBuilder bulder) 将StringBuilder类对象转换成String对象</p><p>String类的20种方法的使用示例: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;11123&quot;</span>;<br>        String str3=<span class="hljs-string">&quot;abc&quot;</span>;<br>        String str4=<span class="hljs-string">&quot;ABC&quot;</span>;<br><span class="hljs-comment">//        boolean flag = str3.isEmpty();</span><br><span class="hljs-comment">//        str.indexOf(&quot;23&quot;)</span><br>        System.out.println(str.indexOf(<span class="hljs-string">&quot;213&quot;</span>));<br>        <span class="hljs-comment">//返回第一个匹配到的字符串的第一个字符所在index</span><br>        <span class="hljs-comment">//不匹配返回-1</span><br>        System.out.println(str.charAt(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//返回index对应的字符</span><br>        String str2=str.concat(<span class="hljs-string">&quot;456&quot;</span>);<br>        <span class="hljs-comment">//进行字符串拼接,等同于+操作</span><br>        System.out.println(str2.contains(<span class="hljs-string">&quot;56&quot;</span>));<br>        <span class="hljs-comment">//判断是否包含另一个字符串</span><br>        System.out.println(str3.equals(str4));<br>        <span class="hljs-comment">//判断字符串内容是否相等</span><br>        System.out.println(str3.equalsIgnoreCase(str4));<br>        <span class="hljs-comment">//判断字符串内容是否相等, 忽略字母大小写的区别</span><br>        System.out.println(str3.startsWith(<span class="hljs-string">&quot;a&quot;</span>));<br>        <span class="hljs-comment">//判断字符串的开头是否是另一个字符串</span><br>        <span class="hljs-comment">//String str3=&quot;abc&quot;;</span><br>        System.out.println(str3.endsWith(<span class="hljs-string">&quot;a&quot;</span>));<br>        <span class="hljs-comment">//判断字符串的末尾是否是另一个字符串</span><br>        System.out.println(Arrays.toString(str3.getBytes(StandardCharsets.UTF_8)));<br>        <span class="hljs-comment">//以数组形式返回字符串的每个字符在编码集中对应的数值</span><br>        System.out.println(Arrays.toString(str3.toCharArray()));<br>        <span class="hljs-comment">//返回字符串中的字符对应的char数组</span><br>        System.out.println(str3.isEmpty());<br>        <span class="hljs-comment">//判断字符串的内容是否为空</span><br>        String str5=<span class="hljs-string">&quot;  aab c   &quot;</span>;<br>        System.out.println(str5.trim());<br>        <span class="hljs-comment">//去除字符串开头和结尾的空格并返回</span><br>        <span class="hljs-comment">//注意不会修改字符串本身, 返回的是另一个新字符串</span><br>        System.out.println(Arrays.toString(str5.split(<span class="hljs-string">&quot; &quot;</span>)));<br>        <span class="hljs-comment">//以参数的字符串为分隔符, 将字符串分割并存储为char类型数组返回</span><br>        System.out.println(str5.equals(str5.substring(<span class="hljs-number">0</span>)));<br>        <span class="hljs-comment">//返回从index开始到结尾的子字符串</span><br>        System.out.println(str5.replace(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<br>        <span class="hljs-comment">//将字符串中所有的匹配字符串替换为另一个字符串</span><br>        System.out.println(str5.lastIndexOf(<span class="hljs-string">&#x27;a&#x27;</span>));<br>        <span class="hljs-comment">//返回字符串中最后一个匹配的字符所在的index</span><br>        str5.toUpperCase(Locale.ROOT);<br>        <span class="hljs-comment">//将字符串中的所有小写字母转换为大写</span><br>        str5.toLowerCase(Locale.ROOT);<br>        <span class="hljs-comment">//将字符串中所有的大写字母转换成小写</span><br>        System.out.println(String.valueOf(<span class="hljs-number">5</span>));<br>        <span class="hljs-comment">//将基本数据类型转换成字符串, 可以用空白字符串+基本数据类型代替</span><br>        <span class="hljs-comment">//注意该方法为类方法, 不是实例方法</span><br>        System.out.println(str5.intern());<br>        <span class="hljs-comment">//从常量池中取出对应的字符串对象返回, 如果不存在则在常量池中创建</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String a=<span class="hljs-string">&quot;1&quot;</span>;<br>String b=a+a+a+a+a+a;<br><span class="hljs-comment">//上述代码将中途产生4个临时对象, 使用StringBuilder或StringBuffer类可以避免产生临时对象</span><br></code></pre></td></tr></table></figure><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><p><strong>System代表当前运行的JVM本身, 程序不能创建System对象</strong></p><blockquote><p>System提供了类变量和类方法来给外部调用</p></blockquote><p><strong>Java提供了System类和Runtime类使程序可以与系统交互</strong></p><p>类成员: </p><p>System.in 标准输出</p><p>System.out 标准输出</p><p>System.error 异常输出</p><p>类方法可以访问环境变量和系统属性</p><blockquote><p>这里的标准和异常是指系统的信息状态</p></blockquote><p><strong>Java中如果需要调用C语言来方法操作系统底层硬件设备可以通过以下步骤实现:</strong></p><blockquote><ol><li>声明一个native修饰的方法, 只有方法签名没有方法实现</li><li>用Javac编译成class文件</li><li>用Javah编译成.h文件</li><li>在C语言的源代码中include .h文件并实现native修饰的方法</li><li>将C语言的源代码文件编译成动态链接库文件</li><li>在Java中用System.loadLibrary()或Runtime.loadLibrary()加载第五步的动态链接库文件, 该native方法就可以被调用了</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; env=System.getenv();<br>        <span class="hljs-comment">//将当前系统中的所有环境变量获取名称</span><br>        <span class="hljs-comment">//Map是java.util中的一个类</span><br>        <span class="hljs-keyword">for</span>(String name:env.keySet())&#123;<br>            System.out.println(name+<span class="hljs-string">&quot;--&quot;</span>+env.get(name));<br>        &#125;<br>        <span class="hljs-comment">//遍历所有的环境变量的值</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span>System.getProperties();<br>        <span class="hljs-comment">//Properties也是java.util中的一个类</span><br>        props.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;props.txt&quot;</span>),<span class="hljs-string">&quot;System pro&quot;</span>);<br>        <span class="hljs-comment">//FileOutPutStream是java.io中的类, 用于将信息存储到文件里</span><br>        <span class="hljs-comment">//默认路径为项目所在的根目录</span><br></code></pre></td></tr></table></figure><p>上述代码调用System.getenv方法来获取当前系统的环境变量, 并将获取到的数据存储到了文本文件中</p><p>System类中常用的方法有:</p><ol><li><strong>获取当前的系统环境变量</strong></li></ol><p>getenv() getProperties() getProperty(String name)</p><ol start="2"><li><strong>获取当前时间</strong></li></ol><p>currentTimeMills() nanoTime()</p><blockquote><p>返回的值为当前时间与1970年1月1日0:00的时间差, </p><p>currentTimeMills()以毫秒为单位, nanoTime()以纳秒为单位</p><p>并且不同操作系统的底层时间粒度不同, 所以导致返回值的精确会有差异</p><p>大部分操作系统以几十毫秒为时间测量单位, 所以很少用到nanoTime()</p></blockquote><ol start="3"><li><p>System.exit(0)</p><blockquote><p>关闭程序所在的JVM, 会导致JVM和上面运行的所有程序直接结束运行</p></blockquote></li><li><p>System.gc()</p><blockquote><p>主动调用垃圾回收</p></blockquote></li><li><p>setIn() setOut() setErr()</p><blockquote><p>改变系统的标准输入 标准输出 标准错误输出流</p></blockquote></li><li><p>arraycopy()</p><blockquote><p>复制的两个数组都必须已经初始化, 如果index超过数组长度将发生数组索引越界错误</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(System.currentTimeMillis());<br>      <span class="hljs-comment">//输出当前系统时间与1970年1月1日0:00的时间差, 以毫秒为单位</span><br>      System.gc();<br>      <span class="hljs-comment">//主动调用垃圾回收</span><br>      <span class="hljs-type">int</span>[] nums=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>      <span class="hljs-type">int</span>[] nums2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">6</span>];<br>      System.arraycopy(nums,<span class="hljs-number">2</span>,nums2,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>      System.out.println(Arrays.toString(nums2));<br>      <span class="hljs-comment">//必须是对两个已经初始化的数组进行操作</span><br>System.exit(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">//导致整个JVM停止运行</span><br></code></pre></td></tr></table></figure><h1 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h1><p>每个Java程序都有一个对应的Runtime实例</p><p>Runtime提供了实例方法来操作当前程序的运行时环境</p><blockquote><p>System类的操作会影响到整个JVM上面的程序</p></blockquote><p>常用的方法:</p><p>getRuntime() 获取当前程序对应的Runtime对象</p><p>gc()</p><blockquote><p>与system类中的方法功能类似</p></blockquote><p>runFinalization()</p><blockquote><p>与system类中的方法功能类似</p></blockquote><p>freeMemory()</p><p>获取空闲内存量</p><p>totalMemory()</p><p>获取总的内存量</p><p>exec(“notepad.exe”)</p><blockquote><p>运行操作系统中指定名称的程序</p><p>在Java9中提供了ProcessHandle接口和ProcessHandle.Info实现类来获取exec运行的进程信息</p></blockquote><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>Math是Java中的数学运算工具类, 提供了大量数学运算的方法</p><p>常见方法:</p><p>random()</p><blockquote><p>产生一个0.0到1.0范围的浮点数</p></blockquote><p>abs(int i)pow(int a,int b)max(int a,int b)min(int a,int b)round(double d) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Math.abs(-<span class="hljs-number">1</span>));<br>      <span class="hljs-comment">//绝对值</span><br>      System.out.println(Math.pow(<span class="hljs-number">3.0</span>, <span class="hljs-number">2.0</span>));<br>      <span class="hljs-comment">//求幂</span><br>      System.out.println(Math.max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>      <span class="hljs-comment">//返回最大值</span><br>      System.out.println(Math.min(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>      <span class="hljs-comment">//最小值</span><br>      System.out.println(Math.round(<span class="hljs-number">15.5</span>));<br>      <span class="hljs-comment">//将double小数四舍五入返回一个int数值</span><br></code></pre></td></tr></table></figure><h1 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h1><p>Random中提供了大量的实例方法用于产生随机数值</p><p>使用Random中的实例方法一般要先创建Random类的实例</p><p>Random类有两个构造器, 无参构造器用默认的种子(当前系统时间) 有参构造器需要传入一个long类型整数作为种子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Random random=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-comment">//调用无参构造器创建对象</span><br>Random random2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//调用有参构造器创建对象, 如果传入的seed相同, 则创建的随机数可以追溯</span><br>random.nextInt(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//产生一个0-~100的随机数</span><br></code></pre></td></tr></table></figure><p>Java7中提供了Random的增强类 ThreadLocalRandom</p><blockquote><p>两个类的功能类似, 但是ThreadLocalRandom提供了对多线程 高并发的支持 有更好的线程安全</p></blockquote><h1 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h1><p>UUID: Universally Unique Indentifier (通用唯一标识码)</p><p><strong>UUID用于生成36位的随机值, UUID值的重复概率非常低, 因此可以视为具有唯一性</strong></p><p>可以用于高并发的系统中, 作为数据的唯一索引</p><blockquote><p>UUID是根据当前系统时间, 网卡MAC地址再加上随机数(盐) 作为种子来产生UUID值, 可以视为具有很高的随机性</p></blockquote><h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><p>在Java中进行浮点数(float double)运算时会发生精度丢失,计算的结果不准确</p><blockquote><p>原因在于浮点数是将十进制小数转换为二进制存储, 转换过程中会发生数据丢失(精度丢失)</p></blockquote><p><strong>数据丢失的本质是由于部分十进制小数没有对应的二进制浮点数, 只能存储成无限接近的近似值(类似于分数中无限循环小数的概念)</strong></p><p>为了在十进制小数的存储和使用时避免精度丢失, Java提供了BigDecimal来进行十进制小数的存储和运算</p><blockquote><p>在BigDecimal中, 十进制浮点数并非直接转换成二进制浮点数进行存储, 所以可以避免产生数据丢失</p></blockquote><p>BigDeciaml提供了大量构造器来将浮点数存储为对象</p><p>BigDecimal(double val)</p><blockquote><p>不推荐使用该构造器, 推荐使用BigDecimal.valueOf(double val)类方法来创建对象</p></blockquote><p>BigDecimal(type val)</p><blockquote><p>将8种基本数据类型(除了Boolean) 转换成对应的BigDeciaml对象 </p></blockquote><p><strong>推荐使用BigDeciaml(String str)构造器来将小数对应的字符串转换</strong></p><p>常用方法(都是实例方法, 必须通过对象调用): 加减乘除 幂</p><p>add()subtract()mutiply()divide()pow()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">BigDecimal bd=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;10&quot;</span>);<br>BigDecimal bd2=BigDecimal.valueOf(<span class="hljs-number">2.2222</span>);<br>bd.add(bd2);<br><span class="hljs-comment">//将BigDecimal对象与另一个对象相加, 不会修改原对象, 直接返回结果对象</span><br>bd.subtract(bd2);<br><span class="hljs-comment">//将两个对象相减并返回结果</span><br>bd.multiply(bd2);<br><span class="hljs-comment">//将两个对象相乘并返回结果</span><br>bd.divide(bd2);<br><span class="hljs-comment">//相除并返回结果</span><br>bd.divide(bd2,<span class="hljs-number">2</span>,BigDecimalROUND_DOWN)<br><span class="hljs-comment">//相除, 返回只保留两位小数的结果</span><br>bd.pow(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//计算幂, 注意必须传入参数必须为int整数</span><br></code></pre></td></tr></table></figure><p><strong>收尾模式</strong></p><p>类常量:</p><p>ROUND_DOWN保留小数位,后面都舍弃</p><p>ROUND_UP判断保留小数位的下一位不等于0则进一</p><p>ROUND_HALF_UP四舍五入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BigDecimal bd2=BigDecimal.valueOf(<span class="hljs-number">2.1234567</span>);<br>bd2.setScale(<span class="hljs-number">4</span>,BigDecimal.ROUND_HALF_UP);<br><span class="hljs-comment">//只保留4位小数,四舍五入</span><br></code></pre></td></tr></table></figure><p><strong>setScale() 需要输入保留位数和保留模式的参数</strong></p><h1 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h1><blockquote><p>Date中的大部分方法已经被废弃, 因为Date显示的时间为当前系统的所在时区的当地时间, 不支持国际化</p><p>可以使用Calender类来代替Date类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Date d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis());<br><span class="hljs-comment">//以1970-1-1到某个时间的时间差(毫秒为单位)创建Date对象</span><br>Date d2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>Date d3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-comment">//创建一个当前时间的Date对象</span><br>System.out.println(d);<br>System.out.println(d2);<br><span class="hljs-comment">//d和d2的输出相同</span><br>d.equals(d2);<br><span class="hljs-comment">//true</span><br>d3.equals(d2);<br><span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h1 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h1><p>需要先创建对象再通过对象调用实例方法</p><p>getTime()</p><blockquote><p>将Calendar对象转换为Date对象</p></blockquote><p>get()set()add()</p><blockquote><p>获取时间 修改时间 在存储的时间基础上加减时间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br><span class="hljs-comment">//注意Calendar对象储存的是创建的时间, 创建后不会变化</span><br>Date d1= cal.getTime();<br><span class="hljs-comment">//转换成Date对象</span><br>cal.get(Calendar.DAY_OF_YEAR);<br><span class="hljs-comment">//今年的第几天</span><br>cal.get(Calendar.DAY_OF_MONTH);<br><span class="hljs-comment">//这个月的第几天</span><br>cal.get(Calendar.DAY_OF_WEEK);<br><span class="hljs-comment">//这周的第几天</span><br>cal.get(Calendar.YEAR);<br><span class="hljs-comment">//公元第几年</span><br>cal.get(Calendar.MONTH);<br><span class="hljs-comment">//今年第几个月</span><br>cal.get(Calendar.DATE);<br><span class="hljs-comment">//和Calendar.DAY_OF_MONTH相同</span><br>cal.get(Calendar.HOUR_OF_DAY);<br><span class="hljs-comment">//今天的第几个小时</span><br>cal.get(Calendar.MINUTE);<br><span class="hljs-comment">//当前小时的第几分钟</span><br>cal.get(Calendar.SECOND);<br><span class="hljs-comment">//当前分钟的第几秒</span><br>cal.set(<span class="hljs-number">1997</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//将时间修改为1997年6月1日,修改对象本身</span><br>cal.add(Calender.YEAR,<span class="hljs-number">60</span>);<br><span class="hljs-comment">//将时间修改为60年后, 会修改对象本身</span><br>cal.add(Calender.YEAR,-<span class="hljs-number">60</span>);<br><span class="hljs-comment">//将时间修改为60年前, 会修改对象本身</span><br></code></pre></td></tr></table></figure><h1 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h1><p>用于将字符串和Date对象按照一定格式进行相互转换</p><p>实例方法:</p><p>parse(String str)format(Date d)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>String str=<span class="hljs-string">&quot;2022-05-16 12:00:12&quot;</span>;<br>SimpleDateFormat sdf=<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br><span class="hljs-comment">//注意月份和分钟分别用大小写的M和m表示</span><br>Date date=sdf.parse(str);<br><span class="hljs-comment">//将格式的字符串转换成对应时间的Date对象</span><br>System.out.println(date);<br>Date date1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>sdf.format(date1);<br><span class="hljs-comment">//将Date对象转换成格式化的字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>必须加上throws ParseException捕获异常, 否则编译会报错</p><blockquote><p>完整格式参考表格</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220516145849340.png" alt="image-20220516145849340"></p><h1 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h1><p><strong>LocalDate按照系统所在语言的格式来输出时区对应的日期</strong></p><p><strong>注意LocalDate对象储存的是年月日, 不包含小时 分钟 秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDate ld=LocalDate.now();<br><span class="hljs-comment">//创建LocalDate对象存储当前时间</span><br>System.out.println(ld);<br><span class="hljs-comment">//输出2022-05-16格式的年月日</span><br>ld.getYear();<br><span class="hljs-comment">//输出年份</span><br>ld.getMonth().getValue();<br><span class="hljs-comment">//输出第几个月</span><br><span class="hljs-comment">//使用ld.getMonth()会输出月份的英文单词</span><br>ld.getDayOfMonth();<br><span class="hljs-comment">//输出一个月中的第几天</span><br>ld.getDayOfYear();<br><span class="hljs-comment">//输出一年中的第几天</span><br>ld.getDayOfWeek();<br><span class="hljs-comment">//输出一周的第几天</span><br>LocalDate ld2=LocalDate.of(<span class="hljs-number">2022</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>);<br><span class="hljs-comment">//修改时间</span><br>ld2.isLeapYear();<br><span class="hljs-comment">//判断是否是闰年</span><br><span class="hljs-comment">//输出假</span><br>ld2.isAfter(ld);<br><span class="hljs-comment">//判断ld2的时间是否在ld之后</span><br><span class="hljs-comment">//输出假</span><br>String str=ld.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH时-mm分钟-ss秒&quot;</span>));<br><span class="hljs-comment">//上行代码会报16错, 因为LocalDate对象中不存储小时 分钟 秒</span><br>String str=ld.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>));<br><span class="hljs-comment">//将LocalDate对象转换为格式化字符串</span><br>String str2= <span class="hljs-string">&quot;2022年05月16日&quot;</span>;<br>LocalDate ld3=LocalDate.parse(str2,DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>));<br><span class="hljs-comment">//将字符串转换为LocalDate对象</span><br>LocalDate ld4=ld3.plusDays(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//将时间加10天, 返回修改后的时间, 不会修改对象本身</span><br>ld4=ld4.plusDays(-<span class="hljs-number">10</span>);<br><span class="hljs-comment">//减10天, 不修改原对象</span><br>ld4=ld4.plusMonths(<span class="hljs-number">5</span>);<br><span class="hljs-comment">//加5个月,不修改原对象</span><br>ld4=ld4.plusYears(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//加一年, 不修改原对象</span><br></code></pre></td></tr></table></figure><h1 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h1><p>跟LocalDate类似, 但是存储的是时分秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalTime lt= LocalTime.now();<br>lt.getHour();<br>lt.getMinute();<br>lt.getSecond();<br>lt=LocalTime.of(<span class="hljs-number">23</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>);<br><span class="hljs-comment">//修改时间</span><br>String str=lt.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>));<br><span class="hljs-comment">//不能使用hh,这里只能使用HH</span><br><span class="hljs-comment">//将LocalTime对象转换为字符串</span><br>lt=LocalTime.parse(<span class="hljs-string">&quot;11点45分30秒&quot;</span>,DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH点mm分ss秒&quot;</span>));<br><span class="hljs-comment">//不能使用hh,这里只能使用HH</span><br></code></pre></td></tr></table></figure><h1 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h1><p>存储年月日 时分秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime ldt=LocalDateTime.now();<br>ldt.getDayOfYear();<br>ldt.getDayOfMonth();<br>ldt.getHour();<br>ldt=LocalDateTime.of(<span class="hljs-number">2022</span>,<span class="hljs-number">3</span>,<br>        <span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>);<br>String str=ldt.format(DateTimeFormatter<br>        .ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));<br><span class="hljs-comment">//注意HH为24小时制</span><br><span class="hljs-comment">//hh为12小时制</span><br>ldt=LocalDateTime.parse(str,DateTimeFormatter<br>        .ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));<br></code></pre></td></tr></table></figure><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>错误(error): 对程序来说不可预测, 不可避免</p><blockquote><p>例如OOM(out of memory) 内存不足导致程序被关闭</p></blockquote><p>异常(exception)分为编译时异常和运行时异常, 都可以通过修改代码处理</p><p>编译时异常:编译器编译时检查出的问题</p><p>运行时异常:程序运行时在JVM抛出的异常</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220516193158131.png" alt="image-20220516193158131"></p><blockquote><p>异常继承树</p></blockquote><p><strong>exception可以通过代码来解决, 体现了Java的健壮性</strong></p><blockquote><p>编译时异常的父类是Exception</p><p>运行时异常的父类是RuntimeException</p></blockquote><p>编译时异常有:</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220516193429760.png" alt="image-20220516193429760"></p><p>运行时异常有:</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220516193455333.png" alt="image-20220516193455333"></p><p>方法栈中的调用关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainEnter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        meth01();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meth01</span><span class="hljs-params">()</span> &#123;<br>        meth02();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meth02</span><span class="hljs-params">()</span> &#123;<br>        meth03();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meth03</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;猜猜我是谁！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中运行的方法栈如图所示</p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220516193642011.png" alt="image-20220516193642011"></p><blockquote><p>当一个方法主动抛出异常时, 将导致该方法被弹出方法栈, 并导致方法栈中在该方法上的方法也被弹出</p></blockquote><p>编译时异常的解决方案:</p><ol><li><p>不捕获异常, 直接向外抛出</p><blockquote><p>异常未被内部处理, 并且会异常方法会被弹出方法栈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;wrong input&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>捕获异常, 但不抛出</p><blockquote><p>异常会被内部消化, 方法不会被弹出栈</p><p>方法会全部执行完</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;wrong input&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>捕获异常并向外抛出</p><blockquote><p>异常被内部消化, 并告知调用的方法</p><p>导致产生异常的方法被弹出方法栈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-comment">//指定抛出异常的类型</span><br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;wrong input&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> e;<br>        <span class="hljs-comment">//将捕获到的异常抛出给外部</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>总结: 1,3会导致方法被弹出栈结构, 剩余代码不会被执行</p><p>2不会弹出, 完整执行完方法的代码</p><p>通常编程中使用1,2方案</p><p>使用原则: 在栈结构允许的最高处捕获并处理异常, 其他层直接将异常外抛</p></blockquote><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><strong>java中的数组不属于集合</strong></p><p><strong>数组特点</strong></p><ol><li>数组的长度不可变</li><li>数组的元素类型是相同且不可变的</li><li>数组不能保存映射关系的数据</li><li>数组的元素可以存储基本数据类型和引用数据类型</li><li>数组是线性连续结构的存储空间</li></ol><p><strong>集合特点:</strong></p><ol><li>集合是长度是可变的容器</li><li>集合的元素类型可以是不同的, 也是可变的</li><li>集合可以保存映射关系的数据(关联数组)</li><li>集合的元素只能存储引用数据类型</li></ol><p>Collection和Map接口是Java集合框架中的根接口</p><p>java中的集合类主要由这两个接口派生出</p><p>集合中的集合分为四种结构: Set List Queue Map</p><p>set: 无序, 元素值不可重复</p><p>list: 有序,可以重复, 通过index来访问值</p><p>Map: 保存映射关系的集合</p><p>Queue: 队列集合</p><p><strong>java中的集合实质为一种特殊的容器, 用于存储多个对象引用</strong></p><p>在Java5中增加了泛型, 使集合具有了存储容器中对象数据类型的能力</p><blockquote><p>在java5之前, 集合将容器中所有的对象都视为Object类型</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220517142541474.png" alt="image-20220517142541474"></p><p>需要访问一种集合中的元素时:</p><ol><li>Set集合只能通过元素值本身来访问(Set集合不能有重复元素值)</li><li>List集合可以通过索引(index)来访问</li><li>Map通过key来访问元素值(value)</li></ol><blockquote><p>Collection集合体系</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220517145417860.png" alt="image-20220517145417860"></p><blockquote><p>Map集合体系</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220517145443512.png" alt="image-20220517145443512"></p><p><strong>其中ArrayListHashSet和HashMap是重点掌握内容</strong></p><p>注意List, Set和Queue都是Collection的子接口</p><p>而Map不属于Collection, 是和Collection相同地位的根接口</p><p>List特点: 有序 元素值可以重复 每个元素都有对应的下标来访问[0到length-1]</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList是List接口的实现类</p><p>ArrayList是一个基于数组结构的列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">al</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">//无参构造</span><br>ArrayList al2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(al);<br><span class="hljs-comment">//可以传入一个Collection集合, 创建一个包含该集合元素的list</span><br>ArrayList al3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//指定初始容量</span><br></code></pre></td></tr></table></figure><blockquote><p>三种构造器</p></blockquote><p>与下列代码的数组类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] objects;<br></code></pre></td></tr></table></figure><p>实例方法:</p><table><thead><tr><th>方法名</th><th>方法功能</th></tr></thead><tbody><tr><td>add</td><td>添加数据</td></tr><tr><td>get</td><td>获取对应索引的数据</td></tr><tr><td>contains</td><td>判断list中是否包含对应的元素值</td></tr><tr><td>indexOf</td><td>查找元素值对应的索引(-1代表无法找到)</td></tr><tr><td>isEmpty</td><td>判断集合元素是否全部为空, 空返回true</td></tr><tr><td>clear</td><td>删除list中全部元素</td></tr><tr><td>remove</td><td>删除索引位置上的元素</td></tr><tr><td>size</td><td>获取列表包含的元素个数</td></tr><tr><td>set</td><td>修改对应索引的元素</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>al.add(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-comment">//在0索引位置加入数据</span><br>al.add(<span class="hljs-number">3</span>);<br>al.add(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);<br><span class="hljs-comment">//在索引位置插入数据</span><br>al.set(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<br>Collections.addAll(al,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><span class="hljs-comment">//向集合中添加大量元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; al.size(); i++) &#123;<br>    System.out.println(al.get(i));<br>    <span class="hljs-comment">//遍历list</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Collections类方法</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>addAll</td><td>将大量元素添加到对应集合对象中</td></tr><tr><td>sort</td><td>将集合中的元素进行排序, 字符串也可以排序, 但是如果集合中同时包含字符串和数组类型, 会发生类型转换异常</td></tr></tbody></table><p>集合有三种遍历方式: for循环, 增强for循环, 迭代器(iterator)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">al</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">//for循环遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; al.size(); i++) &#123;<br>    System.out.println(al.get(i));<br>&#125;<br><span class="hljs-comment">//增强for循环遍历</span><br><span class="hljs-keyword">for</span> (Object o :al) &#123;<br>    System.out.println(o);<br>&#125;<br><span class="hljs-comment">//迭代器遍历</span><br>Iterator it=al.iterator();<br><span class="hljs-comment">//注意迭代器初始位置未指向任何元素</span><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    Object oj=it.next();<br>    <span class="hljs-comment">//迭代器指向集合中的下一个对象, 并返回下一个对象的地址</span><br>    <span class="hljs-comment">//第一次运行会使迭代器指向集合中的第一个对象</span><br>    System.out.println(oj);<br>    it.remove();<br>    <span class="hljs-comment">//删除当前迭代器指向的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一个类可以通过实现Comparable这个函数接口中的compareTo方法(实例方法), 使Collections.sort可以排序该类的对象元素</strong></p><blockquote><p>自然排序: 在被比较对象的类里实现了Comparable函数接口里的compareTo方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Cat&gt;&#123;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Cat c)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age-c.age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test15</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Cat c1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">3</span>);<br>        Cat c2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">2</span>);<br>        ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Collections.addAll(al,c1,c2);<br>        System.out.println(al);<br>        Collections.sort(al);<br>        System.out.println(al);<br>        System.out.println(c1.compareTo(c2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自定义排序:</p><p>创建了一个CarComparator类实现Comparator函数接口里面的compare方法(实例方法), 可以在Collection.sort方法从传入该比较类对象来进行比较</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Cat&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Cat o1, Cat o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.age-o2.age;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test15</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Cat c1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">3</span>);<br>        Cat c2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">2</span>);<br>        ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Collections.addAll(al,c1,c2);<br>        System.out.println(al);<br>        Collections.sort(al,<span class="hljs-keyword">new</span> <span class="hljs-title class_">CatComparator</span>());<br>        <span class="hljs-comment">//自定义</span><br>        System.out.println(al);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ArrayList的底层是通过数组实现</strong></p><blockquote><p><strong>引用数据类型变量的大小为4个字节</strong></p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220517174253114.png" alt="image-20220517174253114"></p><blockquote><p>ArrayList的初始容量为0</p><p>当添加第一个元素时,容量变成10</p><p>添加第11个元素时, 容量变成15 10+(10&gt;&gt;1)&#x3D;10*1.5&#x3D;15</p><p>添加16个元素时, 容量变为15+(15&gt;&gt;1)&#x3D;15*1.5&#x3D;22</p><p>当添加元素而ArrayList容量不足时, 容量会自动扩容为原来的1.5倍</p></blockquote><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><strong>java5中引入参数化类型(parameterized type)的概念,也就是泛型(Generic)</strong></p><p><strong>泛型允许在创建集合时指定元素的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明了一个String泛型的集合al</span><br>ArrayList&lt;String&gt; al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-comment">//java7后可以省略菱形语法</span><br>ArrayList&lt;String&gt; al2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>ArrayList&lt;String&gt; al2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();f<br></code></pre></td></tr></table></figure><p>为了实现集合的通用性:可以保存不同类型的对象元素, 集合中的元素都以Object类型来保存(编译类型)</p><blockquote><p>防止编译器检查报错</p></blockquote><blockquote><p>注意运行时类型没有变, 依旧为原类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Collections.addAll(al,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span> (Object o : al) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span>(String)o;<br>    str.indexOf(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//上述代码运行会报错, 因为列表中包含Integer类型</span><br>    <span class="hljs-comment">//ine类型字面量被自动装箱生成的Integer类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>泛型可以规范集合的元素类型</p><blockquote><p>本质是在编译时进行检查集合中的元素是否为泛型规定的类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Collections.addAll(al, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">//编译时会报错, 因为向String泛型的列表中添加了Integer类型的变量</span><br><span class="hljs-keyword">for</span> (Object o : al) &#123;<br>    System.out.println((o <span class="hljs-keyword">instanceof</span> Integer));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>了解泛型接口和泛型类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyList</span>&lt;String&gt;&#123;<br>&#125;<br><span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;String&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyList</span>&lt;String&gt;&#123;<br>&#125;<br><span class="hljs-comment">//调用测试</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyList&lt;String&gt; datas=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型通配符</strong></p><p>java只有一个泛型通配符</p><p>?  代表不确定的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(ArrayList&lt;?&gt; dates)</span>&#123;&#125;<br>    <span class="hljs-comment">//匹配任何类型</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">(ArrayList&lt;? extends Number&gt; dates)</span>&#123;&#125;<br>    <span class="hljs-comment">//设定通配符上限</span><br>    <span class="hljs-comment">//必须是继承自Number类</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">(ArrayList&lt;? <span class="hljs-built_in">super</span>  Integer&gt; dates)</span>&#123;&#125;<br>    <span class="hljs-comment">//设定通配符下限</span><br>    <span class="hljs-comment">//必须是Integer的父类</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型形参</strong></p><p>通常有以下常用的字母用于泛型形参</p><ol><li>T  代表确定的类型</li><li>K V分别代表键(Key)值(Value)</li><li>E  代表Element</li></ol><blockquote><p>这里意义是习惯默认的, 并非是强制的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匹配任意类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(ArrayList&lt;?&gt; datas)</span>&#123;&#125;<br><span class="hljs-comment">//注意在这里只有?是可以使用的</span><br>&#125;<br><span class="hljs-comment">//在泛型接口中, 可以用泛型形参</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(ArrayList&lt;E&gt; datas)</span>&#123;&#125;<br>    <span class="hljs-comment">//并且泛型形参只能用于实例方法, 不能用于类方法</span><br>    <span class="hljs-comment">//因为需要在创建对象时将类型传给通配符才有实际意义</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Test</span>&lt;String&gt;&#123;&#125;<br><span class="hljs-comment">//将String类型传入形参E</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Test</span>&#123;&#125;<br><span class="hljs-comment">//省略泛型将导致使用原始类型(raw type), T将被编译器视为Object类型处理</span><br></code></pre></td></tr></table></figure><p><strong>泛型擦除</strong></p><p><strong>泛型擦除指泛型只会在编译时进行检查, 并且所有泛型参数在编译后都会被清除, 不会保留到运行时</strong></p><blockquote><p>泛型的本质是在编译时对代码进行检查, 因此运行时是可以对泛型集合添加任意类型的对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(ArrayList&lt;String&gt; al)</span>&#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(ArrayList&lt;Integer&gt; al)</span>&#123;&#125;<br><span class="hljs-comment">//上面两个方法不是方法重载, 由于泛型擦除的特性,所以它们的参数列表是相同的</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ArrayList<String>并非一个新的类, 它与ArrayList是同一个类(实质上等同于ArrayList<Object>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; l1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; l2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>System.out.println(l1.getClass());<br><span class="hljs-comment">//l1的类型为ArrayList</span><br>System.out.println(l2.getClass());<br><span class="hljs-comment">//l2的类型为ArrayList</span><br><span class="hljs-comment">//所以l1跟l2的类型相同</span><br></code></pre></td></tr></table></figure><p><strong>泛型形参不能用于类(static)成员</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] intList =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">5</span>];<br>Number[] doublesList=intList;<br>doublesList[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>doublesList[<span class="hljs-number">1</span>]=<span class="hljs-number">0.5</span>;<br><span class="hljs-comment">//这行代码不会被编译器检查出错误, 但是在运行时会抛出ArrayStoreException, 因为0.5无法被存储为Integer类型</span><br><span class="hljs-comment">//这里是java早期的设计缺陷</span><br></code></pre></td></tr></table></figure><blockquote><p>优秀的编程语言不仅需要提供强大的功能, 更需要在编译时能提供错误提示, 做到在程序运行前就检查出错误</p></blockquote><p>在泛型设计时, java增强了编译检查的设计,不允许将引用变量指向不同类型的泛型对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; iList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>List&lt;Number&gt; nList=iList;<br><span class="hljs-comment">//上述代码将导致编译错误, 避免了程序运行时出现ClassCastException</span><br></code></pre></td></tr></table></figure><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>在java中, LinkedList属于List集合的一种, 可以根据索引进行随机访问元素</p><p>LinkedList属于数据结构中的双向链表结构</p><blockquote><p>LinkedList是List和Deque的实现类</p><p>因此LinkedList也可以作为双向队列使用</p></blockquote><blockquote><p>双向队列: 既可以作为栈, 也可以作为队列</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220518165702335.png" alt="image-20220518165702335"></p><blockquote><p>双向链表的每个元素会存储:</p><p>上个元素的索引下一个元素的索引当前元素值</p></blockquote><blockquote><p>展示了LinkedList各种API的使用, 大部分API与ArrayList相同</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; ll=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>Collections.addAll(ll,<span class="hljs-string">&quot;bdd&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;bcd&quot;</span>,<span class="hljs-string">&quot;小李&quot;</span>);<br>ll.get(<span class="hljs-number">0</span>);<br>ll.size();<br>ll.set(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ll&quot;</span>);<br>ll.contains(<span class="hljs-string">&quot;小李&quot;</span>);<br>ll.remove(<span class="hljs-number">1</span>);<br>ll.clear();<br>Collections.addAll(ll,<span class="hljs-string">&quot;bdd&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;bcd&quot;</span>,<span class="hljs-string">&quot;小李&quot;</span>);<br><br>ll.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;s&quot;</span>);<br>    &#125;<br>&#125;);<br>Collections.sort(ll);<br>System.out.println(ll);<br></code></pre></td></tr></table></figure><p>LinkedList和ArrayList的区别</p><table><thead><tr><th>LinkedList</th><th>ArrayList</th></tr></thead><tbody><tr><td>底层是数组结构</td><td>底层是链表结构</td></tr><tr><td>新增, 删除元素的效率低</td><td>新增, 删除元素的效率高</td></tr><tr><td>查询元素的效率高</td><td>查询元素的效率低</td></tr></tbody></table><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set的特点:</p><ol><li><p>Set的实现类可以有序也可以无序</p></li><li><p>Set的元素值不允许有重复(相同)的</p></li><li><p>Set没有下标, 不能通过下标去访问元素</p><blockquote><p>通过下标访问元素是List集合的重要特征</p></blockquote></li></ol><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>HashSet是Set的实现类, 底层使用HashMap的Key键作为元素值</p><p>HashSet特点:</p><ol><li>元素是无序的</li><li>不允许有重复元素</li><li>没有下标</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Set&lt;String&gt; stringSet1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>Collections.addAll(stringList,<span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ww&quot;</span>, <span class="hljs-string">&quot;tq&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;zl&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>);<br>Collections.addAll(stringSet1,<span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ww&quot;</span>, <span class="hljs-string">&quot;tq&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;zl&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>);<br>Set&lt;String&gt; stringSet2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(stringList);<br>System.out.println(stringList);<br>System.out.println(stringSet1);<br>System.out.println(stringSet2);<br><span class="hljs-comment">//stringSet1和stringSet2的元素内容和顺序是完全相同的</span><br><span class="hljs-comment">//说明HashSet虽然是无序存储的, 但是如果两个Set的元素内容相同的,则它们的元素存储也是按相同的顺序</span><br></code></pre></td></tr></table></figure><p>HashSet实例方法:</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>add</td><td>添加元素(无序)</td></tr><tr><td>size</td><td>显示元素个数</td></tr><tr><td>contains</td><td>是否包含某元素值</td></tr><tr><td>remove</td><td>删除某个元素值</td></tr><tr><td>forEach</td><td>迭代方法, 需要实现一个函数接口的元素展示方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; stringSet1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>Collections.addAll(stringSet1,<span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ww&quot;</span>, <span class="hljs-string">&quot;tq&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;zl&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>);<br>stringSet1.add(<span class="hljs-string">&quot;123&quot;</span>);<br>stringSet1.size();<br>stringSet1.contains(<span class="hljs-string">&quot;123&quot;</span>);<br>stringSet1.remove(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-comment">//通过匿名内部类实现了Consumer函数接口的accept方法</span><br>stringSet1.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">//通过lambda表达式实现</span><br>stringSet1.forEach((str)-&gt;&#123;<br>    System.out.println(str);<br>&#125;);<br><span class="hljs-comment">//for循环遍历set</span><br><span class="hljs-keyword">for</span> (String s : stringSet1) &#123;<br>    System.out.println(s);<br>&#125;<br><span class="hljs-comment">//通过迭代器实现遍历</span><br>Iterator it=stringSet1.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    System.out.println(it.next());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以用ArrayList将HashSet中的元素存储为有序的模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet&lt;String&gt; stringHashSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>Collections.addAll(stringHashSet,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;acd&quot;</span>,<span class="hljs-string">&quot;bde&quot;</span>);<br>System.out.println(stringHashSet);<br>ArrayList&lt;String&gt; stringArrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(stringHashSet);<br>System.out.println(stringArrayList);<br>Collections.sort(stringArrayList);<br>System.out.println(stringArrayList);<br></code></pre></td></tr></table></figure><p><strong>HashSet底层使用HashMap的key来去重元素</strong></p><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220519114853154.png" alt="image-20220519114853154"></p><p>HashSet添加元素的步骤</p><ol><li><p>先使用hashcode()将要添加的元素与集合中的其他元素一一对比, 如果不相等则进入第二步</p></li><li><p>使用equals()将要添加的元素与集合中的其他元素一一对比, 如果还是不相等则加入集合中</p></li></ol><blockquote><p>hashcode() 该方法是Object，底层是C语言编写的，用来获得 对象的地址值（经过一系列的算法）</p><p>equals() 该方法是Object，默认比较的地址值</p></blockquote><blockquote><p>hashcod()获取到的hash值对于同一对象一定相等,</p><p>对于不同的对象可能会不相等</p></blockquote><blockquote><p>(正确性待确认)HashSet中的元素，一定要重写hashcode() 以及equals()</p></blockquote><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是一种分层结构, 不是线性结构</p><blockquote><p>常见线性数据结构: 数组(Arrays) 链表(Linked List) 栈(Stack) 队列(Queue)</p></blockquote><p>根节点(root): 没有父节点的节点(node)(每个树结构只能有一个根节点)(处于二叉树的最顶端)</p><p>叶子节点(leave): 没有子节点的节点(处于二叉树的最末端)</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-code">     tree</span><br><span class="hljs-code">     ----</span><br><span class="hljs-code">      j    &lt;-- root</span><br><span class="hljs-code">    /   \</span><br><span class="hljs-code">   f      k  </span><br><span class="hljs-code"> /   \      \</span><br><span class="hljs-code">a     h      z    &lt;-- leaves</span><br></code></pre></td></tr></table></figure><p>树结构的特点:</p><ol><li><p>可以存储层次结构信息</p></li><li><p>访问&#x2F;搜索元素的速度较快(比链表快, 比数组慢)</p></li><li><p>插入&#x2F;删除速度较快(比数组快,无序链表慢)</p></li><li><p>节点数量可变(无上限)</p><blockquote><p>因为节点使用指针链接到不同节点</p></blockquote></li></ol><p>树的常见应用场景:</p><ol><li>操作层次结构的数据</li><li>树遍历可以用于信息的搜索</li><li>路由算法</li><li>多阶段决策</li></ol><p>指向根节点的指针代表整个树, 根节点的值为空时代表整个树为空 </p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树是一种树结构, 要求一个节点最多只能有两个子节点(child)也被称为左子节点(left child和右子节点(right child)</p><p>拥有同一父节点的两个子节点被称为兄弟(sibling)</p><p>二叉树有三种常见的类型</p><p>全二叉树(Full Binary Tree) 节点不能只有一个子节点(除了叶子节点外,所有的节点必须有两个子节点)</p><p>满二叉树(Perfect Binary Tree) 需要是一个全二叉树, 并且叶子节点都必须在同一级别(level)</p><p>平衡二叉树(Balanced Binary Tree): 如果一个二叉树的高度是O(log n)则其为平衡的</p><blockquote><p>n为该树的节点数</p></blockquote><p>二叉树有两种存储方式: 顺序存储, 链式存储</p><blockquote><p> O(log n)的图形表示</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220520100608133.png" alt="image-20220520100608133"></p><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>二叉树(Binary Tree)属于一种递归结构, 并且每个节点最多有两个子节点</p><p>二叉搜索树(Binary Search Tree)属于一种特殊的二叉树, 要求每个节点都大于或等于左子节点值, 小于等于右子节点</p><p>左子节点&lt;&#x3D;当前节点&lt;&#x3D;右子节点</p><blockquote><p>下图是二叉搜索树示例</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220519100114435.png" alt="image-20220519100114435"></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种特殊的线性(有序)列表(list)</p><p>采用先进先出(FIFO)的顺序来处理元素</p><p>先进先出: 只能在list末尾插入元素, 只能在list开头将元素删除</p><p>队列在java中是一个接口: java.util.Queue</p><p>有两个常用的实现类: LinkedList, PiorityQueue</p><blockquote><p>注意两者都不是线程安全的</p></blockquote><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一种完全二叉树, 通过数组来存储数据</p><blockquote><p>大多数的树是使用链式结构来存储数据</p></blockquote><p>堆又分为大顶堆和小顶堆</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>计算机中的数据以一种被设计好的结构被存储起来, 这种结构被称为数据结构</p><h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h1><blockquote><p>数组的结构</p></blockquote><p><img src="/2022/11/08/0%E7%96%AF%E7%8B%82Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220520102459480.png" alt="image-20220520102459480"></p><p>数组的优点:</p><ol><li>数组允许随机访问元素, 意味着可以直接读取在数组中的任意位置的元素, 而无须经过其他的元素</li><li>数组具有良好的空间局限性, 可以提供很好的性能</li><li>一个数组中的数据类型是相同的</li></ol><p>缺点:</p><ol><li><p>由于数组是编译时内存, 一旦声明后无法在运行时更改其内存大小. </p><blockquote><p>由于数组的元素都是存储在连续的内存位置, 所以对中间元素进行插入, 删除, 移位等操作的</p></blockquote></li></ol><p>java中数组的特性:</p><ol><li>数组都是动态分配的</li><li>数组的本质是对象, 可以调用实例属性.length</li><li>数组的元素是有序的</li><li>数组可以用作静态字段, 方法变量, 方法参数</li></ol><p><strong>一个好的java程序应该满足什么条件: 高内聚 低耦合</strong></p><p>高内聚, 低耦合有对应的7大设计原则, 23个设计模式</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RPC协议</title>
    <link href="/2022/11/08/RPC%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/11/08/RPC%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC协议"><a href="#RPC协议" class="headerlink" title="RPC协议"></a>RPC协议</h1><h1 id="虾皮二面：既然有-HTTP-协议，为什么还要有-RPC"><a href="#虾皮二面：既然有-HTTP-协议，为什么还要有-RPC" class="headerlink" title="虾皮二面：既然有 HTTP 协议，为什么还要有 RPC?"></a>虾皮二面：既然有 HTTP 协议，为什么还要有 RPC?</h1><p>分享一道群友面试虾皮遇到的 RPC 基础面试题。</p><p>下面是正文。</p><p>我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？</p><p>于是就到网上去搜。</p><p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在<strong>用一个我们不认识的概念去解释另外一个我们不认识的概念</strong>，懂的人不需要看，不懂的人看了还是不懂。</p><p>这种看了，又好像没看的感觉，云里雾里的很难受，<strong>我懂</strong>。</p><p>为了避免大家有强烈的<strong>审丑疲劳</strong>，今天我们来尝试重新换个方式讲一讲。</p><h2 id="从-TCP-聊起"><a href="#从-TCP-聊起" class="headerlink" title="从 TCP 聊起"></a>从 TCP 聊起</h2><p>作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。</p><p>这时候，我们可选项一般也就<strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。</strong> 除非是马总这种神级程序员（早期 QQ 大量使用 UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。</p><p>类似下面这样。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">fd</span> = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p><p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用<code>bind()</code>绑定 IP 端口，用<code>connect()</code>发起建连。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQyocyCbtWtQeAg4dXsJUj5c3UIia0jsTxmWSBszLU9PWJXMQyUnWh4lw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>握手建立连接流程</p><p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。</p><p>光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？</p><p>不行，这么用会有问题。</p><h2 id="使用纯裸-TCP-会有什么问题"><a href="#使用纯裸-TCP-会有什么问题" class="headerlink" title="使用纯裸 TCP 会有什么问题"></a>使用纯裸 TCP 会有什么问题</h2><p>八股文常背，TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQNSCzkhc9Ds1jv58WWg97SU7BFSoYydLxdicjEMWrPmmjsibFeHWWQrJg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">TCP是什么</p><p>这三个特点真的概括的 <strong>非常精辟</strong> ，这个八股文我们没白背。</p><p>每个特点展开都能聊一篇文章，而今天我们需要关注的是 <strong>基于字节流</strong> 这一点。</p><p>字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 <strong>01 串</strong> 。纯裸 TCP 收发的这些 01 串之间是 <strong>没有任何边界</strong> 的，你根本不知道到哪个地方才算一条完整消息。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQiceAsicWkehqjTuibicS3eFAEGoAaawjnzxlZX2IBOZW4wQBPNPfJian0eg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">01二进制字节流</p><p>正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送 <strong>“夏洛”和”特烦恼”</strong> 的时候，接收端收到的就是 <strong>“夏洛特烦恼”</strong> ，这时候接收端没发区分你是想要表达 <strong>“夏洛”+”特烦恼”</strong> 还是 <strong>“夏洛特”+”烦恼”</strong> 。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQ9Sx8u4DvUDT8JSoqibIfib4MLv6Y90eiadb0hrqwtz3Yw4eYt6ibAGrGFw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">消息对比</p><p>这就是所谓的 <strong>粘包问题</strong>，之前也写过一篇专门的<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDY2MDk4Mw==&mid=2247486377&idx=1&sn=bdc4b8b71559193b29aa0f54b95973db&scene=21#wechat_redirect">文章</a>聊过这个问题。</p><p>说这个的目的是为了告诉大家，纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些 <strong>自定义的规则</strong> ，用于区分 <strong>消息边界</strong> 。</p><p>于是我们会把每条要发送的数据都包装一下，比如加入 <strong>消息头</strong> ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的 <strong>消息体</strong> 。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQF9hsXFlxicbBmB4O4rlU8SEf2ibOiceboxeUicqML5KOuxjc418NzUSEpA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">消息边界长度标志</p><p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 <strong>协议。</strong></p><p>每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong>。</p><p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p><h2 id="HTTP-和-RPC"><a href="#HTTP-和-RPC" class="headerlink" title="HTTP 和 RPC"></a>HTTP 和 RPC</h2><h3 id="RPC-其实是一种调用方式"><a href="#RPC-其实是一种调用方式" class="headerlink" title="RPC 其实是一种调用方式"></a>RPC 其实是一种调用方式</h3><p>我们回过头来看网络的分层图。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQy1hazSoyvSzo26x5ZqmjkFic0xDdZvxQGpmHSUbDqPF6MicLwTL7hJEw/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">四层网络协议</p><p><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</p><p><strong>HTTP</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）协议又叫做 <strong>超文本传输协议</strong> 。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQzuiawFRh686Do23ISC3LOlDfFeNlMzuoibf5iacc4JQkepocgJLpmJib9A/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">HTTP调用</p><p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）又叫做 <strong>远程过程调用</strong>，它本身并不是一个具体的协议，而是一种 <strong>调用方式</strong> 。</p><p>举个例子，我们平时调用一个 <strong>本地方法</strong> 就像下面这样。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> localFunc(req)<br></code></pre></td></tr></table></figure><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> remoteFunc(req)<br></code></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQBiaRyJO9O3JCL9RSmpJ4GfIYyZgvMU6tfia5WCEIaAD6ZGGLqb2NwfWQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">RPC可以像调用本地方法那样调用远端方法</p><p>基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p><p>值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上 <strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p><p>到这里，我们回到文章标题的问题。</p><h3 id="那既然有-RPC-了，为什么还要有-HTTP-呢？"><a href="#那既然有-RPC-了，为什么还要有-HTTP-呢？" class="headerlink" title="那既然有 RPC 了，为什么还要有 HTTP 呢？"></a>那既然有 RPC 了，为什么还要有 HTTP 呢？</h3><p>其实，TCP 是 <strong>70 年</strong> 代出来的协议，而 HTTP 是 <strong>90 年代</strong> 才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 <strong>80 年代</strong> 出来的<code>RPC</code>。</p><p>所以我们该问的不是 <strong>既然有 HTTP 协议为什么要有 RPC</strong> ，而是 <strong>为什么有 RPC 还要有 HTTP 协议?</strong></p><p>现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client&#x2F;Server (C&#x2F;S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p><p>但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（Server）</strong> ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>Browser&#x2F;Server (B&#x2F;S)</strong> 的协议。</p><p>也就是说在多年以前，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 PC 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p><p>那这么说的话，<strong>都用 HTTP 得了，还用什么 RPC？</strong></p><p>仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。</p><h3 id="HTTP-和-RPC-有什么区别"><a href="#HTTP-和-RPC-有什么区别" class="headerlink" title="HTTP 和 RPC 有什么区别"></a>HTTP 和 RPC 有什么区别</h3><p>我们来看看 RPC 和 HTTP 区别比较明显的几个点。</p><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p><p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p><p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p><p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p><h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h4><p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p><p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQ78tbxt1OPPp1nA2xiaEVXOeIj7MuayiaZcMHWalqWjKabK3IjMibFkEfQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">connection_pool</p><p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p><p>可以看出这一块两者也没太大区别，所以也不是关键。</p><h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p><p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p><p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p><p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQ8CQ6IbniaKXTCiaT6wVLC3ic0oOBbD11MZywbkAsNJ8tuL3bsvhNdUOpQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">序列化和反序列化</p><p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p><p>我们可以随便截个图直观看下。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQKKMfXUTuYF3QKialV6DfGNsTCq15XSe0uHvibhnWsSasaLPvzeGl6ONQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">HTTP报文</p><p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p><p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQJ61c79zyvPHBibY7Ku7YQMoeibOPNAiaoia9WoAU17qwVuHkBWztwTUAow/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">HTTP原理</p><p><img src="https://mmbiz.qpic.cn/mmbiz/iaIdQfEric9TxwcyOKUBoOSRBQZnlm7zNQC7dicq7zfYascETGhRGIWZZb7sTHHOZDXickkzJE5JMffKicaeglEkH5Q/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">RPC原理</p><p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p><p>那么问题又来了。</p><h3 id="为什么既然有了-HTTP2，还要有-RPC-协议？"><a href="#为什么既然有了-HTTP2，还要有-RPC-协议？" class="headerlink" title="为什么既然有了 HTTP2，还要有 RPC 协议？"></a>为什么既然有了 HTTP2，还要有 RPC 协议？</h3><p>这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li><li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li><li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数组内存</title>
    <link href="/2022/11/08/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98/"/>
    <url>/2022/11/08/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>排序算法最简单 最常见的两种:</p><p>冒泡算法: </p><p>将数组遍历</p><p>遍历中将元素与下一元素进行比较, 将较小的元素放到前面, 较大的元素放到后面</p><p>遍历完后, 遍历的最后一位元素即为数组中最大的元素</p><p>将数组最后一位视为已排序好的元素</p><p>然后重新遍历未排序的数组元素</p><p>重复遍历直到首位元素确定为数组中的最小元素</p><p>n&#x3D;nums.length;</p><p>循环 i:0-&gt;n</p><p>循环 j:0-&gt;n-i</p><p>代码块:</p><p>int temp</p><p>if : nums[i]&gt;nums[i+1] {</p><p>temp&#x3D;nums[i]</p><p>nums[i+1]&#x3D;nums[i]</p><p>nums[i]&#x3D;temp;</p><p>}</p><p>选择排序:</p><p>int maxIndex&#x3D;0</p><p>i: 0-&gt;n</p><p>j: 0-&gt;n-i</p><p>代码块</p><p>j:</p><p>f(nums[j]&gt;nums[maxIndex]){</p><p>maxIndex&#x3D;j;</p><p>}</p><p>i:</p><p>swap(nums[maxIndex], nums[n-i])</p><p>如何遍历数组: 使用下标进行循环遍历</p><p>使用增强for循环变量(不需要用到下标)</p><h1 id="数组的内存"><a href="#数组的内存" class="headerlink" title="数组的内存"></a>数组的内存</h1><p>栈(stack) 内存</p><p>结构 : 上开下闭</p><p>存储: 后进先出</p><p>数组为引用数据类型</p><p>引用数据类型具体数据储存在堆内存</p><p>引用变量储存在栈内存</p><p>数组就是一个实例, 当一个实例的引用不存在时, 该实例会被GC回收(销毁)其内存空间, 释放出来, 可以被程序使用</p><p>数组常见错误:</p><p>下标越界: 索引值超过数组元素的范围</p><p>空指针错误: 不存在对应的数组</p><h1 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h1><p>F6 Step Over</p><p>在断点后逐行执行</p><p>不会进入子方法内部(但是子方法还是会作为一行整体执行)</p><p>F5 Step Info</p><p>在断点后逐行执行</p><p>会进入子方法内部</p><p>F7</p><p>从断点所在方法内部, 退出到外部</p><p>F8: 快速到达下一个断点</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java跨平台</title>
    <link href="/2022/11/08/Java%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    <url>/2022/11/08/Java%E8%B7%A8%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java跨平台"><a href="#Java跨平台" class="headerlink" title="Java跨平台"></a>Java跨平台</h1><p>Java通过给不同的操作系统开发对应的JVM来实现跨平台功能,也是Java<br><strong>JVM如何执行代码:</strong></p><blockquote><p>.java文件 –&gt; 字节码文件 –&gt; 机器码</p></blockquote><p>Java源代码经过编译器(javac)的处理后生成字节码文件(类名.class)</p><blockquote><p>由于Java从源代码到运行需要经过编译(interprete)和解释(Compile)两个过程,所以Java是半编译半解释型编程语言</p></blockquote><blockquote><p>Java程序的最小运行单位是类</p></blockquote><p>JVM读取字节码文件后经过一系列处理将字节码解释为机器码直接输出给CPU执行</p><p>JVM包含什么: 类加载器, 核心类库(Java中的系统类库,提供给程序员编程时候调用,大大提高了开发效率), 字节码校验器, 解释器, JIT(即时编译器)</p><p><strong>解释器和JIT的区别:</strong></p><p>解释器以类为单位解释代码, JIT以方法为单位解释代码</p><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>标识符组成Java代码语句, 包括: 关键字(一共50个), 自定义标识符</p><blockquote><p>关键字中有2个无作用保留字: goto const 它们在当前的Java版本中没有实际功能</p><p>除了50个外还有另外3个特殊的保留关键字: true flase null </p></blockquote><p>自定义标识符只能由数字, 字母, 下划线, $作为组成成分,不能以数字作为开头, 严格大小写, 不限制长度</p><p>行业规范以驼峰命名法来命名自定义标识符, 并且命名需要有意义, 尽量使用英文</p><p>其中类名和接口名是用大驼峰法来命名</p><p>方法名, 参数名, 变量名用小驼峰来命名</p><p>对于常量名, 需要全大写, 并且用下划线来分割单词</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Java有3种注释: 单行注释 &#x2F;&#x2F; 多行注释 &#x2F;* <em>&#x2F; 文档注释 &#x2F;</em>* *&#x2F; </p><p>单行注释和多行注释用于解释代码或者废弃代码</p><blockquote><p>文档注释用于API文档说明, 或者解释类的功能, 不能用于注释方法</p></blockquote><p><strong>变量</strong></p><p>变量类型: 全局变量(在方法外定义的变量) 局部变量(在方法内部定义的变量)</p><p>变量用于在内存中读取, 写入数据, 操作数据</p><p>Java的变量在使用前一定要先赋值, 不然会编译报错</p><p>Java是一种强类型语言, 所以声明变量时一定要先定义变量的类型</p><blockquote><p>弱类型语言: JavaScript代表, 在声明变量时不需要声明类型, 导致变量的类型不严格</p><p>强类型语言的优点: 可以在编译时及时检查出问题,实现程序的健壮性</p></blockquote><p>不可以重复声明相同名字的变量名</p><blockquote><p>疑问:全局变量和局部变量的变量名应该是可以有相同的情况</p></blockquote><p><strong>常量</strong></p><p>使用final关键字来定义常量</p><blockquote><p>常量的命名 需要全大写, 并且用下划线来分割单词</p></blockquote><p>字面量常量: 字符串常量 整数常量 浮点数常量</p><blockquote><p>疑问:常量和直接量的区别是什么</p></blockquote><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Java中的数据分为基本数据类型(8种)和引用数据类型(代表: String字符串)</p><blockquote><p>引用数据类型的本质是一个类</p></blockquote><p>8种基本数据类型:</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>大小</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1byte(字节)</td><td>-128到127</td></tr><tr><td>短整型</td><td>short</td><td>2byte</td><td>-32768到32767</td></tr><tr><td>字符型(本质是特殊的整形数值)</td><td>char</td><td>2byte</td><td>0到65535(\u0000到\uffff)</td></tr><tr><td>整型</td><td>int</td><td>4byte</td><td>正负21亿</td></tr><tr><td>长整型</td><td>long</td><td>8byte</td><td>非常大</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4byte</td><td>1.4E到3.4E38</td></tr><tr><td>双精度浮点数</td><td>double</td><td>8byte</td><td>4,9E到1.79E308</td></tr><tr><td>布尔型</td><td>boolean</td><td>一般为1byte(因为计算机程序的最小操作单位为byte)</td><td>true和false</td></tr></tbody></table><p>long赋值时一定要在最后加L或l</p><p>浮点数赋值时,如果是float要加F或f(double不用, 默认)</p><p>字符串不属于基本数据类型</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sql学习</title>
    <link href="/2022/11/08/sql%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/08/sql%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>sql命令:</p><table><thead><tr><th>sql命令</th><th>作用</th></tr></thead><tbody><tr><td>union</td><td>用于合并两个查询的记录, 要求两个查询的列数相同, 数据类型相同(一般是同一个表结构), 会去除重复记录</td></tr><tr><td>union all</td><td>与union类似, 但是保留重复记录</td></tr></tbody></table><h1 id="SQL游标"><a href="#SQL游标" class="headerlink" title="SQL游标"></a>SQL游标</h1><p>cursor(游标)是一个缓存区, 用于存放sql执行结果</p><p>通过游标名可以提取出记录并进行变量赋值操作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PLSQL学习</title>
    <link href="/2022/11/08/PLSQL%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/08/PLSQL%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="PL-x2F-SQL学习"><a href="#PL-x2F-SQL学习" class="headerlink" title="PL&#x2F;SQL学习"></a>PL&#x2F;SQL学习</h1><p>PLSQL是Oracle基于SQL的基础上发展的一门过程语言</p><blockquote><p>PLSQL原理</p></blockquote><p><img src="/2022/11/08/PLSQL%E5%AD%A6%E4%B9%A0/image-20221020170333055.png" alt="image-20221020170333055"></p><p>PLSQL会引擎被编译为字节码, 并分为过程语句和SQL语句, SQL语句交给数据库SQL引擎执行, PLSQL会同时运行过程元素</p><blockquote><p>PLSQL关键字</p></blockquote><table><thead><tr><th>关键字</th><th>解释</th></tr></thead><tbody><tr><td>as</td><td>作为开头</td></tr><tr><td>is</td><td>等同于AS</td></tr><tr><td>end</td><td>作为结束</td></tr><tr><td>in</td><td>作为入参</td></tr><tr><td>out</td><td>作为出参</td></tr><tr><td>savepoint</td><td>创建事务的回滚点</td></tr></tbody></table><blockquote><p>PLSQL数据类型</p></blockquote><table><thead><tr><th>数据类型</th><th>解释</th></tr></thead><tbody><tr><td>varchar</td><td>ANSI编码字符串</td></tr><tr><td>varchar2</td><td>oracle编码字符串</td></tr></tbody></table><blockquote><p>PLSQL运算符</p></blockquote><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>:&#x3D;</td><td>赋值</td></tr><tr><td>&#x3D;</td><td>判断相等</td></tr><tr><td>||</td><td>字符串拼接</td></tr></tbody></table><blockquote><p>函数</p></blockquote><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>chr(ASCII码)</td><td>将ASCII码转为字符串</td></tr></tbody></table><p>常用ASCII码</p><table><thead><tr><th>ASCII</th><th>特殊字符</th></tr></thead><tbody><tr><td>9</td><td>制表符</td></tr><tr><td>10</td><td>换行符</td></tr><tr><td>13</td><td>回车符</td></tr><tr><td>32</td><td>空格</td></tr><tr><td>34</td><td>双引号</td></tr></tbody></table><blockquote><p>命令</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>desc table</td><td>显示表的字段</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sql优化</title>
    <link href="/2022/11/08/sql%E4%BC%98%E5%8C%96/"/>
    <url>/2022/11/08/sql%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h1><p>sql优化主要是建立索引以及防止索引失效</p><p>索引:</p><p>优势: </p><ol><li>加快查询速度</li><li>加快表连接速度</li><li>加快分组和查询的时间</li><li>唯一索引可以保证数据的唯一性</li></ol><p>缺点:</p><ol><li>索引的建立需要耗费时间, 每次对索引字段进行修改后, 索引需要重新生成</li><li>索引占用物理空间, 聚簇索引需要更大的物理空间</li></ol><p>innodb引擎使用B+树作为索引的数据结构</p><p>B+树特点:</p><ol><li>针对物理磁盘的存储特性设计优化</li><li>真实数据存储在叶子节点上(非叶子节点作为索引)</li></ol><p>聚簇索引也被称为主键索引&#x2F;一级索引</p><p>非聚簇索引被称为辅助索引&#x2F;二级索引</p><p>聚簇索引: 使用主键构造B+树, 在叶子节点中存放整张表的记录</p><p>非聚簇索引: 叶子节点中存放键值和主键索引值</p><p>索引字段的一般特性:</p><ol><li>唯一性</li><li>频繁作为查询条件(where)</li><li>不能更新频繁</li><li>用于分组&#x2F;排序(group&#x2F;sort)</li></ol><p>索引设计原则:</p><ol><li>where group sort都会使用到索引, 适合建立索引</li><li>组合索引要利用最左原则, 避免创建重复索引</li><li>最左原则中,范围查找会导致后面的列索引失效, 因此需要尽量将范围查找的列放在后面</li><li>不要盲目创建单列索引, 可以用组合索引进行覆盖</li><li>前缀索引(短索引)应该指定前缀长度, 因为like前导模糊不支持索引</li><li>字符串反转再建立前缀索引可以作为后缀索引使用</li></ol><p>sql优化项:</p><ol><li>执行优先级 on&gt;where&gt;having</li><li>避免对索引列进行运算&#x2F;函数</li><li>避免在sql中进行类型转换,导致索引有可能失效</li><li>使用中间表存储历临时结果, 降低主表压力</li><li>避免使用is null和is not null, 避免索引失效,字段除了字符串类型都要设置默认值</li><li>避免笛卡尔积中小表驱动大表</li><li>更新&#x2F;删除数据时进行拆分操作,分段执行, 降低服务器压力和主从延时</li></ol><p>正式业务场景要注意:</p><ol><li>熟悉业务, 在功能和性能中取得平衡点</li><li>空间提高时间效率: 缓存, 中间表</li><li>牺牲实时性: 功能拆分 异步操作 队列</li><li>分库分表: 垂直&#x2F;水平拆分</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线上Bug分析</title>
    <link href="/2022/11/07/%E7%BA%BF%E4%B8%8ABug%E5%88%86%E6%9E%90/"/>
    <url>/2022/11/07/%E7%BA%BF%E4%B8%8ABug%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="线上Bug分析"><a href="#线上Bug分析" class="headerlink" title="线上Bug分析"></a>线上Bug分析</h1><blockquote><p>时间问题</p></blockquote><ol><li>weblogic10升级到weblogic12会导致时间日期的类型问题(10不带时分秒, 12会保留时分秒), 导致时间校验出现问题</li><li>mybatis3.5.0升级到3.5.8, varchar转换为LocalDate会抛异常</li></ol><p> 改进方法:</p><ol><li>统一时间格式, 日期判断使用年月日格式进行判断</li><li>慎用传参&#x2F;sysdate</li><li>进行服务器&#x2F;ORM版本升级时, 测试系统重要功能, 保证接口功能正常</li></ol><p>其他知识:</p><ol><li>sql中操作日期用函数操作</li><li>尽量少用System.currentTimeMillis(), 会导致系统消耗高</li><li>日期格式用yyyy-MM-dd, 避免用YYYY(周基年), 会导致当周跨年</li><li>Calendar和SimpleDateFormat的format parse方法都是线程不安全的, 尽量使用LocalDateTime和DateTimeFormatter</li></ol><blockquote><p>数据精度问题</p></blockquote><ol><li>浮点数(二进制)转换为整数型(十进制)时会发生精度丢失</li><li>浮点数表示大数时会使用科学计数法, 只表示近似数, 也会有精度丢失</li></ol><p>解决方法:</p><ol><li>金额计算使用BigDecimal</li><li>精度计算的参数使用String类型储存</li></ol><p>其他知识:</p><ol><li>浮点数转换为BigDecimal时, 先转为string再使用BigDecimal.valueOf转换, 避免精度丢失</li><li>BigDecimal进行除法时如果有余数, 会抛出异常,需要多传两个参数取余数出来</li></ol><blockquote><p>死循环问题</p></blockquote><ol><li>对入参未作校验, 导致循环参数出问题</li><li>循环过程中发生异常时候try catch却没有做任何处理</li></ol><p>解决方法:</p><ol><li>调用外部接口对入参进行校验(如非空)</li><li>循环逻辑确保一定能跳出去</li><li>循环中捕获到异常要做break处理</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js</title>
    <link href="/2022/11/03/Vue/"/>
    <url>/2022/11/03/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>Vue是一个开源的前端框架</p><p>特点:</p><ol><li>大量的语法糖简化开发流程</li><li>语法与js区别非常大</li><li>更新迭代非常快</li><li>遵循MVVM架构模式</li><li>支持单页面(应用)开发</li><li>支持渐进式开发</li><li>支持视图组件式开发</li><li>支持虚拟DOM(将DOM节点树创建内存中的副本)</li></ol><p><strong>MVVM</strong></p><p>MVVM: Model View ViewModel三部分</p><p>(模型-视图-视图模型)</p><p><img src="/2022/11/03/Vue/image-20220617155751495.png" alt="image-20220617155751495"></p><p>各部分的作用:</p><ol><li>Model代表数据, 数据来自后端或者用户输入</li><li>View代表网页, 通过网页展示数据</li><li>ViewModel: 用于绑定网页和数据(双向绑定)</li></ol><p><img src="/2022/11/03/Vue/image-20220617154952517.png" alt="image-20220617154952517"></p><p>如何使用Vue开发网页:</p><ol><li>直接在网页中导入Vue.js</li><li>使用Vue-cli脚手架开发</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/* 完成：视图  和   数据之间的绑定 */</span></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">data : &#123;<span class="hljs-attr">msg</span>:<span class="hljs-string">&quot;Hello World!&quot;</span>&#125;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>            &#123;&#123;msg&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure> : 动态渲染视图,类似于jsp中的占位符<p>Vue提供了大量的预定义元素属性, 可以实现在html中进行动态编程</p><p>重要元素属性:</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>v-for&#x3D;”(item, index) in list”</td><td>循环</td></tr><tr><td>v-bind:属性&#x3D;”变量”</td><td>用于在标签属性中引入动态的变量</td></tr><tr><td>:属性&#x3D;”变量”</td><td>v-bind:属性的简写</td></tr><tr><td>v-model&#x3D;”变量”</td><td>用于将元素的value和变量进行双向绑定</td></tr><tr><td>v-on:事件&#x3D;”函数”</td><td>将函数绑定事件</td></tr><tr><td>@事件&#x3D;”函数”</td><td>v-on的简写</td></tr><tr><td>v-if&#x3D;”条件表达式”</td><td>用于进行条件判断</td></tr><tr><td>v-else</td><td>多分支条件语句</td></tr><tr><td>v-else-if</td><td>多分支条件语句</td></tr></tbody></table><p>Vue中给html元素提供了特殊属性ref, 可以直接通过this.$refs.ref值来获取元素的直接引用, 相当于js中的getDocumentBy</p><p>当ref在v-for循环中使用时, 获取的元素集合顺序不一定与html中对应</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Vue的生命周期有4个阶段: 创建挂载更新销毁</p><p>Vue提供了8种Hook函数对应4种生命周期之前和之后</p><p>Hook函数会在对应的生命周期自动执行</p><table><thead><tr><th>Hook函数</th><th>顺序</th></tr></thead><tbody><tr><td>beforeCreate()</td><td>在new Vue(构造器)之前执行</td></tr><tr><td>created()</td><td>在构造器后执行</td></tr><tr><td>beforeMount()</td><td>DOM挂载之前执行</td></tr><tr><td>mounted()</td><td>DOM挂载后执行</td></tr><tr><td>beforeUpdate()</td><td>vm(虚拟DOM)更新视图之前</td></tr><tr><td>updated()</td><td>vm更新视图后</td></tr><tr><td>beforeDestory()</td><td>Vue实例被销毁前</td></tr><tr><td>destory()</td><td>Vue实例被销毁后</td></tr></tbody></table><p>其中mounted()等同于js中的onload函数</p><blockquote><p>一般使用created()函数用于初始化函数</p></blockquote><p><strong>this关键字</strong></p><p>vue中方法可以通过this关键字调用vue对象的实例成员: 实例方法和实例属性</p><blockquote><p>在js中this关键字默认绑定window对象</p></blockquote><h2 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h2><p>Vue有4种方式对数据进行处理</p><ol><li>在html中用行内js直接运算</li><li>调用methods中定义的函数进行计算</li><li>wath属性</li><li>computed属性</li></ol><p>computed属性和methods都可以定义函数,区别在于</p><p>computed定义的函数通过函数名调用不需要加()</p><p>methods定义的函数通过函数名()调用</p><p>computed提供了属性缓存机制, 只有当其返回值的依赖项发生变化时才会重新计算结果值并缓存起来, 当依赖项没有改变时会直接返回缓存的值</p><p>如果使用methods定义的函数返回值作为展示, 将会不停的计算最新值</p><h2 id="Vue类方法"><a href="#Vue类方法" class="headerlink" title="Vue类方法"></a>Vue类方法</h2><p>Vue中提供了大量的api方法提高编程效率</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Vue.set(对象,”属性”,”属性值”)</td><td>为对象添加新的属性和属性值或者修改已有的属性的属性值</td></tr><tr><td>Vue.delete(对象,”属性”)</td><td>将对象的某个属性删除</td></tr><tr><td>Vue.filter(“过滤器名称”,function(参数){代码块})</td><td>定义一个全局过滤器</td></tr><tr><td>filters:{过滤器名称:function(参数){}}</td><td>定义一个局部过滤器</td></tr><tr><td>this.$nextTick(lambda表达式)</td><td>在挂载成功后执行对应的代码</td></tr></tbody></table><p>过滤器通常用于对数据进行处理(直接修改数据本身)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//调用过滤器</span><br>&#123;&#123;<span class="hljs-attr">name</span>:filter&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="component开发"><a href="#component开发" class="headerlink" title="component开发"></a>component开发</h2><p>component:组件开发</p><p>组件是Vue最强大的功能之一</p><p>使用组件可以将app的界面抽象为组件树并进行组件化开发(封装代码和降低代码耦合性)</p><p>组件分为全局组件(可以被任意Vue对象使用)和局部组件(只能被所属的Vue对象使用)</p><blockquote><p>全局组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--通过标签调用组件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">//定义一个全局组件</span></span><br><span class="language-xml"><span class="language-handlebars">Vue.component(&quot;hello&quot;,&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">    //组件一般和template组合使用</span></span><br><span class="language-xml"><span class="language-handlebars">    template:`</span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">hello02</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello02</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    `</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;);</span></span><br><span class="language-xml"><span class="language-handlebars">new Vue(&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">    //选择器绑定</span></span><br><span class="language-xml"><span class="language-handlebars">    el:&#x27;#app&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">    //定义局部选择器</span></span><br><span class="language-xml"><span class="language-handlebars">    components:&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">        &#x27;hello02&#x27;:&#123;</span></span><br><span class="language-xml"><span class="language-handlebars">            template:`</span></span><br><span class="language-xml"><span class="language-handlebars">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-comment">&lt;!--组件嵌套--&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">hello02</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello02</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    `</span></span><br><span class="language-xml"><span class="language-handlebars">        &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">    &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">&#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="库跟框架的概念"><a href="#库跟框架的概念" class="headerlink" title="库跟框架的概念"></a>库跟框架的概念</h2><p>库: Librarys, 本质上是提供了一系列的方法来调用</p><p>如jQuery是将js的方法进行封装, 使编程的效率更高</p><p>框架: 框架包含了各种库, 并且在框架内必须按照框架的特殊语法来写代码</p><p>区别: 我们可以在写js时调用库中的方法来提供编程效率, 而使用库时本质上不是在写js代码而是在写特定库的代码</p><p>前端目前最流行的三个库:</p><ol><li>Angular</li><li>React</li><li>Vue.js</li></ol><p><strong>Vue构造器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Vue构造器</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;属性以及方法&#125;)<br><span class="hljs-comment">//component构造器</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;组件名&quot;</span>,&#123;属性以及方法&#125;);<br></code></pre></td></tr></table></figure><p>Vue构造器的属性和方法有:</p><table><thead><tr><th>属性或方法</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>el:</td><td>“元素选择器”</td><td>绑定对应的元素作为Vue对象</td></tr><tr><td>data(){}</td><td>return{变量:变量值}</td><td>声明Vue对象成员变量</td></tr><tr><td>methods:{}</td><td>方法名: function(参数){方法体}</td><td>声明Vue对象成员方法</td></tr></tbody></table><p>Vue.component构造器的属性和方法有:</p><table><thead><tr><th>属性或方法</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>template:</td><td>`html代码`</td><td>网页组件</td></tr><tr><td>data(){}</td><td>return{变量:变量值}</td><td>声明组件成员变量</td></tr><tr><td>methods:{}</td><td>方法名: function(参数){方法体}</td><td>声明组件成员方法</td></tr></tbody></table><p><strong>Vue自定义的js必须在绑定的标签后引入, 否则会发生element  not found的错误</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;自定义的js.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式(闭包)</title>
    <link href="/2022/11/03/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E9%97%AD%E5%8C%85)/"/>
    <url>/2022/11/03/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E9%97%AD%E5%8C%85)/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda-闭包"><a href="#Lambda-闭包" class="headerlink" title="Lambda(闭包)"></a>Lambda(闭包)</h1><p><strong>Lambda表达式是Java中的函数式编程特性</strong></p><blockquote><p>函数式编程是指将函数作为基本运算单位, 意味着函数可以作为变量来使用(接收函数, 返回函数)</p></blockquote><p>Lambda是Java8的一个重大更新</p><p>Lambda表达式相当于创建了一个匿名方法</p><p>Lambda只能用来实现单方法接口的实例化(一个接口中只有一个方法)</p><p>lambda表达式的有点:</p><ol><li>可以简化匿名内部类的代码, 减少生成内部类文件</li><li>将函数作为变量传递, 为Java提供了函数式编程的支持</li></ol><p>lambda可以用于替代匿名内部类对象</p><blockquote><p>只有一个抽象方法的接口被称为函数式接口</p></blockquote><p>lambda表达式允许将代码块作为实参传给一个方法</p><p>Lambda表达式有三部分:</p><ol><li><p>形参列表</p></li><li><p>箭头(-&gt;) </p></li><li><p>代码块</p><p>**代码块必须包含return语句)</p><blockquote><p>当lambda表达式的代码块只有一条语句时, 会将该语句返回值自动return</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>;<br><span class="hljs-comment">//    void test();</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test15</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Hello h=(num)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;;<br>    &#125;<br>    <span class="hljs-comment">//省略写法, 也是语法正确的</span><br>    Hello h=num -&gt; System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">//注意当没有形参时, 不可以省略圆括号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码用lambda实现了一个接口的实例化</p><p><strong>Lambda表达式所创建的对象的目标类型(target type)为函数式接口( functional interface)</strong></p><p>函数式接口: 一个接口只能有一个抽象方法, 但是可以包含多个默认方法 类方法 私有方法</p><blockquote><p>Java8中为函数式接口提供了注解@FunctionalInterface</p><p>该注解放在接口声明之前, 用于提示编译器检查该接口必须是函数式接口, 如果不是的话会造成编程报错</p></blockquote><p>Lambda表达式的限制条件:</p><ol><li>目标必须是函数式接口类型</li><li>一个Lambda表达式只能实现一个方法, 只能为函数式接口创建对象</li><li>Lambda表达式的形参列表必须与该函数</li></ol><p>常见使用场景:</p><ol><li><p>将lambda表达式赋值给函数接口类型的变量</p></li><li><p>将lambda作为函数式接口类型的参数传给一个方法</p></li><li><p>将lambda表达式进行强制转换为函数接口类型后再使用</p><blockquote><p>如传给Object类型引用变量</p></blockquote></li></ol><p>Java8在java.util.function包中提供了大量预定义的函数接口</p><p>4类典型的接口:</p><ol><li>XxxFunction</li><li>XxxConsumer</li><li>XxxPredicate</li><li>XxxSupplier</li></ol><h2 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h2><p>lambda表达式有更加简洁的写法</p><table><thead><tr><th>种类</th><th>示例</th><th>对应的表达式</th><th>说明</th></tr></thead><tbody><tr><td>类方法</td><td>类名::类方法</td><td>() -&gt; class.staticMethod()</td><td></td></tr><tr><td>实例方法</td><td>对象::实例方法</td><td>() -&gt; 对象.noStaticMethod()</td><td></td></tr><tr><td></td><td>类名::实例方法</td><td>(b,….) -&gt; a.noStaticMethod(b,…)</td><td></td></tr><tr><td>引用构造器</td><td>类名::new</td><td>() -&gt; new Class()</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello2</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">helloHo</span><span class="hljs-params">(Ho a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ho</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Ho</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> i1)</span> &#123;&#125;<br><br>    Ho() &#123;&#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;&#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticHello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test16</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Ho</span> <span class="hljs-variable">ho</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ho</span>();<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> (a, b) -&gt; Ho.staticHello(a, b);<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h6</span> <span class="hljs-operator">=</span> Ho::staticHello;<br>        <span class="hljs-comment">//类方法</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h3</span> <span class="hljs-operator">=</span> (a, b) -&gt; ho.hello(a, b);<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h7</span> <span class="hljs-operator">=</span> ho::hello;<br>        <span class="hljs-comment">//特定对象的实例方法</span><br>        Hello2 h8=(a,b,c)-&gt;a.hello(b,c);<br>        Hello2 h9=Ho::hello;<br>        <span class="hljs-comment">//某类对象的实例方法</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h4</span> <span class="hljs-operator">=</span> (a, b) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ho</span>(a, b);<br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">h5</span> <span class="hljs-operator">=</span> Ho::<span class="hljs-keyword">new</span>;<br>        <span class="hljs-comment">//引用构造器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>lambda和匿名内部类有相同之处:</p><ol><li>两者都可以直接访问接口中默认被final修饰的变量</li><li>两者对应的实例都可以调用接口中继承的默认方法</li></ol><p>两者的区别:</p><ol><li>匿名内部类可以为任何接口 抽象类 普通类创建实例, lambda表达式只能创建函数接口的实例</li><li>匿名内部类的代码块可以调用接口的默认方法, lambda表达式的代码块不能调用默认方法</li></ol><p>在Arrays类中的有些类方法需要Comparator, XxxOperator, XxxFunction等函数接口的实例, 可以用lambda表达式来实现, 使代码更简洁</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Steam</title>
    <link href="/2022/11/03/Steam/"/>
    <url>/2022/11/03/Steam/</url>
    
    <content type="html"><![CDATA[<h1 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h1><p>Java8中有两个最关键的新特性: lambda表达式(语法糖) Stream API(java.util.stream.*)</p><p>使用Stream(流)API可以对集合进行操作</p><p>Stream的特性:</p><ol><li>本身不存储数据, </li><li>不对源数据进行修改, 用新对象存储返回结果</li><li>延迟执行操作, 等需要结果时才执行操作</li></ol><p>Steam工作步骤:</p><ol><li>创建Stream</li><li>中间操作</li></ol><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>java8提供了内置的4种函数式接口, Consumer Function Predicate Supplier</p><blockquote><p>这四种函数式接口都位于java.util.function包下</p></blockquote><p>语法糖: 语法糖是指编程语言为了提高编程效率, 提供了使用更方便的编程语法</p><p>lambda表达式可以视为实现匿名内部类的语法糖</p><p>使用@FunctionalInterface注解可以声明一个接口为函数式接口, 编译器会检查该接口是否满足函数式接口的条件(只有一个抽象方法)</p><table><thead><tr><th>名称</th><th>内置函数接口</th><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>消费型接口</td><td>Cosumer</td><td>void accept(T t)</td><td>对传入泛型对象进行操作</td></tr><tr><td>供给型接口</td><td>Supplier</td><td>T get()</td><td>返回一个泛型对象</td></tr><tr><td>函数型接口</td><td>Function</td><td>R apply(T t)</td><td>对泛型T对象进行操作, 并返回泛型R对象</td></tr><tr><td>断言型接口</td><td>Predicate</td><td>boolean test(T t)</td><td>对传入的泛型对象判断是否满足约束, 返回布尔值</td></tr></tbody></table><blockquote><p>Stream流可以通过使用java8内置的4种函数接口, 实现各种流操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        List&lt;User&gt; userList = Lists.newArrayList();<br>        <span class="hljs-comment">//lambda表达式</span><br>        userList.stream()<br>                .filter(user -&gt; user.getAge() &gt; <span class="hljs-number">18</span>)<br>                .map(User::getName)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2022/11/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/11/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p><strong>网络编程三要素: IP地址端口号通信协议</strong></p><ol><li>IP地址</li></ol><p>IP地址分为内网IP和公网IP两种</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//windows查看本机IP地址命令<br>ipconfig ipconfig -all<br>//Linux查看本机IP地址命令<br>ifconfig<br>//使用ICMP协议来测试目标IP是否可以访问<br>ping 8.8.8.8<br></code></pre></td></tr></table></figure><ol start="2"><li>端口</li></ol><p>计算机的每个端口都对应一个进程</p><p>同一个端口不能被两个进程同时占用, 会产生端口冲突</p><p><strong>端口号取值范围 0-65535(16位)</strong></p><p>端口号通常被分为三类:</p><table><thead><tr><th>分类</th><th>端口范围</th><th>解释</th></tr></thead><tbody><tr><td>公认端口</td><td>0~1023</td><td>绑定系统服务</td></tr><tr><td>注册端口</td><td>1024~49151</td><td>程序可以自定义使用端口</td></tr><tr><td>动态端口(私有端口)</td><td>49152~65535</td><td>应用程序动态使用的端口(自动分配的端口)</td></tr></tbody></table><blockquote><p>一般系统的默认端口为0~1024</p><p>常见程序端口: 22(SSH) 8080(Tomcat) 80(Nginx) 3306(Mysql)</p></blockquote><ol start="3"><li>通信协议</li></ol><p>常见通信协议: TCP&#x2F;IP协议 UDP协议</p><p><strong>网络模型</strong></p><blockquote><p>OSI 7层模型</p></blockquote><table><thead><tr><th>分层</th><th>示例</th></tr></thead><tbody><tr><td>应用层</td><td></td></tr><tr><td>表示层</td><td></td></tr><tr><td>会话层</td><td></td></tr><tr><td>传输层</td><td></td></tr><tr><td>网络层</td><td></td></tr><tr><td>数据链路层</td><td></td></tr><tr><td>物理层</td><td></td></tr></tbody></table><blockquote><p>TCP&#x2F;IP经典模型</p></blockquote><table><thead><tr><th>分层</th><th>示例</th></tr></thead><tbody><tr><td>应用层</td><td></td></tr><tr><td>传输层</td><td></td></tr><tr><td>网络层</td><td></td></tr><tr><td>物理+数据链路层</td><td></td></tr></tbody></table><p>IP地址用于标识网络中的通信实体(主机)</p><p>IPv4的IP地址有32位(4个字节), 为了方便记忆, 通常会将其转为10进制</p><blockquote><p>例如: 127.0.0.1</p><p>IP地址范围:0.0.0.0~255.255.255.255</p></blockquote><p>IP地址由NIC负责规划和管理</p><p>分为五类</p><blockquote><p>注意ABC类地址还分为公有地址和私有地址</p><p>但是D类和E类都是私有地址</p></blockquote><table><thead><tr><th>分类</th><th>公有地址</th><th>掩码</th></tr></thead><tbody><tr><td>A类</td><td>1.0.0.0~127.0.0.0</td><td>255.0.0.0</td></tr><tr><td>B类</td><td>128.0.0.0~191.255.0.0</td><td>255.255.0.0</td></tr><tr><td>C类</td><td>192.0.0.0~233.255.255.0</td><td>255.255.255.0</td></tr></tbody></table><table><thead><tr><th>分类</th><th>私有地址范围</th></tr></thead><tbody><tr><td>A类</td><td>10.0.0.0  ~  10.255.255.255</td></tr><tr><td>B类</td><td>172.16.0.0  ~  172.31.255.255</td></tr><tr><td>C类</td><td>192.168.0.0  ~  192.168.255.255</td></tr><tr><td>D类</td><td>224.0.0.0~239.255.255.255</td></tr><tr><td>E类</td><td>240.0.0.0~255.255.255.255</td></tr></tbody></table><h1 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><blockquote><p>TCP全称Transmission Control Protocal(传输控制协议)</p><p>UDP全称User Datagram Protocol(用户数据报文协议)</p></blockquote><p>TCP的应用非常普遍(因为TCP提供了可靠性)</p><p>UDP的应用比较少(因为UDP无法提供可靠性)</p><p>TCP&#x2F;IP协议本身是一个协议栈(protocol stack)</p><p><img src="/2022/11/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220523142153228.png" alt="image-20220523142153228"></p><p>TCP协议是应用层服务, IP协议是网络层服务</p><table><thead><tr><th>TCP特性</th><th>解释</th></tr></thead><tbody><tr><td>TCP可以用来完成进程间通信</td><td>通过端口号绑定进程, TCP可以进行进程与进程间的通信</td></tr><tr><td>TCP是面向流的</td><td>TCP将数据转换为字节流进行发送和接收(UDP是将数据直接按位切割成数据包(datagrams or packets), 并非字节流)</td></tr><tr><td>TCP是双全工通信</td><td>双方向通信m</td></tr><tr><td>TCP是面向连接的</td><td>面向连接三阶段:建立连接  传输数据  结束连接  (UDP是无连接的)</td></tr><tr><td>TCP是可靠的</td><td>TCP有数据校验机制来确保数据包是完整并且正确传输的, 并且可以通过确认策略和计时器来恢复损坏数据包.  发现错误时会重新传输出错位置的数据段</td></tr><tr><td>TCP可以实现多路复用</td><td>通过端口号建立多个逻辑链路(端口号只是一个软件逻辑, 并非物理链路) 一个物理链路的发送方和接收方会分别执行多路复用和解复用</td></tr></tbody></table><blockquote><p>TCP将许多字节组成一个数据段, 每个数据包都有</p></blockquote><blockquote><p>数据校验机制: 字节号 序列号 确认号</p></blockquote><blockquote><p>TCP使用拥塞控制机制来确保传输</p></blockquote><p>TCP协议特点:</p><ol><li>面向连接, 依赖连接</li><li>三次握手建立连接, 四次挥手断开连接</li><li>连接建立后可以进行双向通信(全双工通信)</li></ol><p><strong>TCP协议建立连接需要经历三次握手,四次挥手</strong></p><p>三次握手:</p><ol><li>客户端发送请求给服务器, 请求建立连接</li><li>服务端发送响应给客户端, 同意建立连接</li><li>客户端发送响应, 正式建立连接</li></ol><p>三次握手(记忆):</p><table><thead><tr><th>简略</th><th>详细</th><th>方向</th></tr></thead><tbody><tr><td>SYN</td><td>SYN&#x3D;1(用于同步)  Seq&#x3D;x(当前报文第一个字节的字节号)</td><td>客户端发给服务端</td></tr><tr><td>SYN+ACK</td><td>SYN&#x3D;1(用于同步)Seq&#x3D;y(新的字节号) ACK&#x3D;x+1(确认已经收到了之前的Seq&#x3D;x信息)</td><td>服务端发给客户端</td></tr><tr><td>ACK</td><td>ACK&#x3D;y+1(表示收到了之前的Seq&#x3D;y信息)两次ACK代表连接已经被双方都确认了, 成功建立TCP连接</td><td>客户端发给服务端</td></tr></tbody></table><p><img src="/2022/11/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220523162208324.png" alt="image-20220523162208324"></p><p>详细步骤:</p><table><thead><tr><th>步骤</th><th>详细</th></tr></thead><tbody><tr><td>SYN</td><td>客户端发送了包含SYN的报文段, 告知服务器 通信时间和报文中开头的序列号</td></tr><tr><td>SYN+ACK</td><td>服务端发送SYN+ACK信号位响应, ACK确认了上次接收的报文段, SYN表示报文开头的序列号</td></tr><tr><td>ACK</td><td>客户端发送ACK确认服务器的响应, 表示连接已经建立好</td></tr></tbody></table><p>四次挥手:</p><ol><li>客户端发送请求给服务端, 请求端口连接(注意客户端和服务器都是相对而言, 仅代表发送角色和接收角色)</li><li>服务端发送响应给客户端, 说明在处理中</li><li>服务器再次发送响应给客户端, 说明已经处理好, 可以断开连接</li><li>客户端断开连接</li></ol><p>UDP协议是无连接, 可以点对多(广播)的协议</p><p>不可靠, 适合用于实时性要求高的服务</p><blockquote><p>DNS服务(域名解析服务)属于UDP协议</p></blockquote><p>TCP&#x2F;IP协议是面向连接的, 只能点对点,</p><p>可靠性高, 适合对传输的可靠性要求高的服务</p><p><strong>TCP头(header)</strong></p><blockquote><p>TCP数据段(Segment)结构</p></blockquote><p><img src="/2022/11/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220523143928334.png" alt="image-20220523143928334"></p><p>TCP数据段包括header和要发送的数据字节信息</p><p>TCP的header有20到60个字节, 默认为20个字节, 最多可以有60个字节大小</p><table><thead><tr><th>Header字段</th><th>作用</th><th>大小</th></tr></thead><tbody><tr><td>源端口地址</td><td>发送端进程的端口地址</td><td>2个字节</td></tr><tr><td>目标端口地址</td><td>接收端进程的端口地址</td><td>2个字节</td></tr><tr><td>序列编号(Sequence Number)</td><td>保存第一个字节的字节号</td><td>4个字节</td></tr><tr><td>确认编号(Acknowledgement Number)</td><td>代表接收方希望接收到的接下来信息, 代表了对已接受到的信息的确认</td><td>4个字节</td></tr><tr><td>报头长度(Header Length)</td><td>表示header的长度, (5~15代表20 ~60长度)</td><td>4位</td></tr><tr><td>控制标志(Control flags)</td><td>有6个控制位, 用于控制TCP连接的建立和结束</td><td>6位</td></tr><tr><td>Windows Size</td><td>缓冲容量</td><td></td></tr><tr><td>校验和</td><td></td><td></td></tr><tr><td>紧急指针</td><td></td><td></td></tr></tbody></table><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>套接字(Socket)是对网络通信的端点的抽象</p><blockquote><p>接收端和发送端分别是一个套接字</p></blockquote><p>两个Socker可以建立点对点的数据传输</p><blockquote><p>通常编程中不会要求手写套接字编程, 会有框架来提供已经写好的方法</p></blockquote><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库分为SQL数据库和NO-SQL数据库两种</p><table><thead><tr><th>SQL数据库</th><th>NO-SQL数据库</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>脱O oracle转mysql</title>
    <link href="/2022/11/03/%E8%84%B1O%20oracle%E8%BD%ACmysql/"/>
    <url>/2022/11/03/%E8%84%B1O%20oracle%E8%BD%ACmysql/</url>
    
    <content type="html"><![CDATA[<h1 id="脱O-oracle转mysql"><a href="#脱O-oracle转mysql" class="headerlink" title="脱O oracle转mysql"></a>脱O oracle转mysql</h1><p>重构步骤:</p><ol><li>单体程序重构为微服务</li><li>plsql的pkg代码重构<ol><li>实时逻辑代码用Java重写</li><li>离线批处理逻辑用Hive Sql(佣金)重写</li></ol></li><li>ARK化: Java代码全面微服务化</li><li>涉及业务: 人事&#x2F;考核&#x2F;荣誉&#x2F;风险</li><li>Oracle数据转存到Mysql</li></ol><p>人力成本: 100人年</p><p>微服务改造: 20人年</p><p>pkg转Java: 74人年</p><p>pkg转Hive: 6人年</p><p>收益:</p><ol><li>降低软硬件成本</li><li>提升代码可维护性</li><li>缩短需求周期</li></ol><p>风险:</p><ol><li>重构影响系统稳定性</li><li>重构期间的人力&#x2F;软硬件成本</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>软件设计原则</strong></p><p>常用的面向对象(软件)设计原则有7个</p><table><thead><tr><th>设计原则</th><th>缩写</th><th>要求</th></tr></thead><tbody><tr><td>开闭原则</td><td>OCP</td><td>扩展开发, 修改关闭</td></tr><tr><td>单一职责原则</td><td>SRP</td><td>一个类负责一个业务职责</td></tr><tr><td>里氏替换原则</td><td>LSP</td><td>基类可以透明使用其子类的对象</td></tr><tr><td>依赖倒置原则</td><td>DIP</td><td>依赖对象, 不依赖具体实现</td></tr><tr><td>接口隔离原则</td><td>ISP</td><td>类之间的依赖建立在最小接口上</td></tr><tr><td>合成&#x2F;聚合复用原则</td><td>ARP&#x2F;ORP</td><td>尽量使用合成&#x2F;聚合代替继承实现复用</td></tr><tr><td>最少知识原则</td><td>LKP</td><td>一个实体类应该尽量减少与其他实体类的依赖&#x2F;影响</td></tr></tbody></table><p>设计模式是什么:</p><p>设计模式（Design Pattern）代表软件开发的最佳实践， 是软件开发中会遇到的一般问题的解决方案、经验总结</p><p>设计模式分为三大类： 创建型模式 结构型模式 行为型模式</p><blockquote><p>设计模式分类</p></blockquote><p><img src="/2022/11/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220927190827597.png" alt="image-20220927190827597"></p><p><strong>常见的设计模式有:</strong></p><ol><li>工厂模式<ol><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ol></li><li>单例模式</li><li>适配器模式</li><li>代理模式</li><li>观察者模式</li><li>装饰器模式</li><li>责任链模式</li><li>策略模式</li></ol><p>重点： 工厂模式 单例模式 代理模式（AOP）</p><p><strong>Spring中用到了哪些设计模式</strong></p><table><thead><tr><th>设计模式</th><th>应用场景</th></tr></thead><tbody><tr><td>工厂模式</td><td>通过BeanFactory，ApplicationContext创建Bean对象（Bean工厂）</td></tr><tr><td>代理模式</td><td>通过AOP实现</td></tr><tr><td>单例模式</td><td>Spring中所有的Bean都是默认单例</td></tr><tr><td>模板模式</td><td>Spring框架提供了jdbcTemplate RedisTemplate等类用于操作数据库（还有MinIOTemplate  RabbitTemplate）</td></tr><tr><td>适配器模式</td><td>MVC的Controller, AOP的增强或通知（Advice）用到了适配器模式</td></tr><tr><td>观察者模式</td><td>Spring事件驱动模式</td></tr><tr><td>包设计模式</td><td>多个数据库的动态切换</td></tr></tbody></table><p><strong>JDK中用到了哪些设计模式</strong></p><p>最常用的有</p><ol><li>工厂模式<ol><li>java.lang.Proxy#newProxyInstance() </li><li>java.lang.Object#toString() </li><li>java.lang.Class#newInstance()</li><li>java.lang.reflect.Array#newInstance() </li><li>java.lang.reflect.Constructor#newInstance() </li><li>java.lang.Boolean#valueOf(String) </li><li>java.lang.Class#forName()</li></ol></li><li>代理模式<ol><li>java.util.Calendar#getInstance() </li><li>java.util.Arrays#asList() </li><li>java.util.ResourceBundle#getBundle() </li><li>java.sql.DriverManager#getConnection() </li><li>java.sql.Connection#createStatement() </li><li>java.sql.Statement#executeQuery() </li><li>java.text.NumberFormat#getInstance() </li><li>javax.xml.transform.TransformerFactory#newInstance(）</li></ol></li></ol><p><strong>工厂模式</strong></p><p>简单工厂模式：通过一个工厂对象创建实例， 调用方只需要传入创建对象的参数， 不需要考虑创建逻辑</p><p>工厂方法模式：</p><blockquote><p>简单工厂模式：工厂负责生成所有产品  工厂方法模式：定义抽象工厂， 其中定义产品的生成接口</p></blockquote><p><strong>单例模式</strong></p><p>单例模式：创建型模式，一个单例类只能存在一个实例</p><p>要求： 构造方法私有 对外提供一个静态方法用于创建静态变量实例</p><p>优点：降低内存开销，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>配置中心</title>
    <link href="/2022/11/03/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2022/11/03/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>Spring Cloud Config是基于Spring框架的分布式配置中心</p><blockquote><p>配置中心分为服务端和客户端</p></blockquote><p>服务端作用: 从对应的git仓库拉去配置信息, 并将配置信息提供给客户端</p><p>客户端: 在程序启动时从配置中心请求配置信息并加载</p><p><strong>服务端配置步骤</strong></p><blockquote><p>依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在spring启动类中添加注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br></code></pre></td></tr></table></figure><blockquote><p>yaml配置</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">server:<br>  port: 8000<br>spring:<br>  application:<br>    name: config-server<br>  cloud:<br>    config:<br>      server:<br>        git:<br>          uri: https://gitee.com/strong7217/micro01.git<br>          username: 18566230139<br>          password: Ay66xx<br>eureka:<br>  client:<br>    service-url:<br>      defaultZone: http://localhost:8761/eureka<br></code></pre></td></tr></table></figure><blockquote><p>git仓库要注意文件名格式</p></blockquote><p>服务Id-环境名称.yml</p><p><strong>客户端配置步骤</strong></p><p>pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>yaml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">spring:<br>  cloud:<br>    config:<br>      name: cinema-member-service<br>      profile: dev<br>      label: master<br>      uri: http://localhost:8000<br></code></pre></td></tr></table></figure><p><strong>添加配置刷新功能</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">management:<br>  endpoints:<br>    web:<br>      exposure:<br>        include: &#x27;refresh&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>添加刷新Controller</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;refresh&quot;)</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshController</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;title&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> title;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>配置中心添加重试功能</strong></p><blockquote><p>添加依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.retry<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-retry<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>添加yaml配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span>  <span class="hljs-comment">#分支名称</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8000</span> <span class="hljs-comment">#配置中心微服务访问地址</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">order-service</span> <span class="hljs-comment">#微服务的ID</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span>  <span class="hljs-comment">#环境名称</span><br>      <span class="hljs-attr">fail-fast:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#快速失败，进行重试</span><br>      <span class="hljs-attr">retry:</span><br>        <span class="hljs-attr">initial-interval:</span> <span class="hljs-number">5000</span> <span class="hljs-comment">#初始间隔时间  </span><br>        <span class="hljs-attr">max-interval:</span> <span class="hljs-number">30000</span> <span class="hljs-comment">#最大间隔时间</span><br>        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 重试次数</span><br>        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">2</span> <span class="hljs-comment">#重试间隔时间倍数</span><br></code></pre></td></tr></table></figure><p><strong>添加多git仓库配置功能</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-server</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">server:</span><br>        <span class="hljs-attr">git:</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">https://gitee.com/strong7217/&#123;application&#125;</span><br>          <span class="hljs-attr">username:</span> <span class="hljs-number">18566230139</span><br>          <span class="hljs-attr">password:</span> <span class="hljs-string">Ay66xx</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>隐式转换</title>
    <link href="/2022/11/03/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/11/03/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>4.26笔记</p><h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><p>Java中的类型转换包括自动类型转换(隐式类型转换), 强制类型转换</p><p><strong>自动类型转换</strong>:将小范围的类型向大范围类型转换, 转换中不会发生数据丢失</p><p>byte -&gt; short -&gt;int-&gt; long -&gt; float -&gt; double</p><p>char -&gt; int</p><blockquote><p>boolean类型不能参与到表达式的运算中</p></blockquote><p><strong>字符集</strong></p><p>char类型的本质是整数数值, 输出时会按照ascii编码翻译成对应的字符</p><p>实质上char类型存储了16位的无符号整数(无符号代表它没有符号位, 可以存储2的15次方数据)</p><blockquote><p>Java中的字符串是默认使用16位的Unicode编码来存储数据</p></blockquote><blockquote><p>疑问:char类型有2个字节(16位), 可以存储65535个字符, 但是ASCII码只有128个字符</p><p>那么129之后的值是按照什么规则来转换成字符的</p></blockquote><p>ASCII: 单字节的字符集码表, 包含128个字符(其中前32个字符无法打印, 后96个字符可以打印)</p><p>UTF-8: 包括了世界上大部分语言的文字的字符集码表, 父集是Unicode, 为变长字符集, 其大小会根据存储的字符不同而变化</p><p>GBK: 中国研发的字符集, 可以表示中文</p><p>byte a&#x3D;1,b&#x3D;2,c&#x3D;a+b;</p><p>上述代码会报错, 因为a+b表达式的结果是整数型, 整数值默认是int类型</p><blockquote><p>在移位运算时表达式中的整数型(byte short char)在参与运算时会发生自动类型转换, 自动转换成int类型的数值再参与表达式的运算</p></blockquote><blockquote><p>在java中默认整数类型为int 默认浮点数类型为double</p></blockquote><h1 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h1><p>强制类型转换会发生数据丢失:</p><p>例如: byte b &#x3D; (byte)a  表达式中a是int类型(32位) b是byte类型(8位)</p><p>上例的强制类型转换中,  会将a的前24位截断,只保留最后的8位赋值给b</p><h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><blockquote><p>在Java中运算符的类型有算数运算符 关系运算符(比较运算符) 逻辑判断运算符(要求两个操作数都是boolean型) 赋值运算符 位操作运算符 </p></blockquote><p>基本算数运算符有 + - * &#x2F; %</p><p>其中+运算符不仅有加法的意义, 当操作数中有字符串时, 会执行字符串的拼接操作</p><p>-运算符不仅可以作为减肥的双目操作符, 也可以作为取反的单目操作符</p><blockquote><p>标识符中数字不能放在首位</p><p>char类型可以存储中文</p></blockquote><blockquote><p>area:面积 perimeter:周长</p></blockquote><h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><p>关系运算符包括 &lt; &gt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D; instanceof </p><blockquote><p>Java仅有一种三目运算符 ?(expression) ture_expression : false_expression</p></blockquote><p>关系运算符的值是布尔类型, 也就是说只有true或false</p><p><strong>Scanner类</strong>是java提供的系统类库, 可以录入键盘的输入内容, 仅需了解 无需深入探究</p><h1 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h1><p>++ – 单目操作符, 可以放在操作数前或后</p><p>放在操作数前时, 先执行自增&#x2F;减 再参与表达式的运算</p><p>放在操作数后时, 如果是参与到算术表达式中, 代表当前操作数为原值 , 但是后面参与运算的同名操作数的值会加一</p><blockquote><p>方便记忆</p><p>++</p><p>在前, 先加后用</p><p>在后, 先用后加</p><p>–</p><p>在前, 先减后用</p><p>在后, 先用后减</p></blockquote><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;<br>      <span class="hljs-type">int</span> j=<span class="hljs-number">4</span>;<br>      <span class="hljs-type">int</span> k=<span class="hljs-number">7</span>;<br>      System.out.println(i++*++i-++j+k++);<br>      <span class="hljs-comment">//(3*5)-5+7=17</span><br>      <span class="hljs-comment">//上述表达式中, i++ 所以这里的操作数为3 *++3 这里的操作数为3+1+1=5</span><br>      <span class="hljs-comment">//3*5=15</span><br>      <span class="hljs-comment">//15-5+8=17</span><br></code></pre></td></tr></table></figure><p>示例2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> j=<span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> k=<span class="hljs-number">5</span>;<br><br>System.out.println(i++- --j+k++*i--);<br><span class="hljs-comment">//3-3+5*4=20</span><br></code></pre></td></tr></table></figure><p><strong>技巧</strong>: 将自增&#x2F;减运算符先预运算出各操作数的值, 从左到右写出只有数值的算术表达式, 再按照数学运算规则去计算结果</p><h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>对于算数运算符来说, 优先级与数学中的优先级相同, 可以将算数表达式作为数学表达式去运算</p><blockquote><p>优先级从上到下, 同等优先级的运算符按照从左到右的顺序进行计算</p></blockquote><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>()[]</td><td>正常(从左到右)</td></tr><tr><td>2</td><td>! ++ –(取反 自增 自减)</td><td>反(从右到左)</td></tr><tr><td>3</td><td>* &#x2F; %</td><td>正常</td></tr><tr><td>4</td><td>+ -</td><td>正常</td></tr><tr><td>5</td><td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td>正常</td></tr><tr><td>6</td><td>&lt; &gt; &lt;- &gt;&#x3D; instanceof</td><td>正常</td></tr><tr><td>7</td><td>&#x3D;&#x3D; !&#x3D;</td><td>正常</td></tr><tr><td>8</td><td>&amp; (按位与)</td><td>正常</td></tr><tr><td>9</td><td>^ (异或)</td><td>正常</td></tr><tr><td>10</td><td>\</td><td>正常</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>正常</td></tr><tr><td>12</td><td></td><td>正常</td></tr><tr><td>13</td><td>?:</td><td>反</td></tr><tr><td>14</td><td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; (所有的赋值运算符)</td><td>反</td></tr></tbody></table><p><strong>需要注意的地方</strong>: 结合性来说 有三类运算符是相反的, 从右到左 有: ! ++ – ?:还有所有的赋值运算符</p><p>大小括号的优先级是最高的</p><p>自增自减 取反的优先级第二高</p><p>乘法除法取余的优先级第三高</p><p>加减法的优先级第四高</p><p>赋值运算符的优先级是最低的</p><blockquote><p>位运算符 &amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt; </p><p>按位与 按位或 异或 左移操作符 右移操作符 无符号右移操作符</p></blockquote><h1 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h1><p>计算机中通过原码储存正数, 补码储存负数</p><p>原码计算: 将十进制数字转换为2进制即为原码</p><p>如何计算补码:</p><p>先将负数取绝对值 然后转原码</p><p>将得到的原码取反得到反码( 0转1 1转0)</p><p>将反码+1得到补码(这里的补码为正数的补码)</p><p>补码最前面加上符号位1即为该负数的补码(存储值)</p><p>常见的进制:</p><p>2进制: 逢2进1 以0b开头 唯一可以直接被计算机识别的进制</p><p>8进制: 逢8进1 以0开头</p><p>16进制: 逢16进1 以0x开头 10-15的数字以a-f表示</p><p>10进制: 逢十进一</p><p>计算机中</p><p>一个位为bit(比特)</p><p>8位为byte(字节) 字节也是程序可以操作的最小单位(说明程序不能对单独的位进行操作, 必须一次对8个位进行操作)</p><p>计算机无法直接识别负数, 所以需要在最前面加上符号位</p><p>对于正整数来说, 原码, 反码 补码都是相同的</p><p>负数的原码 :正数的原码加上符号位1</p><p>反码: 原码的基础上将符号位外的位取反得到反码</p><p>补码: 反码加1</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>集合Stream流</title>
    <link href="/2022/11/03/%E9%9B%86%E5%90%88Stream%E6%B5%81/"/>
    <url>/2022/11/03/%E9%9B%86%E5%90%88Stream%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="集合Stream流"><a href="#集合Stream流" class="headerlink" title="集合Stream流"></a>集合Stream流</h1><p>Stream API是java8添加的新特性, 通过lambda表达式实现了对集合对象的聚合或批量操作</p><p>通过Stream可以实现对集合的筛选 排序 聚合等操作</p><p>优点:</p><ol><li>性能高</li><li>代码简洁</li><li>并行</li></ol><p>创建Stream操作的三步骤:</p><ol><li>创建: 通过集合&#x2F;数组创建Stream</li><li>中间操作: 通过中间操作链处理数据</li><li>结束操作: 执行中间操作链产生结果</li></ol><p>中间操作有:</p><table><thead><tr><th>方法名</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>filter</td><td>过滤</td><td>过滤方法</td><td></td></tr><tr><td>map</td><td>遍历元素并操作</td><td></td><td></td></tr><tr><td>flatMap</td><td>遍历元素并操作(区别在于终止操作时, flatMap是返回元素本身, map返回数组流引用元素)</td><td></td><td></td></tr><tr><td>distinct</td><td>去重</td><td></td><td></td></tr><tr><td>sorted</td><td>排序</td><td></td><td></td></tr><tr><td>peek</td><td></td><td></td><td></td></tr><tr><td>limit</td><td>前n个元素</td><td></td><td></td></tr><tr><td>skip</td><td>删除前n个元素</td><td></td><td></td></tr></tbody></table><p>结束操作有:</p><table><thead><tr><th>方法名</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>forEach</td><td>遍历</td><td></td><td></td></tr><tr><td>forEachOrdered</td><td>遍历</td><td></td><td>串行流是乱序 并行流是有序</td></tr><tr><td>toArray</td><td>转换为数组</td><td></td><td></td></tr><tr><td>reduce</td><td>聚合为一条数据</td><td></td><td></td></tr><tr><td>collect</td><td>转换为集合</td><td></td><td></td></tr><tr><td>min</td><td>最小值</td><td></td><td></td></tr><tr><td>max</td><td>最大值</td><td></td><td></td></tr><tr><td>count</td><td>个数</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>技术面试</title>
    <link href="/2022/11/03/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/11/03/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="技术面试问题"><a href="#技术面试问题" class="headerlink" title="技术面试问题"></a>技术面试问题</h1><h2 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h2><ol><li>你是怎么实现某个业务的</li><li>业务的具体代码实现</li><li>如何部署项目(测试环境, 公有云上线)</li></ol><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ol><li>单例模式的八种实现方式</li></ol><h1 id="Spring问题"><a href="#Spring问题" class="headerlink" title="Spring问题"></a>Spring问题</h1><ol><li>自动装配流程</li><li>定时任务实现</li><li>Spring Cloud用过哪些组件, 说下他们的作用&#x2F;角色</li></ol><p>谈谈对某种技术的理解:</p><ol><li>概念</li><li>实现</li><li>优缺点</li><li>(项目中的用途)</li></ol><p>NO.1:项目是怎么实现维修业务的</p><p>后端传设备参数到前端，前端处理</p><p>NO.2:维修业务后台代码都有啥</p><p>json传一堆查询结果</p><p>NO.3:消息队列怎么实现的</p><p>说了消费者生产者</p><p>NO.4:RabbitMQ怎么保证消息不会重复接收</p><p>说了幂等性实现</p><p>NO.5:RabbitMQ怎么保证消息的顺序</p><p>生产者发送多条消息到一个队列中，这多条消息具有先后顺序，这个队列只有一个消费者去消费消息。 消费者在消费信息的时候不去直接消费消息，而是将消息保存在内存队列中。根据消息的关键值（例如订单ID）进行消息分类，将关键值相同的消息（一组需要保证顺序的消息）发送到相同的内存队列中的里面，一个线程只去一个内存队列中取信息。这样就保证了消息的顺序性</p><p>NO.6:RabbitMQ怎么保证消息的可靠性</p><p>设置mandatory参数或者备份交换器 使用publisher confirm机制 队列和消息都为持久化的 设置消费端对应的autoAck参数为false并在消费完消息之后再进行消息确认</p><p>NO.7:说一下集合</p><p>直接把集合说了个底朝天</p><p>NO.8:创建线程的方法</p><p>继承Thread类，runnable，callable，线程池</p><p>NO.9:.调start方法后线程的状态</p><p>可运行状态</p><p>NO.10:sleep放了哪个锁？？？</p><p>sleep不放锁。wait才放锁，给人挖坑呢</p><p>NO.11:线程池怎么创建</p><p>手写线程池，内置线程池，（四个都说）</p><p>NO.12:线程池参数</p><p>1.corePoolSize：核心线程数 2.maxinumPoolSize：最大线程数 3.keepAliveTime：线程闲置超时时长 4.TimeUnit：时间单位，默认为毫秒（为前者指定的时间单位） 5.workQueue：任务队列（阻塞队列） 6.ThreadFactory：创建新线程的工厂 7.RejectExecutionHandler：拒绝策略</p><p>NO.13:什么是死锁，怎么解决</p><p>一个事务有了A锁又要B，另一个有了B又要A，就造成死锁 （1）如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。 （2）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。 （3）对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。 （4）如果业务处理不好，可以用分布式事务锁或者使用乐观锁。</p><p>NO.14:Synchronized作用</p><p>@synchronized 的作用是创建一个互斥锁，保证此时没有其它线程对self对象进行修改，保证代码的安全性。也就是包装这段代码是原子性的，安全的。</p><p>NO.15:.#和$的区别</p><p>小时候就会</p><p>NO.16:Mybatis缓存</p><p>说了一级缓存是sqlsessio级别的，二级缓存时sqlsessionfactory级别的</p><p>NO.17:千万条数据怎么插入</p><p>说了foreach，人说用存储过程，</p><p>NO.18:联查用的啥，多表联查中on和where区别</p><p>说用的最多的就是leftjoin on是筛选后面的条件，where是筛选临时表</p><p>NO.19:分页用的啥，手写sql怎么写</p><p>limit，再说参数</p><p>NO.20:springBoot核心注解</p><p>启动类注解说完了</p><p>NO.21:AOP和IOC</p><p>说完了</p><p>NO.22:@Resource和@Autowired的区别</p><p>@Resource按名字@Autowired按类型</p><p>NO.23:说一下事务</p><p>一路说到MVVC</p><p>NO.24:微服务组件</p><p>nacos、feign‘，rabbion，’gateway、sentinal、seata</p><p>NO.25:nacos怎么配</p><p>test</p><p>NO.26:fegin怎么用，写什么注解</p><p>启动类enablefeginclient 假接口feginclient</p><p>NO.27:项目中gateway作用</p><p>鉴权，路由，所有请求都走网关</p><p>NO.28:说说负载均衡</p><p>说了几个</p><p>NO.29:redis项目中做什么</p><p>临时数据存储，消息队列</p><p>NO.30:redis持久化</p><p>AOF、RDB</p><p>NO.31:redis中数据与数据库不一致怎么办</p><p>写的时候先写缓存，再写数据库</p><p>NO.32:说说sql优化</p><p>先说怎么优化，再说索引，说了B+树，说到存的啥</p><p>NO.33:索引失效</p><p>*号，null，回表过多，模糊查询，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>异常捕获</title>
    <link href="/2022/11/03/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"/>
    <url>/2022/11/03/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><p>异常捕获是编译时异常的解决方案之一</p><p>关键字 try catch finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    SimpleDateFormat sdf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyy-MM-dd&quot;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//如果return在上层代码, 下层代码不会执行</span><br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;<br>        Date d=sdf.parse(<span class="hljs-string">&quot;1234&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;调用成功&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//try代码块中的return不会影响到finally的执行</span><br>        <span class="hljs-comment">//finally在return之前执行</span><br>    &#125;<span class="hljs-keyword">catch</span> (ParseException e)&#123;<br>        e.printStackTrace();<br>        System.out.println(<span class="hljs-string">&quot;异常捕获&quot;</span>);<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;始终执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>try代码块中的return不会影响到finally的执行</strong><br><strong>finally在return之前执行</strong></p><p>异常捕获语句可能会产生多个异常, 可以有多个catch块, 但是try块和finally块只能有一个</p><p>有多个catch块时, 从上到下执行, 并且当一个catch块满足时不会再判断后面的catch块</p><p>因此为了使每个catch块都有效, 应该按照异常范围从小到大排序</p><h1 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h1><p>throw是异常抛出, 用于声明异常, 告诉方法的调用者该方法可能抛出的异常</p><ol><li><p>不捕获异常, 直接向外抛出</p><blockquote><p>异常未被内部处理, 并且会异常方法会被弹出方法栈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;wrong input&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>捕获异常并向外抛出</p><blockquote><p>异常被内部消化, 并告知调用的方法</p><p>导致产生异常的方法被弹出方法栈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-comment">//指定抛出异常的类型</span><br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;wrong input&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> e;<br>        <span class="hljs-comment">//将捕获到的异常抛出给外部</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>抛出异常会导致方法被弹出栈结构, 剩余代码不会被执行</p></blockquote><h1 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h1><p>运行时异常无法被编译器检测出, 会在程序运行时动态抛出</p><p>运行时异常无法捕获(catch), 可以用条件判断语句进行预防</p><blockquote><p>捕获只能捕获编译时异常</p></blockquote><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>可以通过继承Exception或RuntimeException类来实现自定义异常</p><p><strong>异常的本质是特殊的类</strong></p><ol><li><p>自定义编译时异常</p><blockquote><p>继承Exception类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义运行时异常</p><blockquote><p>继承RuntimeException类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRumtimeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimException</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><strong>java中的数组不属于集合</strong></p><p><strong>数组特点</strong></p><ol><li>数组的长度不可变</li><li>数组的元素类型是相同且不可变的</li><li>数组不能保存映射关系的数据</li><li>数组的元素可以存储基本数据类型和引用数据类型</li><li>数组是线性连续结构的存储空间</li></ol><p><strong>集合特点:</strong></p><ol><li>集合是长度是可变的容器</li><li>集合的元素类型可以是不同的, 也是可变的</li><li>集合可以保存映射关系的数据(关联数组)</li><li>集合的元素只能存储引用数据类型</li></ol><p>Collection和Map接口是Java集合框架中的根接口</p><p>java中的集合类主要由这两个接口派生出</p><p>集合中的集合分为四种结构: Set List Queue Map</p><p>set: 无序, 元素值不可重复</p><p>list: 有序,可以重复, 通过index来访问值</p><p>Map: 保存映射关系的集合</p><p>Queue: 队列集合</p><p><strong>java中的集合实质为一种特殊的容器, 用于存储多个对象引用</strong></p><p>在Java5中增加了泛型, 使集合具有了存储容器中对象数据类型的能力</p><blockquote><p>在java5之前, 集合将容器中所有的对象都视为Object类型</p></blockquote><p><img src="/2022/11/03/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/image-20220517142541474.png" alt="image-20220517142541474"></p><p>需要访问一种集合中的元素时:</p><ol><li>Set集合只能通过元素值本身来访问(Set集合不能有重复元素值)</li><li>List集合可以通过索引(index)来访问</li><li>Map通过key来访问元素值(value)</li></ol><blockquote><p>Collection集合体系</p></blockquote><p><img src="/2022/11/03/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/image-20220517145417860.png" alt="image-20220517145417860"></p><blockquote><p>Map集合体系</p></blockquote><p><img src="/2022/11/03/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/image-20220517145443512.png" alt="image-20220517145443512"></p><p><strong>其中ArrayListHashSet和HashMap是重点掌握内容</strong></p><p>注意List, Set和Queue都是Collection的子接口</p><p>而Map不属于Collection, 是和Collection相同地位的根接口</p><p>List特点: 有序 元素值可以重复 每个元素都有对应的下标来访问[0到length-1]</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList是List接口的实现类</p><p>ArrayList是一个基于数组结构的列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">al</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">//无参构造</span><br>ArrayList al2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(al);<br><span class="hljs-comment">//可以传入一个Collection集合, 创建一个包含该集合元素的list</span><br>ArrayList al3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//指定初始容量</span><br></code></pre></td></tr></table></figure><blockquote><p>三种构造器</p></blockquote><p>与下列代码的数组类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] objects;<br></code></pre></td></tr></table></figure><p>实例方法:</p><table><thead><tr><th>方法名</th><th>方法功能</th></tr></thead><tbody><tr><td>add</td><td>添加数据</td></tr><tr><td>get</td><td>获取对应索引的数据</td></tr><tr><td>contains</td><td>判断list中是否包含对应的元素值</td></tr><tr><td>indexOf</td><td>查找元素值对应的索引(-1代表无法找到)</td></tr><tr><td>isEmpty</td><td>判断集合元素是否全部为空, 空返回true</td></tr><tr><td>clear</td><td>删除list中全部元素</td></tr><tr><td>remove</td><td>删除索引位置上的元素</td></tr><tr><td>size</td><td>获取列表包含的元素个数</td></tr><tr><td>set</td><td>修改对应索引的元素</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>al.add(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-comment">//在0索引位置加入数据</span><br>al.add(<span class="hljs-number">3</span>);<br>al.add(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);<br><span class="hljs-comment">//在索引位置插入数据</span><br>al.set(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<br>Collections.addAll(al,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><span class="hljs-comment">//向集合中添加大量元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; al.size(); i++) &#123;<br>    System.out.println(al.get(i));<br>    <span class="hljs-comment">//遍历list</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Collections类方法</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>addAll</td><td>将大量元素添加到对应集合对象中</td></tr><tr><td>sort</td><td>将集合中的元素进行排序, 字符串也可以排序, 但是如果集合中同时包含字符串和数组类型, 会发生类型转换异常</td></tr></tbody></table><p>集合有三种遍历方式: for循环, 增强for循环, 迭代器(iterator)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">al</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">//for循环遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; al.size(); i++) &#123;<br>    System.out.println(al.get(i));<br>&#125;<br><span class="hljs-comment">//增强for循环遍历</span><br><span class="hljs-keyword">for</span> (Object o :al) &#123;<br>    System.out.println(o);<br>&#125;<br><span class="hljs-comment">//迭代器遍历</span><br>Iterator it=al.iterator();<br><span class="hljs-comment">//注意迭代器初始位置未指向任何元素</span><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    Object oj=it.next();<br>    <span class="hljs-comment">//迭代器指向集合中的下一个对象, 并返回下一个对象的地址</span><br>    <span class="hljs-comment">//第一次运行会使迭代器指向集合中的第一个对象</span><br>    System.out.println(oj);<br>    it.remove();<br>    <span class="hljs-comment">//删除当前迭代器指向的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一个类可以通过实现Comparable这个函数接口中的compareTo方法(实例方法), 使Collections.sort可以排序该类的对象元素</strong></p><blockquote><p>自然排序: 在被比较对象的类里实现了Comparable函数接口里的compareTo方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Cat&gt;&#123;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Cat c)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age-c.age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test15</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Cat c1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">3</span>);<br>        Cat c2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">2</span>);<br>        ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Collections.addAll(al,c1,c2);<br>        System.out.println(al);<br>        Collections.sort(al);<br>        System.out.println(al);<br>        System.out.println(c1.compareTo(c2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自定义排序:</p><p>创建了一个CarComparator类实现Comparator函数接口里面的compare方法(实例方法), 可以在Collection.sort方法从传入该比较类对象来进行比较</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Cat&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Cat o1, Cat o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.age-o2.age;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test15</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Cat c1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">3</span>);<br>        Cat c2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-number">2</span>);<br>        ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Collections.addAll(al,c1,c2);<br>        System.out.println(al);<br>        Collections.sort(al,<span class="hljs-keyword">new</span> <span class="hljs-title class_">CatComparator</span>());<br>        <span class="hljs-comment">//自定义</span><br>        System.out.println(al);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ArrayList的底层是通过数组实现</strong></p><blockquote><p><strong>引用数据类型变量的大小为4个字节</strong></p></blockquote><p><img src="/2022/11/03/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/image-20220517174253114.png" alt="image-20220517174253114"></p><blockquote><p>ArrayList的初始容量为0</p><p>当添加第一个元素时,容量变成10</p><p>添加第11个元素时, 容量变成15 10+(10&gt;&gt;1)&#x3D;10*1.5&#x3D;15</p><p>添加16个元素时, 容量变为15+(15&gt;&gt;1)&#x3D;15*1.5&#x3D;22</p><p>当添加元素而ArrayList容量不足时, 容量会自动扩容为原来的1.5倍</p></blockquote><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>为了实现集合的通用性:可以保存不同类型的对象元素, 集合中的元素都以Object类型来保存(编译类型)</p><blockquote><p>防止编译器检查报错</p></blockquote><blockquote><p>注意运行时类型没有变, 依旧为原类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Collections.addAll(al,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span> (Object o : al) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span>(String)o;<br>    str.indexOf(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//上述代码运行会报错, 因为列表中包含Integer类型</span><br>    <span class="hljs-comment">//ine类型字面量被自动装箱生成的Integer类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>泛型可以规范集合的元素类型</p><blockquote><p>本质是在编译时进行检查集合中的元素是否为泛型规定的类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Collections.addAll(al, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">//编译时会报错, 因为向String泛型的列表中添加了Integer类型的变量</span><br><span class="hljs-keyword">for</span> (Object o : al) &#123;<br>    System.out.println((o <span class="hljs-keyword">instanceof</span> Integer));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>了解泛型接口和泛型类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyList</span>&lt;String&gt;&#123;<br>&#125;<br><span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;String&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyList</span>&lt;String&gt;&#123;<br>&#125;<br><span class="hljs-comment">//调用测试</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyList&lt;String&gt; datas=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型通配符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匹配任意类型</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(ArrayList&lt;?&gt; datas)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型擦除</strong></p><p><strong>泛型擦除指泛型只会在编译时进行检查, 并且所有泛型参数在编译后都会被清除, 不会保留到运行时</strong></p><blockquote><p>泛型的本质是在编译时对代码进行检查, 因此运行时是可以对泛型集合添加任意类型的对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(ArrayList&lt;String&gt; al)</span>&#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(ArrayList&lt;Integer&gt; al)</span>&#123;&#125;<br><span class="hljs-comment">//上面两个方法不是方法重载, 由于泛型擦除的特性,所以它们的参数列表是相同的</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2022/11/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/11/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>微服务: 一种系统设计架构, 用于将单体系统拆分为多个模块, 每个模块都是可以独立开发的微服务, 模块间通过网络通信, 实现了分布式架构</p><p>微服务优点: </p><ol><li>可维护性高, 更新迭代快, 每个模块都可以独立进行开发和部署, 对其他模块的影响较低</li><li>容错性高,  每个模块都是独立的进程, 隔离性高</li><li>扩展性高, 模块间耦合性低, 分布式系统的扩容能力强</li><li>模块间使用HTTP通信, 通用性高</li><li>可监控, 通过网络通信可以实现注册中心, 服务监控等微服务管理系统</li></ol><p>缺点:</p><pre><code class="hljs">1. 模块间通过网络进行通信, 延迟高 开销大, 可以通过中间件实现并发或异步执行任务来提高系统效率1. 测试难度高, 需要维护庞大的API文档1. 分布式系统非常庞大, 运维难度高1. 开发技术要求高</code></pre><p>微服务常用于分布式去中心化的部署方式, 适合互联网业务场景</p><p>RPC框架: 远程过程调用, 使服务可以通过网络调用另一个服务, 实现分布式服务架构(微服务)</p><p>单体架构: 将系统分为view dao controller三层, 所有的业务模块都放在一个工程中, 最终部署到一台服务器上</p><p>单体架构可以通过将系统部署到多个服务器上(每台服务器都是一个独立的系统, 不能被称为分布式架构), 再使用反向代理软件(nginx) 通过负载均衡实现水平扩展, 解决高并发问题</p><p>单体架构优点: 没有分布式的网络通信延迟, 测试简单, 部署简单</p><p>缺点: 伸缩性差, 扩容难度高</p><p>稳定性低, 系统隔离性差 (一个模块的错误会导致整个系统挂掉)</p><p>每次更新都需要重新部署整个系统, 灵活性差</p><p>SOA架构: 面向服务架构, 早期分布式系统的实现, 不同服务间通过中间件进行通信</p><h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><p>注册中心可以实现微服务系统的服务发现功能(自动化注册和发现)</p><blockquote><p>在微服务系统中, 服务发现是最核心的模块</p></blockquote><p>服务发现的三种角色: 注册中心 服务提供者 服务消费者</p><p><img src="/2022/11/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220823113453986.png" alt="image-20220823113453986"></p><h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1><h1 id="Hystrix熔断器"><a href="#Hystrix熔断器" class="headerlink" title="Hystrix熔断器:"></a>Hystrix熔断器:</h1><p>Hystrix熔断器处理分布式系统的延迟和容错</p><blockquote><p>熔断器是监控分布式系统的每个组件, 当某个组件响应超时时将该组件从分布式系统中熔断或服务降级, 提高整个系统的健康和高可用</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>技术面试答案</title>
    <link href="/2022/11/03/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%AD%94%E6%A1%88/"/>
    <url>/2022/11/03/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="技术面试答案"><a href="#技术面试答案" class="headerlink" title="技术面试答案"></a>技术面试答案</h1><p>谈谈对单例模式的理解:</p><p>概念: 单例模式就是保证一个类只能存在一个实例, 并且只有一个方法来获取该类实例(该类的静态方法)</p><p>单例模式实现的类也被称为单例类</p><p>单例类的三个必要条件:</p><ol><li>私有构造函数, 防止new, 保证只能在类内部创建对象</li><li>私有静态变量用于存放唯一的实例</li><li>提供静态方法用于创建唯一的实例</li></ol><blockquote><p>私有构造函数会导致类无法被继承</p></blockquote><p>单例模式的五种实现方式:</p><ol><li>懒汉</li><li>饿汉</li><li>静态内部类</li><li>枚举</li><li>双重校验锁</li></ol><p>Spring Cloud Alibaba和Spring Cloud的对比和优势</p><table><thead><tr><th>角色</th><th>Spring Cloud Alibaba组件</th></tr></thead><tbody><tr><td>分布式配置</td><td>Nacos</td></tr><tr><td>服务注册&#x2F;发现</td><td>Nacos</td></tr><tr><td>服务熔断</td><td>Sentinel</td></tr><tr><td>远程服务调用</td><td>Dubbo RPC</td></tr><tr><td>服务路由</td><td>Dubbo Proxy</td></tr><tr><td>分布式信息</td><td>Rabbit MQ</td></tr><tr><td>负载均衡</td><td>Dubbo  LB&#x2F;Ribbon</td></tr><tr><td>分布式事务</td><td>Seata</td></tr></tbody></table><p>如何实现分布式事务(Seata)</p><ol><li>在registry.conf里面配置注册中心信息, 读取配置</li><li>数据库建库 建两张表 分支事务表 全局事务表</li><li>seata配置内容设置数据存储方式(数据库) 事务 日志配置</li><li>项目的maven中引入seata依赖</li><li>项目的yaml配置中添加 seata的注册中心信息</li></ol><p>seata配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">#数据存储方式为数据库<br>store.mode=db<br># 客户端与服务端传输方式<br>transport.serialization=seata<br>transport.compressor=none<br># 关闭metrics功能，提高性能<br>metrics.enabled=false<br>metrics.registryType=compact<br>metrics.exporterList=prometheus<br>metrics.exporterPrometheusPort=9898<br></code></pre></td></tr></table></figure><p>创建数据库, 建立两张表: 分支事务表 全局事务表</p><p>表字段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml">SET NAMES utf8mb4;<br>SET FOREIGN_KEY_CHECKS = 0;<br>-- ----------------------------<br>-- 分支事务表<br>-- ----------------------------<br>DROP TABLE IF EXISTS `branch_table`;<br>CREATE TABLE `branch_table`  (<br>  `branch_id` bigint(20) NOT NULL,<br>  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,<br>  `transaction_id` bigint(20) NULL DEFAULT NULL,<br>  `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `status` tinyint(4) NULL DEFAULT NULL,<br>  `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `gmt_create` datetime(6) NULL DEFAULT NULL,<br>  `gmt_modified` datetime(6) NULL DEFAULT NULL,<br>  PRIMARY KEY (`branch_id`) USING BTREE,<br>  INDEX `idx_xid`(`xid`) USING BTREE<br>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;<br>-- ----------------------------<br>-- 全局事务表<br>-- ----------------------------<br>DROP TABLE IF EXISTS `global_table`;<br>CREATE TABLE `global_table`  (<br>  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,<br>  `transaction_id` bigint(20) NULL DEFAULT NULL,<br>  `status` tinyint(4) NOT NULL,<br>  `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `timeout` int(11) NULL DEFAULT NULL,<br>  `begin_time` bigint(20) NULL DEFAULT NULL,<br>  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,<br>  `gmt_create` datetime NULL DEFAULT NULL,<br>  `gmt_modified` datetime NULL DEFAULT NULL,<br>  PRIMARY KEY (`xid`) USING BTREE,<br>  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE,<br>  INDEX `idx_transaction_id`(`transaction_id`) USING BTREE<br>) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;<br>SET FOREIGN_KEY_CHECKS = 1;<br></code></pre></td></tr></table></figure><p>项目yaml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">seata:<br>  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址<br>    # 参考tc服务自己的registry.conf中的配置<br>    type: nacos<br>    nacos: # tc<br>      server-addr: 127.0.0.1:8848<br>      namespace: &quot;&quot;<br>      group: DEFAULT_GROUP<br>      application: seata-server # tc服务在nacos中的服务名称<br>      cluster: SH<br>  tx-service-group: seata-demo # 事务组，根据这个获取tc服务的cluster名称<br>  service:<br>    vgroup-mapping: # 事务组与TC服务cluster的映射关系<br>      seata-demo: SH<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2022/11/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>常见的排序算法有: 选择排序 冒泡排序 快速排序</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2022/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><h3 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h3><p>数据库按照历史发展顺序有如下4种</p><ol><li>网状型数据库</li><li>层次型数据库</li><li>关系数据库 (SQL数据库)</li><li>非关系型数据库 (NO-SQL)</li></ol><h3 id="SQL和NO-SQL的区别"><a href="#SQL和NO-SQL的区别" class="headerlink" title="SQL和NO-SQL的区别"></a>SQL和NO-SQL的区别</h3><p>关系型数据库和非关系型数据库也被称为SQL数据库和NO-SQL数据库</p><p>两者的区别在于关系型数据库存储数据以及数据间的关系,而非关系型数据库只存储数据</p><blockquote><p>sql数据库代表: mysql sqlserver oracle db</p><p>no-sql数据库代表: redis memcache hbase</p></blockquote><p>no-sql数据库是为了高并发的场景而设计, 将数据存储在内存中, 尽可能提高数据的读写速度</p><h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>ER图也被称为实体关系图, 一般由产品经理在需求分析阶段提供, 用于设计对应的数据库</p><p>ER图的组成部分: 矩形椭圆菱形</p><blockquote><p>矩形表示实体</p><p>椭圆表示属性(实体的属性)</p><p>菱形表示关系(实体间的关系)</p></blockquote><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>SQL是关系型数据库的基础, 用于处理数据间的关系</p><p>数据库中的数据存储在表中, 而表的数据也可以分为行和列</p><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>表</td><td>存储数据以及数据间的关系</td></tr><tr><td>记录</td><td>表的行被称为记录</td></tr><tr><td>字段</td><td>表的列被称为字段,字段是记录中的某个特性</td></tr></tbody></table><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>jdbc是java数据库编程的基础, 提供了一套API用于在数据库中执行sql语句</p><p>JDBC工作步骤:</p><ol><li>连接数据库</li><li>在数据库中执行sql语句</li><li>将sql语句的执行结果返回</li></ol><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220526154354456.png" alt="image-20220526154354456"></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="mysql概念"><a href="#mysql概念" class="headerlink" title="mysql概念"></a>mysql概念</h3><p><strong>mysq是一种DBMS, 属于关系型数据库</strong></p><p>mysql的一个实例(server instance)可以包含多个数据库, 通过use命令切换数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#显示当前mysql服务器实例下的所有数据库<br><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><h3 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h3><p>mysql中的数据类型主要有3种: 数值类型 字符串类型  日期类型</p><table><thead><tr><th>类型</th><th>具体类型</th></tr></thead><tbody><tr><td>数值类型</td><td>严格数值类型 近似数值类型</td></tr><tr><td>字符串类型</td><td>char, varchar, binary, varbinary, blob, text, enum, set</td></tr><tr><td>日期类型</td><td>datetime, timestamp, date, time, year</td></tr></tbody></table><p><strong>mysql支持所有标准sql数值类型</strong></p><p>严格数值类型:integer(int) smallint decimal(dec) numeric</p><p>近似数值类型:float real double precision</p><h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><p><strong>mysql作为DBMS有三层架构</strong></p><ol><li>连接层 处理客户端连接和鉴权认证</li><li>服务层 负责查询语句(select语句)的解析 优化 缓存, 还有内置函数和存储过程的实现</li><li>存储引擎  负责数据库中数据的存储 提取(write read)</li></ol><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220527154444039.png" alt="image-20220527154444039"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是数据库操作的执行基本单位, 事务可以包含一个或多个sql语句</p><p>事务四特性: ACID</p><table><thead><tr><th>特性</th><th>要求</th><th>英文</th></tr></thead><tbody><tr><td>原子性</td><td>事务不可再分</td><td>atomicity</td></tr><tr><td>一致性</td><td>同一事务的数据准确无误, 不能有差异</td><td>consistency</td></tr><tr><td>隔离性</td><td>不同事务间相互独立, 互不干扰</td><td>isolation</td></tr><tr><td>持久性</td><td>一条事务被commit后存储到磁盘中, 在执行新事务前数据不能被修改</td><td>durability</td></tr></tbody></table><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>存储引擎负责执行事务</p><p><strong>存储引擎是DBMS架构的最底层并且最核心的组成部分, 直接负责事务的实现</strong></p><p>面试题: myisam和innodb的区别</p><table><thead><tr><th>特性</th><th>innodb</th><th>myisam</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>256TB</td></tr><tr><td>事务支持</td><td>支持</td><td>不支持</td></tr><tr><td>外键支持</td><td>支持</td><td>不支持</td></tr><tr><td>数据缓存支持</td><td>支持</td><td>不支持</td></tr><tr><td>默认储存引擎版本</td><td>mysql5.5及之后</td><td>mysql5.5之前</td></tr><tr><td>事务多线程安全</td><td>支持表锁</td><td>支持行锁</td></tr><tr><td>每个表对应的文件数目</td><td>2个(frm,ibd)</td><td>3个(frm,myd,myi)</td></tr><tr><td>默认索引结构</td><td>树形(B+树)</td><td>B+树</td></tr><tr><td>聚簇</td><td>支持</td><td>不支持</td></tr><tr><td>范围查找</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>索引用于快速查找数据库中的数据, 提高查询效率</p><p>innodb和myisam都是用B+树作为索引结构, 但是在实现上有所区别</p><blockquote><p>myisam的索引树的叶子节点保存数据的内存地址</p><p>innodb的叶子节点直接保存数据本身</p></blockquote><p>myisam索引结构实现:</p><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220530111032633.png" alt="image-20220530111032633"></p><p>Innodb索引结构实现:</p><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220527180430136.png" alt="image-20220527180430136"></p><blockquote><p>B+树索引支持聚簇, 范围查询, 搜索效率高</p></blockquote><p>聚簇: 索引和数据放在同一个区域中</p><p>非聚簇: 索引和数据放在不同的区域</p><p>聚簇要求数据必须有主键, 然后按照主键进行聚簇</p><blockquote><p>如果表没有显示指定的主键, mysql会自动选择一个满足条件的字段作为主键, 如果不存在满足条件的字段, mysql会生成隐含字段作为聚簇的主键</p><p>隐含字段的类型为长整型, 6个字节大小</p></blockquote><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图 view被称为虚拟表, 视图本身不存储数据, 仅仅存储查询语句, 从数据库中读取数据并展示</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>SQL语言有五种: DDLDMLDQLDCL 还有事务控制语句</p><p><strong>重点学习DQL, 数据库查询语句</strong></p><p>DDL用于建库建表</p><p>DML用于对表进行增删查改</p><p>DQL用于在表中查询数据[重点学习]</p><p>DCL用于设定权限(数据库 表 数据)</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>约束(constraint)是对SQL数据库数据做的限制</p><p>mysql中的约束有四种</p><table><thead><tr><th>约束名</th><th>作用</th></tr></thead><tbody><tr><td>not null</td><td>非空</td></tr><tr><td>unique</td><td>唯一</td></tr><tr><td>primary key</td><td>主键</td></tr><tr><td>foreign key</td><td>外键</td></tr></tbody></table><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><table><thead><tr><th>分类</th><th>关键字</th></tr></thead><tbody><tr><td>DDL</td><td>create  update  delete</td></tr><tr><td>DML</td><td>create  alter  drop  truncate</td></tr><tr><td>DQL</td><td>select</td></tr><tr><td>DCL</td><td>grant  revoke</td></tr><tr><td>事务控制语句</td><td>commit  rollback  savepoint add constraint</td></tr></tbody></table><p><strong>SQL语句的关键字不区分大小写</strong></p><blockquote><p>注意标识符是区分大小写的</p></blockquote><table><thead><tr><th>SQL命令</th><th>功能</th></tr></thead><tbody><tr><td>create</td><td>创建数据库或者数据库对象</td></tr><tr><td>drop</td><td>删除数据库或者数据库对象</td></tr><tr><td>alter</td><td>更改数据库结构或属性</td></tr><tr><td>comment</td><td>添加注释</td></tr><tr><td>rename</td><td>重命名数据库对象</td></tr><tr><td>delete from</td><td>逐行删除表的记录, 可以恢复</td></tr><tr><td>truncate</td><td>删除表的所有记录, 不可恢复</td></tr></tbody></table><p><strong>delete from是逐行将整个表的数据删除, 有日志可以恢复</strong></p><p><strong>truncate table是直接将整个表重置, 速度最快, 但是操作不可恢复</strong></p><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p><strong>DQL也被称为查询语句, 是功能最复杂的SQL语句(面试重点)</strong></p><p>最简单的DQL语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段或(函数加字段) <span class="hljs-keyword">from</span> 表名; <br></code></pre></td></tr></table></figure><p>完整DQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段或(函数加字段) <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 查询条件 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 字段 <span class="hljs-keyword">having</span> 过滤条件 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段 limit (a,b)<br></code></pre></td></tr></table></figure><p><strong>执行顺序从左向右</strong></p><blockquote><p>除了select字段语句是在where后执行, 但是实际上并不影响最终结果</p></blockquote><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>DQL语句的函数不会修改数据源本身, 仅仅是将结果打印出来</p><h5 id="字段函数"><a href="#字段函数" class="headerlink" title="字段函数"></a>字段函数</h5><blockquote><p>字段函数操作对象为字段</p></blockquote><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>count</td><td>计数</td></tr><tr><td>sum</td><td>求和</td></tr><tr><td>avg</td><td>求平均值</td></tr><tr><td>max</td><td>求最大值</td></tr><tr><td>min</td><td>求最小值</td></tr><tr><td>ifnull</td><td>筛选并保留空值</td></tr><tr><td>group_concat</td><td>将某个字段的多行记录合并为一行记录, 用逗号分割</td></tr></tbody></table><h5 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h5><blockquote><p>字符串函数操作对象可以是字符串类型字段或字符串直接量</p></blockquote><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>concat(a,b)</td><td>拼接a和b</td></tr><tr><td>substr( … from … for …)</td><td>截取</td></tr><tr><td>trim( a from b)</td><td>从b中删除a(删除位置是开头和结尾,可以匹配多个, 不会删除中间被其他字符包围的a)</td></tr><tr><td>trim(a)</td><td>删除a中的空格</td></tr><tr><td>uuid()</td><td>没有操作对象, 直接返回一个36位的随机码(字符串)</td></tr></tbody></table><h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><blockquote><p>下列三个函数都没有操作对象, 直接返回一个表示当前时间的字符串</p></blockquote><table><thead><tr><th>函数</th><th>格式</th></tr></thead><tbody><tr><td>now()</td><td>yyyy-MM-dd hh:mm:ss</td></tr><tr><td>curdate()</td><td>yyyy-MM-dd</td></tr><tr><td>curtime()</td><td>hh:mm:ss</td></tr></tbody></table><p>year() month() day() 分别读取日期对象中的年份 月份 日</p><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>一般的函数都只能通过select语句调用, 意味着其返回结果只能打印出来而不能存储到数据库中</p><p>存储过程是一个特殊的函数,不需要通过select语句执行</p><h4 id="dual表"><a href="#dual表" class="headerlink" title="dual表"></a>dual表</h4><p><strong>dual表是一个虚拟表, 不包含任何数据 仅仅用于使sql命令符合语法要求</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">#获取当前的年份<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(now()) <span class="hljs-keyword">from</span> dual;<br>#获取当前的月份<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">month</span>(now()) <span class="hljs-keyword">from</span> dual;<br>#获取当前的天数<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">day</span>(now()) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>查询语句中可以嵌套子查询, 子查询返回的结果实质为行内视图</p><p>子查询语句可以放在三个地方 select后 from后 where in 后</p><ol><li>select … from … where … in (子查询)</li><li>select 字段,(子查询) from …</li><li>select … from (子查询)</li></ol><h4 id="union-连查表"><a href="#union-连查表" class="headerlink" title="union(连查表)"></a>union(连查表)</h4><p>连查表使用union或union all语句, 将多个select语句返回的视图进行合并展示</p><p><strong>union要求两个view的字段数相同,字段类型不需要相同</strong></p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>分组查询的语句有:</p><ol><li>.. group by …</li><li>… group by … having …</li><li>group_concat()函数</li></ol><h4 id="多表查询-连查"><a href="#多表查询-连查" class="headerlink" title="多表查询(连查)"></a>多表查询(连查)</h4><p>多表查询用于同时对多个表的数据进行查询</p><blockquote><p> 笛卡尔乘积</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">#直接将两个表的数据一条对应m条<br>#得到的组合表的记录数将是n<span class="hljs-operator">*</span>m<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student,score;<br></code></pre></td></tr></table></figure><p>mysql可以使用三种联查</p><blockquote><p>mysql支持左外联查和右外联查, 但是不支持全外联查</p></blockquote><table><thead><tr><th>联查</th><th>区别</th></tr></thead><tbody><tr><td>内联查</td><td>只显示满足连接条件的数据</td></tr><tr><td>左外联查</td><td>将右表不满足连接条件的数据丢弃</td></tr><tr><td>右外联查</td><td>将左表不满足连接条件的数据丢弃</td></tr></tbody></table><p><strong>联查语句都是使用on作为连接条件</strong></p><h5 id="内联查"><a href="#内联查" class="headerlink" title="内联查"></a>内联查</h5><p>… inner join … on …</p><p>内联查仅仅将两个表间有关联的记录拼接起来, 没有关联的记录会被丢弃</p><h5 id="外联查"><a href="#外联查" class="headerlink" title="外联查"></a>外联查</h5><p>mysql中外联查分为左外联查和右外联查</p><blockquote><p>用外联查会导致另一个表中不符合筛选的数据被填充为null</p></blockquote><p>左外联查以左表为基础, 右外联查以右表为基础</p><blockquote><p>左联查</p></blockquote><p>… left join … on …</p><blockquote><p>右联查</p></blockquote><p>… right join … on …</p><p>MySql回滚：</p><blockquote><p>如果数据库没有开启备份或者日志记录， 那么commit事务后是无法进行回滚操作的</p></blockquote><p>开启日志：binlog</p><p>在服务器上设置定时任务手动备份数据库文件</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库面试题</title>
    <link href="/2022/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL面试题"><a href="#SQL面试题" class="headerlink" title="SQL面试题"></a>SQL面试题</h1><h2 id="备份-x2F-恢复mysql数据库的几种方法-并说出其优缺点"><a href="#备份-x2F-恢复mysql数据库的几种方法-并说出其优缺点" class="headerlink" title="备份&#x2F;恢复mysql数据库的几种方法, 并说出其优缺点"></a>备份&#x2F;恢复mysql数据库的几种方法, 并说出其优缺点</h2><ol><li>使用mysqldump工具生成备份的sql</li><li>mysqlhoycopy, 热备份</li><li>使用tar打包整个数据库目录</li><li>使用Navicat工具</li></ol><h2 id="Mysql的索引有哪几种-为什么用B-树做索引"><a href="#Mysql的索引有哪几种-为什么用B-树做索引" class="headerlink" title="Mysql的索引有哪几种, 为什么用B+树做索引"></a>Mysql的索引有哪几种, 为什么用B+树做索引</h2><h2 id="redis中数据类型zset-跳表-的实现"><a href="#redis中数据类型zset-跳表-的实现" class="headerlink" title="redis中数据类型zset(跳表)的实现"></a>redis中数据类型zset(跳表)的实现</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构入门02</title>
    <link href="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A802/"/>
    <url>/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A802/</url>
    
    <content type="html"><![CDATA[<h1 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h1><p>常见的线性数据结构有: 数组(array) 链表(linked list) 栈(stack) 队列(queue)</p><p>数组: 连续存储结构, 存储的元素都是相同类型(相同空间大小)</p><p>数组一旦创建, 其空间大小固定, 不可改变(连续存储位置的特性导致的限制)</p><p>链表: 每个元素都是对象, 可以动态增加和删除元素, 其线性顺序由指针维护</p><p>链表的类型一般有四种, </p><ol><li>单链表: 一个节点只存储下一个节点的指针</li><li>双链表:一个节点存储两个节点的指针(上一个节点和下一个节点)</li><li>环状链表: 链表头尾相连构成一个环状结构, 因此可以从任意节点开始遍历整个链表</li><li>环状双链表:</li></ol><p>链表的缺点: 不允许随机访问</p><blockquote><p>在数组中访问第n个元素需要O(1)的时间, 链表中需要O(n)</p></blockquote><p><strong>stack</strong></p><p>栈是一种先进后出(FILO)的数据结构, 对栈的添加删除操作都只能在同一端进行</p><p>栈的常见操作:</p><ol><li>push 入栈</li><li>pop 出栈</li><li>top 返回栈顶的元素, 但不删除</li><li>size 返回栈当前元素总量</li></ol><p>栈通常有两种类型:  寄存器栈(固定容量) 内存栈(动态容量)</p><p><strong>queue</strong></p><p>队列是一种先进先出FIFO的数据结构, 主要有排队(添加新元素到顶部)和出列(删除尾部元素)</p><p>enqueuedequeue</p><p>队列分类:</p><ol><li>简单队列: 线性队列</li><li>循环队列: </li><li>优先级队列</li><li>双端队列: 可以在两端进行插入或删除操作的特殊队列, 不遵循FIFO规则</li></ol><p><strong>分层数据结构</strong></p><p>树是典型的分层数据结构</p><p>二叉树是一种特殊的树结构, 其每个节点最多只能有两个子节点(左子节点和右子节点)</p><p>二叉树的每个节点会包含三个部分: 数据 指向左子节点的指针, 指向右子节点的指针(因此树的遍历只能从父节点开始向子节点进行, 不能逆过来)</p><p>二叉树一般有两种方式来遍历: 深度优先遍历, 宽度优先遍历(水平顺序遍历)</p><p>深度优先遍历有三种:</p><ol><li>有序遍历: 根节点-左子节点-右子节点</li><li>预序遍历: 左子节点-根节点-右子节点</li><li>后序遍历: 左子节点-右子节点-根节点</li></ol><p>二叉树的基本操作:</p><ol><li>插入</li><li>删除</li><li>搜索</li><li>遍历</li></ol><p>二叉树的辅助操作:</p><ol><li>计算树的高度</li><li>计算树有多少层</li><li>计算整个树的节点数量</li></ol><p>二叉树的应用场景:</p><ol><li>霍夫曼编码树可以用于压缩数据</li><li>二叉树可以实现优先级队列</li></ol><p><strong>树遍历(travel tree)</strong></p><p>对于树或图有两种常用的遍历算法: DFS BFS</p><ol><li>DFS 深度优先搜索 (Depth First Search)</li><li>BFS 广度优先搜索(Breadth First Search)</li></ol><p><strong>二叉搜索树</strong>(BST) 是一种特殊的二叉树</p><p>BST要求: 左子节点和右子节点必须小于或等于父节点(对每个节点都有此要求)</p><p>BST的常用操作有</p><ol><li>查找最大最小值</li><li>删除特定元素</li><li>插入元素(需要在插入后仍满足BST要求)</li></ol><p>辅助操作:</p><ol><li>查找第k小的元素</li><li>判断一个二叉树是否满足BST的要求</li></ol><p>bst特性: 同时提供了速度适中的搜索和插入操作</p><p>搜索速度: 数组&gt;bst&gt;链表</p><p>插入删除操作: 链表&gt;bst&gt;数组</p><p><strong>二项堆</strong></p><p>二项堆是一种特殊的二叉树</p><p>要求:</p><ol><li>必须是完全树(每个层次都被填满)</li></ol><blockquote><p>二项堆的底层一般使用数组实现</p></blockquote><p><strong>散列(Hash)</strong></p><p>利用hash存储数据, 可以将搜索 删除 插入等操作的时间复杂度降低到O(1)的程度</p><blockquote><p>平均情况下的时间复杂度为O(1)</p></blockquote><p>散列函数(hash函数):可以将输入的数据转换为固定大小的整数值, 将对应的整数值作为索引, 将数据存储到hash表中</p><blockquote><p>由于hash函数的计算效率很高, 因此根据索引直接取数据的速度非常快</p></blockquote><p>hash插入时不需要考虑索引重复的情况, 因此插入速度非常快</p><p>hash函数应该做到以下四点:</p><ol><li>计算速度快</li><li>索引分布的位置均匀</li><li>尽可能降低碰撞概率</li><li>高负载系数</li></ol><p>hash表: hash表实质上是一个特殊的数组, 数组元素是指向对应数据的指针</p><p>通过hash表可以进行快速的元素搜索</p><p>hash碰撞: hash函数计算时有可能发生不同数据计算出相同的索引的情况, 必须对这种情况进行处理, 一般有三种处理方式</p><ol><li>链接, 将哈希表的单元格指向一个link list, 在列表中保存具有相同哈希值的数据</li><li>example: </li><li>开放寻址</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构入门</title>
    <link href="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/"/>
    <url>/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构入门"><a href="#数据结构入门" class="headerlink" title="数据结构入门"></a>数据结构入门</h1><p>数据结构是计算机中数据存储的一种特殊结构, 良好的数据结构可以减少占用的空间和缩短数据操作时间</p><p>数据结构分为线性数据结构和非线性数据结构</p><blockquote><p>在java中每种集合都有对应的数据结构</p></blockquote><p>线性数据结构: list queue stack array</p><blockquote><p>线性结构中的元素都是在同一个维度上, 只有一对一的关系, 不存在同等的元素</p></blockquote><p>非线性数据结构: tree graph table</p><blockquote><p>非线性结构允许元素可以在多个维度上面排列, 有一对多 多对一 多对多的关系</p></blockquote><h2 id="常见数据结构概述"><a href="#常见数据结构概述" class="headerlink" title="常见数据结构概述"></a>常见数据结构概述</h2><p><strong>线性数据结构</strong></p><ol><li><p>array: 数组是指存储在连续内存位置中的数据集合, 一个数组中的元素具有相同的数据类型, 可以通过下标来快速访问不同的元素位置</p><blockquote><p>数组元素位置是通过向基值(第一个元素的值)添加偏移量(根据下标决定)来计算</p></blockquote></li><li><p>链表(linklist): 链表与数组相似, 但是链表的元素不是连续存储的, 需要依靠指针将元素连接起来, 不能使用下标进行快速查找</p></li><li><p>栈(stack): 栈是遵循LIFO(后进先出)操作顺序的线性结构, 并且只能在指定的一端进行push(添加元素)操作(无法在另一端也进行添加操作)(从一端进去, 并且从同一端出去)</p></li><li><p>queue(队列): 与栈类似, 但是是遵循FIFO的顺序(从一端进从另外一端出来)</p></li></ol><p>栈的基本操作有:</p><ol><li>初始化: 将stack的元素都设为空</li><li>push: 将一个新元素添加到stack中, 如果栈满了将发生溢出现象</li><li>pop: 按照push的相反方向将元素从栈中删除</li><li>peek(或者top): 返回栈顶部的元素</li><li>isEmpty: 如果整个堆栈都是空的将返回true, 否则返回false</li></ol><p>队列的基本操作:</p><ol><li>enqueue: 将一个新元素加到队列中, 队列满会发生溢出现象</li><li>dequeue: 将一个元素从队列的最前端中删除</li><li>font: 获取队列最前端的元素</li><li>rear: 获取队列最后端的元素</li></ol><p>常见非线性结构:</p><ol><li>binary tree(二叉树)</li><li>heap(堆)</li><li>Hashing(散列)</li><li>Matrix(矩阵)</li><li>Trie(键树)</li></ol><p>其中 二叉树 堆 键树都属于树状结构</p><p>二叉树: 每个节点最多只能有两个节点(左节点, 右节点), 使用link</p><p>堆: 堆是一种特殊的二叉树, 通常分为大顶堆(max-heap)和小顶堆(min heap), 大顶堆要求父节点必须大于或等于子节点, 小顶堆要求父节点必须小于或等于子节点</p><p>散列: Hashing使用hash函数来将值映射为键, 映射效率(查询效率)取决于hash函数的效率</p><p>数据结构也分为静态数据结构和动态数据结构</p><p>静态数据结构: 声明后内存空间固定不变</p><p>动态数据结构: 声明后内存空间可以动态变化</p><p><strong>数组</strong></p><p>数组是一种连续存储且大小固定的数据结构, 是一种关键的底层数据结构</p><p>由于数组的连续储存和大小固定特性, 使得数组的操作效率非常高, 并且提供了非常丰富的操作功能</p><p>数组特性:</p><ol><li><p>提供了每个元素的索引, 可以根据索引快速查找元素</p></li><li><p>数组中的元素都是相同数据类型, 并且元素个数固定</p></li><li><p>数组可以通过多维数组实现其他复杂的数据结构</p><blockquote><p>如stack 队列 堆 哈希表</p></blockquote></li><li><p>数组元素的遍历非常快</p></li></ol><p>数组的应用:</p><ol><li>数组库的记录由数组存储</li><li>图像处理</li><li>数学计算</li></ol><p>链表:</p><p>链表的元素存储是不连续的, 元素间通过指针进行链接</p><p>链表类型: 单链表 双重链表 循环链表 双重循环链表</p><p>单链表表示一个元素只有一个链接</p><p>双链表表示一个元素有两个链接</p><p>链表特点:</p><ol><li>链表的每个节点除了存储元素值外还需要额外内存存储链接</li><li>链表中的元素是可变的, 不需要固定</li><li>链表的第一个节点为头节点(Head)</li><li>最后一个节点的指针一定是指向NULL</li><li>链表中插入和删除操作非常快</li></ol><p>链表的应用:</p><ol><li>实现堆栈 队列 graph</li><li>用于内存管理</li></ol><p>二叉搜索树:</p><p>二叉搜索树是一种特殊的二叉树, 左子节点必须小于或等于父节点, 右子节点必须大于或等于父节点</p><p>堆:</p><p>堆是一种特殊的二叉树</p><p>stack:</p><p>栈是一种只能从同一端进行添加和删除操作的数据结构(后进先出)</p><p>栈一般使用一维数组或链表实现, 也被称为顺序栈或链式栈</p><p>栈的底层通过数组和链表实现</p><blockquote><p>栈的内存是固定的, 添加的元素超过栈空间时会导致栈溢出</p></blockquote><p>栈的应用: 反转字符串(将数据顺序颠倒) , 内存管理</p><p><strong>队列(queue)</strong></p><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/image-20220722093442308.png" alt="image-20220722093442308"></p><p>队列是线性结构, 遵循FIFO(先进先出)的顺序</p><p>队列的添加和删除操作是发生在不同端</p><p>队列的基本操作: enqueue(添加) rear(队尾) front(队头) dequeue(删除)</p><p><strong>Tree(树)</strong></p><p>树是非线性分层结构, 也被称为递归结构</p><p>树的属性:</p><p>高度: 树的高度 &#x3D; 根节点的高度 &#x3D; 叶子节点的最大深度</p><p>深度: 根节点的深度为0, 从根节点开始每层节点加深一层深度</p><blockquote><p>使用树结构存储数据可以实现快速访问数据(树遍历)</p></blockquote><p>树结构示例</p><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/image-20220801101451352.png" alt="image-20220801101451352"></p><p>树的应用场景:</p><ol><li>在数据库作为索引结构: B+树</li><li>路由器使用生成树协议(Spanning Tree Protocol)预防环路产生提高可靠性</li></ol><p><strong>Graph(图)</strong></p><p>图是由边和顶点组成的非线性数据结构, 通常用于解释非常复杂的编程问题(图论Graph Theory)</p><blockquote><p>图结构示例</p></blockquote><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/image-20220801112438840.png" alt="image-20220801112438840"></p><p>图的应用场景:</p><ol><li>地图</li><li>社交网络的关系图</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构入门03</title>
    <link href="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A803/"/>
    <url>/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A803/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构入门03"><a href="#数据结构入门03" class="headerlink" title="数据结构入门03"></a>数据结构入门03</h1><p><strong>graph&#x2F;图</strong></p><p>图由两个部分组成: 顶点 边(注意边可以包含方向 权重 等属性)</p><p>如果一个图包含了方向或权重属性则被称为有向图或加权图</p><blockquote><p>图的多种表现形式</p></blockquote><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A803/image-20220804102316331.png" alt="image-20220804102316331"></p><blockquote><p>以矩阵的形式表示图</p></blockquote><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A803/image-20220804102343406.png" alt="image-20220804102343406"></p><blockquote><p>邻接列表表示图</p></blockquote><p><img src="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A803/image-20220804102410066.png" alt="image-20220804102410066"></p><p>**前缀树(Trie)**也被称为 基数树&#x2F; 字典树</p><p>常用于在字典中根据前缀搜索单词, 其优点是没有hash表的碰撞问题, 搜索较快O(n) ,但是需要较大的空间用于存储(因为需要将单词拆分为一个个字母进行存储)</p><p>通常用于处理单词相关的用途: 搜索单词, 拼写检查</p><p><strong>后缀树(Suffix Tree)</strong></p><p>后缀树的主要用途是在文本进行模式搜索(KMP Z)</p><p>一般的模式搜索耗费的时间与文本长度成正比, 但是通过后缀树将文本进行预处理后可以极大的提升模式搜索速度</p><blockquote><p>由于后缀树使用时通常要先进行预处理将文本转换为后缀树, 因此不能用于频繁更改的文本(每次更改都需要进行一次预处理)</p></blockquote><p>矩阵: 矩阵可以视为一个二维数组, 通过两个数组(行\列)的位置作为矩阵元素的坐标</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构面试题</title>
    <link href="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构面试题"><a href="#数据结构面试题" class="headerlink" title="数据结构面试题"></a>数据结构面试题</h1><h2 id="简单说下哈希表-HashMap"><a href="#简单说下哈希表-HashMap" class="headerlink" title="简单说下哈希表(HashMap)"></a>简单说下哈希表(HashMap)</h2><h2 id="链地址法和探测法"><a href="#链地址法和探测法" class="headerlink" title="链地址法和探测法"></a>链地址法和探测法</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>整理面试题模板</title>
    <link href="/2022/11/03/%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/11/03/%E6%95%B4%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="部署代码到云服务器上面？"><a href="#部署代码到云服务器上面？" class="headerlink" title="部署代码到云服务器上面？"></a>部署代码到云服务器上面？</h3><h4 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h4><p><img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/hekai/20220830193558.png" alt="image-20220830193558069"></p><h4 id="2-一些命令"><a href="#2-一些命令" class="headerlink" title="2. 一些命令"></a>2. 一些命令</h4><p>java 的命令：   java -xxx.jar 的命令  boot详细如何动态的修改 port (1.通过启动命令修改 2.通过application.yml 文件修改)</p><p>git 的版本关联:  提交代码,拉取 git status  分支 xxx</p><p>mvn       打包   install  </p><p>docker 的命令   docker xxx xxx</p><p>linux的命令:    路径 &#x2F;  文件的操作  、查看进程 , xxx </p><h4 id="3-项目-jenkins"><a href="#3-项目-jenkins" class="headerlink" title="3 项目 (jenkins)"></a>3 项目 (jenkins)</h4><p>  1，git 提交   2.maven构建  3.java启动 </p><h3 id="spring的aop？"><a href="#spring的aop？" class="headerlink" title="spring的aop？"></a>spring的aop？</h3><h4 id="1-aop的概念-解决的问题"><a href="#1-aop的概念-解决的问题" class="headerlink" title="1.aop的概念 解决的问题"></a>1.aop的概念 解决的问题</h4><p>  切面 、通知  ,切点 ,配置</p><h4 id="2-spring的aop是怎么回事"><a href="#2-spring的aop是怎么回事" class="headerlink" title="2. spring的aop是怎么回事"></a>2. spring的aop是怎么回事</h4><ol><li>jdk动态代理     源码  jvm中的字节码 方法的调用 （在 invohandler这个接口进行增强） 缺点</li><li>cglib 动态代理  创建一个代理类 (把当前的类 进行继承 扩展了方法)  缺点</li><li>springaop的封装 …  aspect xxx 使用起来方便</li></ol><h4 id="3-怎么使用"><a href="#3-怎么使用" class="headerlink" title="3. 怎么使用?"></a>3. 怎么使用?</h4><ol><li><p>项目中的日志处理     拿到登录的用户&#x2F;方法的调用 封装成日志 存储到mysql中</p></li><li><p>事务        事务传播、配置事务  事务失效 </p></li><li><p>注解实现 + redis实现了限流 ( 接口操作 的幂等性 )</p><pre><code class="hljs">   1. 自定义注解   2. aop切到方法中   3. 判断注解 + redis + 业务代码</code></pre></li></ol><h4 id="4-aop遇到的一些问题"><a href="#4-aop遇到的一些问题" class="headerlink" title="4. aop遇到的一些问题"></a>4. aop遇到的一些问题</h4><ol><li>事务失效</li><li>项目不能启动xxx</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>方法重载</title>
    <link href="/2022/11/03/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/11/03/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>Java允许同一个类里有多个重名的方法, 但是要求重名的方法对应的形参列表不能相同</p><p>如果一个类中包含多个方法名相同, 但是形参列表不同的方法, 就称为方法重载</p><p>(返回值不同不能作为方法重载的条件)</p><p>在Java中确定一个方法需要<strong>三要素</strong></p><ol><li>调用者 方法的所属者, 可以是类或对象</li><li>方法名 方法对应标识符</li><li>形参列表 调用方法时候, 实参的值将被赋值给形参</li></ol><p>形参个数可变的方法也可以被重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String... args)</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String args)</span>&#123;&#125;<br><span class="hljs-comment">//public void test(String[] args)&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>第二行代码传入参数只有一个, 可以作为test方法的方法重载</p><p>但是第三行代码不行</p><blockquote><p>不建议重载形参个数可变的方法, 因为会导致程序可读性的下降</p></blockquote><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>从功能上来看, 面向对象中的方法类似于结构化程序里面的函数, 但是Java里面的方法不能独立于对象, 必须定义在类里面</p><p>面向对象三大基本特征: 封装(Encapsulation) 继承(implement) 多态(polymorphism)</p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>在Java中, 类是一种引用变量</p><p>面向对象程序设计的重要概念: 类 对象</p><blockquote><p>对象是类的实例 类是对象的抽象</p></blockquote><p>类的修饰符有 public final abstract, 也可以不加修饰符</p><p><strong>类是Java程序的基本单位</strong></p><p>类包含三种最常见的成员: 构造器 成员变量 方法</p><p>如果一个类不包含任何成员, 则其为空类</p><p>static修饰的成员不能访问非static成员, 只能访问其他用static修饰的成员</p><p>Java中通过new 关键字来调用对应类的构造器, 构造器会返回该类的一个实例</p><p>构造器是类创建对象的默认途径</p><p>没有构造器的类通常无法创建实例</p><p>如果没有自定义的构造器, 系统会自动为类生成一个构造器</p><h1 id="类-class"><a href="#类-class" class="headerlink" title="类(class)"></a>类(class)</h1><p>类是一种特殊的数据类型, 在Java里面使用类定义的变量都是引用变量(全局变量)</p><p>类用于描述具有相同特征(相似属性)的某一类对象</p><p>对象是类的实例</p><p>在Java中对象是通过调用对应类的构造器类创建的</p><blockquote><p>面向对象三大特征: 封装 继承 多态</p></blockquote><p>在Java中提供了三个访问控制修饰符来实现封装</p><p>private protected public</p><p>extends关键字来实现继承</p><p>通过继承, 子类可以继承父类中的成员变量(类中方法外的变量)和方法</p><p>访问控制允许的情况下, 子类实例(对象)可以直接调用父类中方法</p><blockquote><p>继承是实现类复用的重要手段, 类的复用也可以通过组合关系来实现 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br></code></pre></td></tr></table></figure><p>上述代码将子类的对象赋值给了父类变量, 使得该变量具有了多态性</p><blockquote><p>如果是用组合关系来实现复用, 无法这样子来实现多态</p><p>灵活性差</p></blockquote><p>Java中通过构造器来对类的实例进行初始化, 构造器支持重载</p><p>如果多个重载的构造器包含相同的代码, 可以考虑将代码块放入类的初始化代码块中</p><blockquote><p>类的初始化代码块的执行会早于构造器</p></blockquote><p><strong>当一个子类被初始化时, 系统会自动初始化它的所有父类</strong></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>类中的属性有: 类成员属性和实例成员属性</p><p>区别在于是否被static修饰符修饰</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/11/03/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/11/03/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><strong>java5中引入参数化类型(parameterized type)的概念,也就是泛型(Generic)</strong></p><p><strong>泛型允许在创建集合时指定元素的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明了一个String泛型的集合al</span><br>ArrayList&lt;String&gt; al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-comment">//java7后可以省略菱形语法</span><br>ArrayList&lt;String&gt; al2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>ArrayList&lt;String&gt; al2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();f<br></code></pre></td></tr></table></figure><p>为了实现集合的通用性:可以保存不同类型的对象元素, 集合中的元素都以Object类型来保存(编译类型)</p><blockquote><p>防止编译器检查报错</p></blockquote><blockquote><p>注意运行时类型没有变, 依旧为原类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList al=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Collections.addAll(al,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span> (Object o : al) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span>(String)o;<br>    str.indexOf(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//上述代码运行会报错, 因为列表中包含Integer类型</span><br>    <span class="hljs-comment">//ine类型字面量被自动装箱生成的Integer类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>泛型可以规范集合的元素类型</p><blockquote><p>本质是在编译时进行检查集合中的元素是否为泛型规定的类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Collections.addAll(al, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">//编译时会报错, 因为向String泛型的列表中添加了Integer类型的变量</span><br><span class="hljs-keyword">for</span> (Object o : al) &#123;<br>    System.out.println((o <span class="hljs-keyword">instanceof</span> Integer));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>了解泛型接口和泛型类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyList</span>&lt;String&gt;&#123;<br>&#125;<br><span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;String&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyList</span>&lt;String&gt;&#123;<br>&#125;<br><span class="hljs-comment">//调用测试</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyList&lt;String&gt; datas=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrayList</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型通配符</strong></p><p>java只有一个泛型通配符</p><p>?  代表不确定的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(ArrayList&lt;?&gt; dates)</span>&#123;&#125;<br>    <span class="hljs-comment">//匹配任何类型</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show1</span><span class="hljs-params">(ArrayList&lt;? extends Number&gt; dates)</span>&#123;&#125;<br>    <span class="hljs-comment">//设定通配符上限</span><br>    <span class="hljs-comment">//必须是继承自Number类</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">(ArrayList&lt;? <span class="hljs-built_in">super</span>  Integer&gt; dates)</span>&#123;&#125;<br>    <span class="hljs-comment">//设定通配符下限</span><br>    <span class="hljs-comment">//必须是Integer的父类</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型形参</strong></p><p>通常有以下常用的字母用于泛型形参</p><ol><li>T  代表确定的类型</li><li>K V分别代表键(Key)值(Value)</li><li>E  代表Element</li></ol><blockquote><p>这里意义是习惯默认的, 并非是强制的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匹配任意类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(ArrayList&lt;?&gt; datas)</span>&#123;&#125;<br><span class="hljs-comment">//注意在这里只有?是可以使用的</span><br>&#125;<br><span class="hljs-comment">//在泛型接口中, 可以用泛型形参</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(ArrayList&lt;E&gt; datas)</span>&#123;&#125;<br>    <span class="hljs-comment">//并且泛型形参只能用于实例方法, 不能用于类方法</span><br>    <span class="hljs-comment">//因为需要在创建对象时将类型传给通配符才有实际意义</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Test</span>&lt;String&gt;&#123;&#125;<br><span class="hljs-comment">//将String类型传入形参E</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Test</span>&#123;&#125;<br><span class="hljs-comment">//省略泛型将导致使用原始类型(raw type), T将被编译器视为Object类型处理</span><br></code></pre></td></tr></table></figure><p><strong>泛型擦除</strong></p><p><strong>泛型擦除指泛型只会在编译时进行检查, 并且所有泛型参数在编译后都会被清除, 不会保留到运行时</strong></p><blockquote><p>泛型的本质是在编译时对代码进行检查, 因此运行时是可以对泛型集合添加任意类型的对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(ArrayList&lt;String&gt; al)</span>&#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(ArrayList&lt;Integer&gt; al)</span>&#123;&#125;<br><span class="hljs-comment">//上面两个方法不是方法重载, 由于泛型擦除的特性,所以它们的参数列表是相同的</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ArrayList<String>并非一个新的类, 它与ArrayList是同一个类(实质上等同于ArrayList<Object>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; l1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; l2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>System.out.println(l1.getClass());<br><span class="hljs-comment">//l1的类型为ArrayList</span><br>System.out.println(l2.getClass());<br><span class="hljs-comment">//l2的类型为ArrayList</span><br><span class="hljs-comment">//所以l1跟l2的类型相同</span><br></code></pre></td></tr></table></figure><p><strong>泛型形参不能用于类(static)成员</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] intList =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">5</span>];<br>Number[] doublesList=intList;<br>doublesList[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>doublesList[<span class="hljs-number">1</span>]=<span class="hljs-number">0.5</span>;<br><span class="hljs-comment">//这行代码不会被编译器检查出错误, 但是在运行时会抛出ArrayStoreException, 因为0.5无法被存储为Integer类型</span><br><span class="hljs-comment">//这里是java早期的设计缺陷</span><br></code></pre></td></tr></table></figure><blockquote><p>优秀的编程语言不仅需要提供强大的功能, 更需要在编译时能提供错误提示, 做到在程序运行前就检查出错误</p></blockquote><p>在泛型设计时, java增强了编译检查的设计,不允许将引用变量指向不同类型的泛型对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; iList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>List&lt;Number&gt; nList=iList;<br><span class="hljs-comment">//上述代码将导致编译错误, 避免了程序运行时出现ClassCastException</span><br></code></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类也被称为嵌套类, 它放在另一个类内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>    <span class="hljs-comment">//定义了一个非static内部类Inner</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInner</span>&#123;&#125;<br>    <span class="hljs-comment">//定义了一个static内部类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内部类特点:</p><ol><li>内部类可以提供更好的封装</li><li>内部类可以访问外部类私有(private)成员, 因为内部类本身被视为private成员的一部分, 但是外部类无法访问内部类的成员</li><li>特殊内部类: 匿名内部类适合用于仅需要创建一次类的用途</li><li>外部类不能用的修饰符private protected static可以用于内部类</li><li>只有static修饰的内部类才能有static成员</li></ol><blockquote><p>注意在一个源文件里可以定义多个外部类, 它们都是相互独立的</p></blockquote><p>外部类的上级单元是包</p><p><strong>外部类只有两个不同的作用域: 同一个包内, 任何位置 分别对应default(包权限)和public(任何位置)权限</strong></p><blockquote><p>同一个包内的不同源文件属于同一个作用域</p></blockquote><p>内部类有4个作用域, public(任何位置) protected (父子类) default(同一个包) private(同一个类)</p><p><img src="/2022/11/03/%E6%B3%9B%E5%9E%8B/image-20220510153945868.png" alt="image-20220510153945868"></p><p>static内部类可以包含非static成员, 但是static成员不能访问非static成员</p><blockquote><p>外部类不能被static修饰</p></blockquote><blockquote><p>接口也可以定义内部接口, 但是一般开发中不需要用到内部接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner2</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test43</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        Outer.Inner inner= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() ;<br>        <span class="hljs-comment">//创建外部类对象来创建非static内部类对象</span><br>        Outer.Inner inner0= out.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() ;<br>        <span class="hljs-comment">//调用已存在外部类对象来创建非static内部类对象</span><br>        Outer.<span class="hljs-type">Inner2</span> <span class="hljs-variable">inner2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner2();<br>        <span class="hljs-comment">//直接通过外部类来创建static内部类对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内部类的调用必须在前面加上其外部类的前缀</strong></p><p><strong>创建内部类对象前必须先创建外部类对象</strong></p><p><strong>非static内部类的构造器必须由外部类对象来调用</strong></p><blockquote><p>意味着</p><ol><li>非static内部类创建对象需要先创建&#x2F;存在有外部类对象</li><li>非static内部类被继承的子类创建对象时也需要由外部类对象来调用</li></ol></blockquote><blockquote><p>在方法中定义的类为局部(方法)内部类, 实际开发中很少用到</p></blockquote><blockquote><p>扩展: 局部(方法内)变量</p></blockquote><blockquote><p>由于同一个类中的多个局部内部类可以同名,所以javac会将局部内部类的class文件命名时加上数值</p><p>OuterClass$NInnerClass.class</p></blockquote><p><strong>多态就是指调用相同名字的方法会表现出不同的行为</strong></p><p>Java中有两种类型的多态: 编译时多态(static)(静态和运行时多态(no-static)(动态)</p><p>编译时多态: 方法重载</p><p>运行时多态: 方法重写</p><blockquote><p>? 运算符多态不确定</p></blockquote><blockquote><p>Polymorphism is the ability to process objects differently on the basis of their class and data types</p></blockquote><p>面向对象编程(OOP) :Object-oriented programming </p><p>在Java中多态有三种类型的实现方式:</p><ol><li><p>方法重写(override) 子类重写超类的同名方法</p></li><li><p>方法重载(overload) 同名不同参数列表的方法 </p></li><li><p>运算符重载 同一种运算符会因为操作数类型不同导致运算方式不同</p><blockquote><p>例如+运算符不仅用于加法运算, 还可以用于字符串拼接 </p><p>运算符 &amp; | !可以用于逻辑运算和按位运算</p></blockquote></li></ol><p><strong>面向对象的四个基本概念: 封装 继承 多态 抽象</strong></p><p>面向对象的三个基本特征: 封装 继承 多态</p><p>encapsulation inheritance polymorphism</p><p>继承(inherit)与派生(derive)是同一现象的不同方向</p><p>抽象 abstract</p><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类没有类名, 直接用花括号声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-comment">//内部类Inner</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>    &#123;<br>        <span class="hljs-comment">//初始化块</span><br>    &#125;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//静态初始化块</span><br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//创建匿名内部类实例</span><br>        Outer out=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>() &#123;<br>            <span class="hljs-comment">//匿名内部类的类体</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意不要将初始化块跟匿名内部类弄混</p></blockquote><blockquote><p>抽象类中可以没有抽象方法, 但是有抽象方法的类一定是抽象类</p></blockquote><ol><li>匿名内部类一定是非抽象类</li><li>匿名内部类只能用系统默认提供的构造器或者从父类中继承的自定义构造器, 但是可以自定义初始化块</li></ol><p>匿名内部类必须在定义时实现一个接口或者继承父类, 而且只能实现或继承一次</p><p><strong>匿名内部类特点</strong></p><ol><li>匿名内部类没有类名, 意味着它无法被外部使用名字调用,只能在创建时使用一次</li><li>匿名内部类的定义与实例的构造同时进行</li><li>匿名内部类属于一种特殊的方法内部类</li></ol><p><strong>匿名内部类通常用于定义一个一次性使用的类</strong></p><p>匿名内部类只能创建一个对象</p><blockquote><p>类似于单例类(Singleton)</p><p>但是单例类可以重复使用, 匿名内部类只能使用一次, 由于没有类名所以无法再次调用匿名内部类</p></blockquote><p><strong>匿名内部类会继承父类中的有参构造器</strong></p><p>**普通的子类只会调用父类中的无参构造器</p><p><strong>匿名内部类必须实现继承的所有的抽象方法, 也可以重写普通方法</strong></p><p>匿名内部类访问的局部变量必须被final修饰</p><p>Java8提供了effectively final功能, 会自动将匿名内部类访问的局部变量用final修饰</p><blockquote><p>意味着匿名内部类可以访问没有被显式final修饰的局部变量, 但是一旦访问该局部变量会被系统自动用final修饰</p></blockquote><p>匿名内部类无法访问已经被指定初始值的局部变量, 因为该变量已无法被自动用final修饰</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p><strong>LinkedList既是List也是双向队列也是栈</strong></p><blockquote><p>而ArrayList不属于双向队列和栈</p></blockquote><p>在java中, LinkedList属于List集合的一种, 可以根据索引进行随机访问元素</p><blockquote><p>随机访问指随机访问集合中的元素, 相对于有序访问</p><p>有序访问指按顺序遍历元素的形式去访问元素</p></blockquote><p>LinkedList属于数据结构中的双向链表结构</p><blockquote><p>LinkedList是List和Deque的实现类</p><p>因此LinkedList也可以作为双向队列使用</p><p>List既可以作为栈, 也可以作为队列</p></blockquote><p><img src="/2022/11/03/%E6%B3%9B%E5%9E%8B/image-20220518165702335.png" alt="image-20220518165702335"></p><blockquote><p>双向链表的每个元素会存储:</p><p>上个元素的索引下一个元素的索引当前元素值</p></blockquote><blockquote><p>展示了LinkedList各种API的使用, 大部分API与ArrayList相同</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;String&gt; ll=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>Collections.addAll(ll,<span class="hljs-string">&quot;bdd&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;bcd&quot;</span>,<span class="hljs-string">&quot;小李&quot;</span>);<br>ll.get(<span class="hljs-number">0</span>);<br>ll.size();<br>ll.set(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ll&quot;</span>);<br>ll.contains(<span class="hljs-string">&quot;小李&quot;</span>);<br>ll.remove(<span class="hljs-number">1</span>);<br>ll.clear();<br>Collections.addAll(ll,<span class="hljs-string">&quot;bdd&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;bcd&quot;</span>,<span class="hljs-string">&quot;小李&quot;</span>);<br><br>ll.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;s&quot;</span>);<br>    &#125;<br>&#125;);<br>Collections.sort(ll);<br>System.out.println(ll);<br></code></pre></td></tr></table></figure><p>LinkedList和ArrayList的区别</p><table><thead><tr><th>LinkedList</th><th>ArrayList</th></tr></thead><tbody><tr><td>底层是链表结构</td><td>底层是数组结构</td></tr><tr><td>新增, 删除元素的效率高</td><td>新增, 删除元素的效率低</td></tr><tr><td>查询元素的效率低</td><td>查询元素的效率高</td></tr></tbody></table><blockquote><p>LinkedList在插入或删除只需要改变前后元素指针指向的地址即可, 不需要对集合的每个元素都进行操作, 因此性能出色</p><p>但是随机访问性能较差</p><p>ArrayList由于是用数组进行存储, 所以随机访问的性能高</p></blockquote><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector属于List集合的一种</p><blockquote><p>Vector是一种非常古老的集合实现, </p></blockquote><p>Vector的底层原理和API都与ArrayList相同</p><p>区别在于Vector是线程安全的, ArrayList不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; lv=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>lv.add(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-comment">//注意Vector中实例方法的源码是被synchronized修饰的线程安全方法</span><br>lv.add(<span class="hljs-string">&quot;113&quot;</span>);<br>Collections.sort(lv);<br></code></pre></td></tr></table></figure><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set的特点:</p><ol><li><p>Set的实现类可以有序也可以无序</p></li><li><p>Set的元素值不允许有重复(相同)的</p></li><li><p>Set没有下标, 不能通过下标去访问元素</p><blockquote><p>通过下标访问元素是List集合的重要特征</p></blockquote></li></ol><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>HashSet是Set的实现类, 底层使用HashMap的Key键作为元素值</p><p>HashSet特点:</p><ol><li>元素是无序的</li><li>不允许有重复元素</li><li>没有下标</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Set&lt;String&gt; stringSet1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>Collections.addAll(stringList,<span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ww&quot;</span>, <span class="hljs-string">&quot;tq&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;zl&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>);<br>Collections.addAll(stringSet1,<span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ww&quot;</span>, <span class="hljs-string">&quot;tq&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;zl&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>);<br>Set&lt;String&gt; stringSet2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(stringList);<br>System.out.println(stringList);<br>System.out.println(stringSet1);<br>System.out.println(stringSet2);<br><span class="hljs-comment">//stringSet1和stringSet2的元素内容和顺序是完全相同的</span><br><span class="hljs-comment">//说明HashSet虽然是无序存储的, 但是如果两个Set的元素内容相同的,则它们的元素存储也是按相同的顺序</span><br></code></pre></td></tr></table></figure><p>HashSet实例方法:</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>add</td><td>添加元素(无序)</td></tr><tr><td>size</td><td>显示元素个数</td></tr><tr><td>contains</td><td>是否包含某元素值</td></tr><tr><td>remove</td><td>删除某个元素值</td></tr><tr><td>forEach</td><td>迭代方法, 需要实现一个函数接口的元素展示方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; stringSet1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>Collections.addAll(stringSet1,<span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ww&quot;</span>, <span class="hljs-string">&quot;tq&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;zl&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>);<br>stringSet1.add(<span class="hljs-string">&quot;123&quot;</span>);<br>stringSet1.size();<br>stringSet1.contains(<span class="hljs-string">&quot;123&quot;</span>);<br>stringSet1.remove(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-comment">//通过匿名内部类实现了Consumer函数接口的accept方法</span><br>stringSet1.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">//通过lambda表达式实现</span><br>stringSet1.forEach((str)-&gt;&#123;<br>    System.out.println(str);<br>&#125;);<br><span class="hljs-comment">//for循环遍历set</span><br><span class="hljs-keyword">for</span> (String s : stringSet1) &#123;<br>    System.out.println(s);<br>&#125;<br><span class="hljs-comment">//通过迭代器实现遍历</span><br>Iterator it=stringSet1.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    System.out.println(it.next());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>注册中心</title>
    <link href="/2022/11/03/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2022/11/03/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p>Spring Cloud Config是</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2022/11/03/%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/03/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>复杂度分为时间复杂度和空间复杂度, 两者被用来衡量(描述)一个程序或者算法的效率</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度用于衡量算法的快慢</p><p>时间复杂度需要考虑到算法所处理的数据的规模大小, 算法的执行时间一般与数据规模呈正相关关系</p><p>为什么时间复杂度需要考虑数据规模:</p><p>不同的算法在不同数据规模下的运行时间不同</p><blockquote><p>如果算法a和b的时间复杂度为100n和n^2, 在100n</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列 MQ</title>
    <link href="/2022/11/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20MQ/"/>
    <url>/2022/11/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20MQ/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列-MQ-Message-Queue"><a href="#消息队列-MQ-Message-Queue" class="headerlink" title="消息队列 MQ(Message Queue)"></a>消息队列 MQ(Message Queue)</h1><p>消息队列中间件也被称为MQ(Message Queue)是分布式系统的关键组件 用于解决项目解耦, 异步信息, 流量消峰等问题, 使用中间件可以实现高性能 高可用 可伸缩 最终一致性</p><blockquote><p>常用的消息队列中间件有: ActiveMQ RabbitMQ ZeroMQ Kafka RocketMQ</p></blockquote><p><strong>消息队列使用场景</strong></p><ol><li>异步处理任务</li><li>系统解耦</li><li>流量削峰(流量消费)</li></ol><p>场景举例: </p><p><strong>异步处理任务</strong></p><p>用户注册后需要发送注册邮件和注册短信</p><p>串行实现: 依次完成三个任务后再返回信息给客户端</p><p><img src="/2022/11/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20MQ/image-20220822105605962.png" alt="image-20220822105605962"></p><p>并行实现: 将注册信息写入数据库后同时执行剩下的两个任务</p><p><img src="/2022/11/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20MQ/image-20220822105722978.png" alt="image-20220822105722978"></p><p>MQ实现: 将发送邮件 短信两个任务放到消息队列中执行, 直接返回注册成功信息给客户端</p><blockquote><p>消息队列中的任务属于非必须任务逻辑, 可以异步处理</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法入门</title>
    <link href="/2022/11/03/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/11/03/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="算法入门"><a href="#算法入门" class="headerlink" title="算法入门"></a>算法入门</h1><p>算法是指程序解决计算问题需要遵循的一组规则&#x2F;有限的步骤</p><blockquote><p>算法与具体的语言无关, 但是解决问题时我们需要使用特定的语言编写程序去实现算法</p></blockquote><p>算法必须具备的特性:</p><ol><li>清晰明确, 不可以有模糊描述</li><li>必须在有限时间内结束</li><li>明确的输入: 算法接收的输入应该是预先定义好范围和类型的</li><li>输出的明确性: 算法应该明确定义好将要产生的输出</li><li>输出的确定性: 相同的输入必须产生相同的输出</li><li>与特定语言无关, 但是可以编写程序来实现算法</li></ol><blockquote><p>算法的输入有0个或多个, 输出必须有一个或以上</p></blockquote><p>算法优点:</p><ol><li>算法通常很容易理解</li><li>根据算法可以解决特定的编程问题</li></ol><p>算法缺点:</p><ol><li>编写算法需要长时间思考</li><li>算法无法解决复杂的业务问题(业务中的大量if判断(分支)语句和循环语句很难用算法去描述)</li></ol><h2 id="算法类型"><a href="#算法类型" class="headerlink" title="算法类型"></a>算法类型</h2><p>常用的算法有:</p><ol><li><p>暴力算法: 解决问题的最简单算法, 通常情况下时间复杂度较高</p></li><li><p>递归算法: 将问题分为数个子问题, 重复调用相同的函数来解决子问题</p><p>动态规划可以视为递归算法的特殊解(路径概念)</p></li><li><p>回溯算法: 回溯算法通过遍历所有可能的解决方案来构建最终解决方案</p><p>当一个解决方案失败时,回溯到前一个状态, 直到满足最终要求 </p></li><li><p>搜索算法: 在一组数据中搜索满足要求的元素或多个元素</p></li><li><p>排序算法: 将一组数据以特定的顺序重新排列, 通常用于递增或递减排序</p></li><li><p>哈希算法: 根据输入产生特定的hash值, 通常用于搜索数据</p></li><li><p>分治算法: 将问题拆分为子问题, 将子问题单个解决后再全部合并得出最终解</p><p>通常有3个步骤: 拆分 解决子问题 合并</p></li><li><p>贪婪算法: 分步骤确定解决方案, 在每个步骤中将选择当前的最优解, 但是贪婪算法的结果很可能不是整个问题的最优解</p></li><li><p>动态规划算法(DP): 将问题拆分为多个类似的子问题来解决, 在DP中找到状态和状态转移函数是解决问题的关键</p></li><li><p>图算法: 用于处理路径相关的问题</p></li><li><p>随机算法: 用于产生随机数</p></li></ol><h2 id="设计算法"><a href="#设计算法" class="headerlink" title="设计算法"></a>设计算法</h2><p><strong>设计一个算法的步骤:</strong></p><ol><li>理解要解决的问题的定义</li><li>考虑问题的约束条件</li><li>确定输入</li><li>确定预期的输出</li><li>确定解决问题的方法是在约束范围内(是否可以调用系统或第三方提供的类库中的方法)</li><li>测试算法的输出是否符合要求</li></ol><h2 id="分析算法的时间复杂度和空间复杂度"><a href="#分析算法的时间复杂度和空间复杂度" class="headerlink" title="分析算法的时间复杂度和空间复杂度"></a>分析算法的时间复杂度和空间复杂度</h2><p>算法的分析分为先验分析和后验分析</p><p>先验分析: 在写算法前在理论上分析</p><p>后验分析: 编程程序实现算法后再对其进行测试分析</p><p>空间复杂度: 算法在计算过程中使用的变量需要占用的内存大小</p><p>空间复杂度一般分为两个部分计算:</p><ol><li>固定部分: 输入 输出 </li><li>可变部分: 临时变量 递归栈空间</li></ol><p>时间复杂度: 算法执行得到结果所需的时间, 一般还与数据规模有关</p><p>分为两部分计算:</p><ol><li>常数部分: 只需要执行一次, 例如分支语句</li><li>可变部分: 需要执行多次, 例如 循环语句 递归</li></ol><p>分析要考虑三种情况:</p><ol><li>最佳情况: 算法花费最短时间的情况</li><li>最坏情况: 算法需要最长时间的情况</li><li>平均情况: 一般需要花费的时间</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类加载器</title>
    <link href="/2022/11/03/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/2022/11/03/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器分为四种: 启动类加载器 扩展类加载器 应用程序加载器 自定义类加载器</p><h2 id="项目出问题排除方向"><a href="#项目出问题排除方向" class="headerlink" title="项目出问题排除方向"></a>项目出问题排除方向</h2><p>前端:</p><p>后端:</p><p>Mysql排除:</p><ol><li>索引</li><li>慢sql日志</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类加载和反射</title>
    <link href="/2022/11/03/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/11/03/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载和反射"><a href="#类加载和反射" class="headerlink" title="类加载和反射"></a>类加载和反射</h1><p>当一个类被首次使用时, 会经历 <strong>加载 连接 初始化</strong> 三个步骤</p><p>这三个步骤被称为类的初始化或类加载</p><p>类加载由jvm提供的系统类加载器完成, 通过类加载可以将二进制的class文件读取到jvm内存中, 在内存中创建一个java.lang.Class类型的对象</p><blockquote><p>在java中类是对象的抽象, 对象是类的实现</p><p>但是在底层实现中, 每个类在使m用时都是有对应的java.lang.Class对象来使用</p></blockquote><p><strong>在jvm中, 并非所有的类都要等到被使用时才会加载, 实际上系统会根据一定规则来预加载部分类</strong></p><p>类连接</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程安全</title>
    <link href="/2022/11/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2022/11/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全的本质是对资源访问是否具有独占性问题</p><p>多个线程同时对资源进行写入和读取操作时会发生线程不安全</p><p>如何保证线程安全:</p><p>确保资源的独占性: 同一时刻只能有一个线程在访问临界资源</p><blockquote><p>也被称为序列化访问临界资源方案或者称为同步互斥访问</p></blockquote><p>java中有两种线程锁机制来实现同步互斥访问的方法: synchronizedLock</p><h2 id="Synchronized-互斥锁"><a href="#Synchronized-互斥锁" class="headerlink" title="Synchronized(互斥锁)"></a>Synchronized(互斥锁)</h2><p>synchronized被称为互斥锁, 是Java中的一个关键字</p><p>synchronized可以用于标记方法或代码块</p><p>synchronized特性:</p><ol><li>互斥: 对象锁只能被一个线程获得, 不能被其他线程抢占</li><li>重入: 一个线程获得对象锁后, 该线程的不同方法可以抢占这个对象锁</li></ol><p>java中每个对象都有monitor属性, 也被称为锁标记或监视器</p><p>当多线程执行体试图访问某个对象时, 需要先获取该对象的monitor才能访问</p><p>当synchronized标记的代码块或者方法执行时需要先获取指定对象的monitor, 其他需要获取monitor的线程会被锁定直到monitor被释放才能继续执行</p><blockquote><p>只有整个代码块或方法结束才会释放锁定的monitor</p></blockquote><p>通常使用synchronized代码块, 更加灵活</p><blockquote><p>同步锁的代码量越少, 多线程效率越高</p></blockquote><p><strong>面试题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取当前对象的锁</span><br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;&#125;<br><span class="hljs-comment">//获取当前对象的锁</span><br><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//获取Object类的class类对象的锁</span><br><span class="hljs-keyword">synchronized</span>(Object class)&#123;&#125;<br><span class="hljs-comment">//获取当前类的class类对象的锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//获取user对象的锁</span><br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;user&#125;<br></code></pre></td></tr></table></figure><p><strong>锁升级是面试时需要掌握的知识</strong></p><p>synchronized会根据线程数量决定加锁的方式(等级)</p><p>有4种锁等级:无锁(无线程)偏向锁(1线程)轻量级锁(双线程)重量级锁(三个线程以上)</p><blockquote><p>下面的线程必须被synchronized修饰</p></blockquote><p>无锁:对象刚创建没有被线程使用时处于无锁状态(偏向位0, 标志01)</p><p>偏向锁:对象被一个线程操作时, 处于偏向锁状态(偏向位1, 标志01)</p><p>轻量锁:两个线程需要操作同一对象时, 升级于轻量锁状态, 偏向位空,标志00并且使用CAS算法进行两个线程间的锁交换</p><p>重量锁:三个以上的线程都需要操作同一对象时升级为重量锁状态, 偏向位为空, 标志10, 并且不再使用CAS算法而是使用底层CPU的进程同步算法进行锁交换 </p><blockquote><p>同步锁只能升级, 一旦升级不会再降级</p></blockquote><p><img src="/2022/11/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20220608141653164.png" alt="image-20220608141653164"></p><h2 id="线程执行顺序控制"><a href="#线程执行顺序控制" class="headerlink" title="线程执行顺序控制"></a>线程执行顺序控制</h2><p>Object类提供了实例方法用于控制使用该对象的monitor锁的进程: waitnotifynotifyAll</p><p><strong>复习:Object类提供的常用方法有:</strong></p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>static方法</td><td></td></tr><tr><td>clone</td><td>复制指定的对象, 返回副本</td></tr><tr><td>equals</td><td>比较两个对象是否相等</td></tr><tr><td>非static方法</td><td></td></tr><tr><td>finalize</td><td>被GC调用, 回收该对象</td></tr><tr><td>getClass</td><td>获取该对象的运行时类类型(指向的实际类)</td></tr><tr><td>hashCode</td><td>获取对象的hash值</td></tr><tr><td>toString</td><td>将该对象打印为字符串</td></tr><tr><td>线程控制</td><td></td></tr><tr><td>notify</td><td>随机唤醒该对象上一个处于等待状态的线程</td></tr><tr><td>notifyAll</td><td>唤醒该对象上所有的处于等待状态的线程</td></tr><tr><td>wait</td><td>使当前线程进入等待(阻塞)状态, 并释放其占用的monitor, 需要被手动唤醒</td></tr><tr><td>wait(long timeout)</td><td>与wait类似, 但是超过timeout时间后会自动唤醒</td></tr></tbody></table><p><strong>Thread.sleep和Object.wait()的区别</strong>:</p><ol><li>sleep会暂停当前线程的执行, sleep期间该不能被手动唤醒, 并且不会释放monitor资源</li><li>wait()也会暂停当前线程的执行, 可以被notify手动唤醒, 并且会将占用的monitor资源释放</li></ol><p>相似之处:</p><ol><li>都会线程进入Not Runnable状态</li><li>都是底层由C语言写的native方法</li></ol><blockquote><p>sleep状态的线程如果被中断会引发InterruptedException异常</p></blockquote><p><strong>java中还有一个线程安全关键字volatile</strong></p><p>volatile用于修饰变量, 作用有:</p><ol><li>保证内存可见性</li><li>防止指令重排序</li></ol><p>当一个变量被volatile修饰时, 线程对变量的操作将写入缓存, 并同步到主存中, 然后基于CPU缓存一致性(MESI)协议来更新其他线程的变量值</p><blockquote><p>volatile不能严格保证线程安全, 只能减少一部分的同步问题</p></blockquote><p><img src="/2022/11/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20220608113859771.png" alt="image-20220608113859771"></p><h2 id="Lock框架"><a href="#Lock框架" class="headerlink" title="Lock框架"></a>Lock框架</h2><p>Java.util.concurrent.lock是java中的独占锁框架, 有多个实现类</p><p>ReentrantLocak可重入锁, 采用递归无阻塞同步机制 底层是CAS原理实现, 与synchronized的行为类似, 但是比syn更灵活更强大, 增加了轮询 超时 中断等高级功能, 支持取锁的公平选择和非公平选择</p><p>ReadWriteLock读写锁</p><p><strong>ThreadLocal直接负责管理资源, 线程通过调用ThreadLocal的api来读写资源</strong></p><p>synchronized和Lock的区别</p><ol><li>synchronized是关键字, Lock是接口</li><li>synchronized通过对象身上的monitor机制来实现同步锁</li><li>Lock属于一种自定义的锁, 与monitor无关</li><li>synchronized无法手动判断锁的状态, Lock可以通过tryLock判断锁状态</li><li>synchronized有自动释放锁的机制, 而Lock只能手动调用unlock()来释放锁, 否则将称为死锁</li><li>synchronized的线程需要等待锁的释放, Lock不一定</li><li>synchronized可重入 不可中断 非公平锁</li><li>Lock可重入 可中断 有公平锁和非公平锁</li><li>synchronized由于只能自动释放锁导致灵活性较低, 适合用于少量代码, Lock适合用于复杂大量代码的情况</li></ol><p>总结</p><ol><li>synchronized支持同步块和同步方法</li><li>不同monitor对象的区别需要重点掌握</li><li>Lock框架采用CAS原理, 提供公平选择和非公平选择取锁</li><li>ThreadLocal负责管理资源副本, 不直接控制线程, 会为每个线程都产生一个独立的关联资源对象</li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池用于进行多个线程的管理和复用</p><blockquote><p>线程池图解</p></blockquote><p><img src="/2022/11/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20220608175231759.png" alt="image-20220608175231759"></p><p>线程池的组成:</p><ol><li>任务队列: 使进程按照FIFO(先进先出)的队列模式进行排队</li><li>工作线程: 执行任务(多线程对象)的线程</li><li>任务对接接口: 线程池接收任务的接口</li><li>线程管理器: 管理线程池中每个线程的生命周期</li></ol><blockquote><p>FIFO是队列结构的特性</p></blockquote><p>线程池分为简单线程池和复杂线程池</p><p>ExecutorsThreadPoolExecutors</p><blockquote><p>创建简单线程池</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建单线程线程池</span><br>Executors.newSingleThreadExecutor();<br><span class="hljs-comment">//创建具有缓存线程能力的线程池</span><br>Executors.newCachedThreadPool();<br><span class="hljs-comment">//创建线程数量固定的线程池</span><br>Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//创建指定线程数量的定时任务线程池</span><br>Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><blockquote><p>复杂线程池ThreadPoolExecutor的构造器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><blockquote><p>参数解释:</p></blockquote><p>int corePoolSize: 指定线程池的初始化线程数量</p><p>int maximumPoolSize: 线程池的最大线程容量</p><p>long keepAliveTime: 线程允许的最大空闲时间, 超出该时间将该空闲线程结束掉</p><p>TimeUnit unit: keepAliveTime的时间单位</p><p>ThreadFactory threadFactory:Executors下面的线程工厂</p><p>RejectedExecutionHandler hanlder 任务(Execution)拒绝策略</p><p>复杂线程池可以针对线上生产环境进行调优</p><ol><li>Tomcat服务器调优</li><li>RebbitMQ服务器, 提高消费者消费能力</li></ol><p>任务拒绝策略(RejectedExecutionHandler)有4种</p><table><thead><tr><th>策略</th><th>特性</th></tr></thead><tbody><tr><td>AbortPolicy</td><td>拒绝新任务, 并抛出异常</td></tr><tr><td>DiscardPolicy</td><td>拒绝新任务, 不抛异常</td></tr><tr><td>CallerRunsPolicy</td><td>拒绝新任务, 交给提交者处理</td></tr><tr><td>DiscardOldestPolicy</td><td>将任务队列中等待最久的任务抛弃, 将新任务加入任务队列</td></tr></tbody></table><blockquote><p>这些策略都是ThreadPoolExecutor包下的类</p></blockquote><p>线程池在不同任务量下的状态:</p><ol><li>线程池初始化指定数量的线程</li><li>线程池中有空闲线程时, 直接分配任务给线程处理</li><li>线程都在处理任务的状态下, 将后续的任务进入任务队列</li><li>当线程都在工作状态, 并且任务队列也满了时, 扩增线程池的线程数量</li><li>当线程池的线程数量已经达到最大值, 当线程都在工作状态, 并且任务队列也满了时,开启任务拒绝策略</li></ol><p>线程池有execute和submit实例方法用于执行线程对象</p><blockquote><p>execute对应Runnable实现类的对象submit对应Callable实现类的对象</p><p>使用线程池时可以直接运行Runnable或Callable的实现类, 不需要再实现Thread类调用start方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明一个复杂线程池</span><br>ThreadPoolExecutor pools=<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>,<span class="hljs-number">200</span>,<br>                        <span class="hljs-number">5</span>,TimeUnit.MINUTES,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(),<br>                        Executors.defaultThreadFactory(),<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy()<br>                        );<br><span class="hljs-comment">//声明一个简单线程池</span><br>ExecutorService es=Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p><strong>生产者消费者模式</strong></p><p>producer consumer</p><p>生产者消费者模式基于队列模型实现, 可以用于实现多线程的线程间通信</p><p>好处:</p><ol><li>生产者和消费者间为松散耦合关系</li><li>可以实现多线程数据的统一处理</li></ol><p>队列 Queue </p><p>java中的队列提供了add和poll用于向队列加入元素和取出元素</p><blockquote><p>用队列实现生产者消费者模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        Queue&lt;String&gt; queque=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">200</span>);<br>        ExecutorService es=Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        es.execute(()-&gt;&#123;<br>            queue.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        &#125;);<br>        es.execute(()-&gt;&#123;<br>            queue.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125;);<br>        es.execute(()-&gt;&#123;<br>            queue.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125;);<br>        es.execute(()-&gt;&#123;<br>            queue.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定时线程池"><a href="#定时线程池" class="headerlink" title="定时线程池"></a>定时线程池</h2><p>ScheduledThreadPoolExecutor可以实现线程的定时执行</p><p>其属于ScheduledExecutorService的子类</p><p>该线程池类有实例方法schedule和scheduleAtFixedRate用于执行线程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledExecutorService ses=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//5秒后执行一次ps1线程对象(定时执行一次)</span><br>ses.schedule(ps1,<span class="hljs-number">5</span>,TimeUnit.SECONDS);<br><span class="hljs-comment">//7秒后开始每隔1s执行一次ps1线程对象(定时周期性执行)</span><br>ses.scheduleAtFixedRate(ps2,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是指多线程运作时发生了锁无法被自动解开, 无限期锁死的情况</p><p><img src="/2022/11/03/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20220609141752996.png" alt="image-20220609141752996"></p><p>死锁发生的条件:</p><ol><li>一定是互斥锁被使用</li><li>锁的占用是无限期, 没有时效</li><li>锁无法被其他线程抢占, 只能被一个线程主动释放</li><li>多个线程保持死锁状态</li></ol><p>死锁发生的根本原因是业务逻辑有问题</p><p>如何解决死锁:</p><ol><li>选用时效锁,如redis</li><li>统一加锁顺序</li></ol><h1 id="Daemon-thread-守护线程"><a href="#Daemon-thread-守护线程" class="headerlink" title="Daemon thread(守护线程)"></a>Daemon thread(守护线程)</h1><p>java中的daemon thread(守护线程)是运行在后台, 负责管理或者辅助其他线程运行的线程</p><p>java中的GC(垃圾回收器)也是一个守护线程</p><p>特点:</p><ol><li>守护线程是极低优先级线程, 当所有用户线程都运行结束时, JVM会自动关闭而不会考虑守护线程的运行状态</li><li>JVM会强制关闭守护进程, 不会考虑其运行状态</li></ol><blockquote><p>当JVM中最后一个非守护进程运行结束时, 所有守护进程会被强制结束</p></blockquote><p>Thread类中提供了实例方法setDaemon(boolean flag)用于将该线程对象设为守护进程或非守护进程</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>缓冲流</title>
    <link href="/2022/11/03/%E7%BC%93%E5%86%B2%E6%B5%81/"/>
    <url>/2022/11/03/%E7%BC%93%E5%86%B2%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p>java中的大部分IO流都提供了缓冲功能, 不需要特别记忆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//缓冲流的默认缓冲区大小为8192byte, 可以通过size参数指定缓冲区大小</span><br>BufferedInputStream bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(file,<span class="hljs-type">int</span> size);<br>BufferedOutputStream bos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(file,<span class="hljs-type">int</span> size);<br><span class="hljs-comment">//flush方法会将缓冲区的内容主动写入物理设备</span><br><span class="hljs-comment">//不调用flush时, 只有当缓冲区满才会自动将内容输出</span><br>bos.flush();<br><span class="hljs-comment">//close方法会自动调用flush方法, 不需要显示调用flush方法</span><br>bos.close();<br></code></pre></td></tr></table></figure><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库发展历史:</p><p>第一代数据库: 层次, 网状数据库</p><p>第二代数据库: 关系型数据库(SQL语句)</p><p>第三代数据库: 对象数据库, nosql数据库</p><p>表与表之间的关系有三种</p><blockquote><p>A表 B表</p></blockquote><ol><li>一对一: 少见, A的一行只与B的一行相关, B的一行也只与A的一行相关, 双向关系</li><li>一对多 : 常见, A的一行与B的多行相关, 但是B的一行只能与A的一行有关系r</li></ol><blockquote><p>在一对多的关系中, 多边的B表被称为从表, 单边的A表被称为主表</p></blockquote><ol start="3"><li>多对多: A的一行与B的多行相关, 并且B的一行也会与A的多行相关</li></ol><blockquote><p>在SQL数据库的设计中, 多对多的关系通过在两个表中增加连接表(Junction Table)来实现</p></blockquote><h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><p>索引用于快速查找数据库中的数据, 提高查询效率</p><p>innodb和myisam都是用B+树作为索引结构, 但是在实现上有所区别</p><p>myisam的索引树的叶子节点保存数据的内存地址</p><p>innodb的叶子节点直接保存数据本身</p><p>innodb使用聚簇索引, 物理位置顺序和索引顺序一致</p><p><strong>myisam只能先取出数据再排序, 而innodb在取数据时已经是按主键排序</strong></p><p>myisam索引结构实现:</p><p><img src="/2022/11/03/%E7%BC%93%E5%86%B2%E6%B5%81/image-20220530111032633.png" alt="image-20220530111032633"></p><p>Innodb索引结构实现:</p><p><img src="/2022/11/03/%E7%BC%93%E5%86%B2%E6%B5%81/image-20220527180430136.png" alt="image-20220527180430136"></p><blockquote><p>B+树索引支持聚簇, 范围查询, 搜索效率高</p></blockquote><p>聚簇: 索引和数据放在同一个区域中</p><p>非聚簇: 索引和数据放在不同的区域</p><p>聚簇要求数据必须有主键, 然后按照主键进行聚簇</p><blockquote><p>如果表没有显示指定的主键, mysql会自动选择一个满足条件的字段作为主键, 如果不存在满足条件的字段, mysql会生成隐含字段作为聚簇的主键</p><p>隐含字段的类型为长整型, 6个字节大小</p></blockquote><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引用于提高搜索速度, 一个表可以包含多个索引, 每个索引都对应一个字段</p><blockquote><p>当一个表包含索引时, 更新(修改)该表需要花费的时间会增加. 因此尽量只对在搜索中频繁用到的字段建立索引</p></blockquote><p>索引字段应该满足的条件:</p><ol><li>在搜索中频繁用到</li><li>重复数据尽量少</li><li>变化改动尽量少</li></ol><blockquote><p>索引中的字段发生变化时会导致索引需要重新生成, 消耗系统资源</p></blockquote><p>mysql的索引有四种</p><p>主键索引 唯一索引 普通索引 组合索引</p><blockquote><p>注意添加主键约束或唯一约束时会自动生成主键索引或唯一索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#添加唯一约束时自动添加唯一索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span>(id);<br>#用<span class="hljs-keyword">create</span>语句创建普通索引<br><span class="hljs-keyword">create</span> index test_index <span class="hljs-keyword">on</span> test (id);<br>#用<span class="hljs-keyword">alter</span>语句创建普通索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">add</span> index test_index(id);<br>#删除索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">drop</span> index test_index;<br></code></pre></td></tr></table></figure><p>索引使用需要注意</p><p>当select语句中的字段都有索引时, 语句执行速度将大大提高</p><p>只要语句中存在一个没有索引的字段都会使查询速度变慢很多</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">add</span> index test_index(id);<br>#可以命中索引<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id<span class="hljs-operator">%</span><span class="hljs-number">2</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>#无法命中索引<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id<span class="hljs-operator">%</span><span class="hljs-number">2</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span>&quot;李%&quot;;<br></code></pre></td></tr></table></figure><p><strong>组合索引是指一个索引对应多个字段</strong></p><blockquote><p>注意select语句在使用组合索引必须满足最左前缀原则</p></blockquote><p>最左前缀匹配原则: </p><ol><li><p>当查询条件中出现的字段是索引中最左边的一列或连续的多列时才能命中索引</p></li><li><p>并且模糊搜索时必须是匹配前缀 例如 ‘李%’</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">#组合索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">add</span> index test_index(id,name);<br>#可以命中索引<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id<span class="hljs-operator">%</span><span class="hljs-number">2</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span>&quot;李%&quot;;<br>#无法命中索引, 必须在<span class="hljs-keyword">where</span>条件语句中包含最左字段<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>&quot;李%&quot;;<br></code></pre></td></tr></table></figure><p><strong>最左前缀匹配原则实质上是由B+树的索引结构所导致</strong></p><p>不适合添加索引的字段:</p><ol><li>很少查询的字段</li><li>频繁修改的字段</li><li>字段中有大量重复数据</li></ol><p>面试题: 索引可能失效的情况</p><ol><li>select *</li><li>模糊搜索没有用前缀 如like ‘%李’ :最左前缀匹配原则</li><li>组合索引没有遵循最左前缀匹配原则</li><li>数据库可以直接返回结果, 不需要用到索引</li><li>sql中用到算数运算符如: limit (page-1)*rows,rows</li><li>sql使用or   !&#x3D;   &lt;&gt; 运算符</li></ol><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>jdbc是java数据库编程的基础, 提供了一套API用于在数据库中执行sql语句</p><p>JDBC生命周期:</p><ol><li>通过对应的驱动创建于数据库的连接</li><li>创建sql编译对象, 编译sql语句</li><li>在数据库中执行sql语句</li><li>将sql语句的执行结果返回</li><li>关闭连接</li></ol><p><img src="/2022/11/03/%E7%BC%93%E5%86%B2%E6%B5%81/image-20220526154354456.png" alt="image-20220526154354456"></p><blockquote><p>jdbc语句</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>            String url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/szdx2?useUnicode=true&amp;characterEncoding=utf8&quot;</span>;<br>            Connection conn= DriverManager.getConnection(url,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;liujinru&quot;</span>);<br>            System.out.println(conn);<br>            Statement stmt=conn.createStatement();<br>            <span class="hljs-comment">//执行查询语句</span><br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span>stmt.executeQuery(<span class="hljs-string">&quot;select * from class_info&quot;</span>);<br>            <span class="hljs-comment">//执行更新语句(数据库修改语句)</span><br>            stmt.executeUpdate();<br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                System.out.println(rs.getString(<span class="hljs-string">&quot;class_name&quot;</span>));<br>            &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>PreparedStatement 预编译</p><p>Statement 直接编译</p><p>预编译的优点是先预编译后设值, 使得语法可以复用,</p><p>并且可以防止SQL注入攻击</p><blockquote><p>直接编译是用字符串拼接的方式组成sql语句, 容易出现sql注入攻击, 并且语法不能复用</p></blockquote><h2 id="Mysql和java数据类型对应关系"><a href="#Mysql和java数据类型对应关系" class="headerlink" title="Mysql和java数据类型对应关系"></a>Mysql和java数据类型对应关系</h2><table><thead><tr><th>mysql</th><th>java</th></tr></thead><tbody><tr><td>char</td><td>String</td></tr><tr><td>varchar</td><td>String</td></tr><tr><td>tinyint</td><td>byte</td></tr><tr><td>smallint</td><td>short</td></tr><tr><td>int</td><td>int</td></tr><tr><td>bitint</td><td>long</td></tr><tr><td>float</td><td>float</td></tr><tr><td>double</td><td>double</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>date, datetime</td><td>java.util.Date, java.sql.Date</td></tr><tr><td>time</td><td>java.util.Time, java.sql.Time</td></tr></tbody></table><h2 id="执行计划-explain"><a href="#执行计划-explain" class="headerlink" title="执行计划(explain)"></a>执行计划(explain)</h2><p>explain语句语法</p><p>explain select …</p><blockquote><p>explain可以跟select delete insert replace update语句一起使用, 提供语句执行过程的信息</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">where</span> stu_name <span class="hljs-keyword">like</span> &quot;李%&quot; ;<br></code></pre></td></tr></table></figure><p>上述explain语句的返回结果是:</p><p><img src="/2022/11/03/%E7%BC%93%E5%86%B2%E6%B5%81/image-20220531094503351.png" alt="image-20220531094503351"></p><table><thead><tr><th>重点字段</th><th>解释</th></tr></thead><tbody><tr><td>key</td><td>用到的索引</td></tr><tr><td>type</td><td>查询类型</td></tr></tbody></table><p>type的种类有: </p><p>allindexrangerefeq_refconstsystemNULL</p><blockquote><p>从左到右, 性能越来越好</p></blockquote><p>all: 全表索引, 性能最差, 需要查询索引表和数据表的全部数据</p><p>index: 查询索引表的所有数据</p><p>range: 范围查询, 查询特定范围的行</p><p>ref: 查询索引表的特定字段</p><p>eq_ref: 查询索引表上面的唯一字段</p><p>const: 索引表只有一行数据</p><p>system: 表只有零或一行记录 </p><p>NULL: mysql可以直接返回结果</p><h1 id="mysql配置"><a href="#mysql配置" class="headerlink" title="mysql配置"></a>mysql配置</h1><p>mysql配置文件的路径为&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p><p>慢查询日志: 记录查询时间长的语句</p><blockquote><p>慢查询日志可以用于分析是否要添加索引来提高查询效率, 减少慢查询</p></blockquote><blockquote><p>mysql默认配置</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">#默认端口为3306<br>port=3306<br>#慢查询日志开启<br>slow_query_log=1<br>#慢查询日志路径<br>slow_query_log_file=/var/log/mysql/mysql-slow.log<br>#默认记录的慢查询是执行时间超过2s的查询语句<br>long_query_time=2<br>#慢查询不会记录任何使用了索引的记录<br>log_queries_not_using_indexes=1<br></code></pre></td></tr></table></figure><blockquote><p>修改mysql的配置文件后需要重启mysql服务使新配置生效</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网关02</title>
    <link href="/2022/11/03/%E7%BD%91%E5%85%B302/"/>
    <url>/2022/11/03/%E7%BD%91%E5%85%B302/</url>
    
    <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>在微服务架构中网关负责(请求过滤): 接收用户请求并转发给具体的服务接口(集群), 并实现了转发 流量控制 负载均衡 降级熔断 日志记录 监控</p><p>常见的网关实现:</p><p>Spring Cloud Gateway</p><p>Kong</p><blockquote><p>注意Nacos不是网关, 是一个动态服务发现和配置系统</p></blockquote><p>分布式系统中ID的解决方案</p><ol><li>数据库主键自增id</li><li>数据库号段模式</li><li></li></ol><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>单机系统中, 我们常用ReetrantLock或synchronize锁来实现线程安全</p><blockquote><p>线程安全的本质是实现边缘资源访问的独占性</p></blockquote><p>分布式锁需要满足的条件:</p><ol><li>互斥</li><li>高可用</li></ol><p>使用Redis可以实现分布式锁</p><p>简易实现:</p><ol><li>使用SETNX命令, 设置锁实现互斥性</li><li>DEL命令释放锁</li><li>使用SET EX 过期时间 NX设置锁过期</li></ol><p>SETNX命令全称: SET if Not eXists</p><p>对应java中的setIfAbsent方法</p><blockquote><p>命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">SETNX lockKey value<br>&gt;返回值1<br><span class="hljs-comment">#获取锁</span><br>SETNX lockKey value<br>&gt;返回值0<br><span class="hljs-comment">#通过返回值1 0判断锁是否存在</span><br>DEL lockKey<br>&gt;返回值1<br><span class="hljs-comment">#释放锁</span><br>SET lockKey value EX 3 NX <br>设置一个3秒后自动过期的锁<br><span class="hljs-comment">#SET NX命令等同于SETNX</span><br></code></pre></td></tr></table></figure><blockquote><p>使用Lua脚本可以保证锁释放的原子性</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">// 释放锁时，先⽐较锁对应的 value 值是否相等，避免锁的误释放<br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>Redisson</strong></p><p>Redisson是基于java实现的redis客户端框架, 提供了基于redis实现的多种功能, 包括多种redis分布式锁的实现</p><p>Redisson中的分布式锁提供了锁自动续期机制, 并使用Watch Dog来监控锁</p><blockquote><p>Watch Dag</p></blockquote><p>RLock是Redisson提供的分布式可重入锁</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网关</title>
    <link href="/2022/11/03/%E7%BD%91%E5%85%B3/"/>
    <url>/2022/11/03/%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>Gateway是Spring提供的API网关服务, 提供了路由 过滤器 断言等功能</p><ol><li>Route 路由</li><li>Predicate 断言</li><li>Filter 过滤器</li></ol><h2 id="常量注入"><a href="#常量注入" class="headerlink" title="常量注入"></a>常量注入</h2><p>@Value(“常量”) 常量,包括字符串,网址,文件路径等</p><p>@Value(“${}”<code> : default_value</code>) 读取配置文件</p><p>@Value(“#{}”<code>? : default_value</code>) 读取注入bean的属性</p><h1 id="Maven分模块开发"><a href="#Maven分模块开发" class="headerlink" title="Maven分模块开发"></a>Maven分模块开发</h1><p>使用Maven模块可以将一个工程拆分成多个模块(子工程)进行单独开发</p><p>拆分逻辑有:</p><ol><li>功能拆分</li><li>业务拆分</li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>事务控制</title>
    <link href="/2022/11/03/%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/11/03/%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h1><p>使用mysql客户端时会默认自动提交事务</p><p>JDBC也会默认自动提交事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//关闭jdbc的自动提交事务</span><br>conn.setAutoCommit(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//手动提交事务</span><br>conn.commit();<br><span class="hljs-comment">//回滚到上一次事务提交后的状态, 也就是说撤销所有未提交的事务</span><br>conn.rollback();<br></code></pre></td></tr></table></figure><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p>范式: NF(Normal Format)</p><p>范式是对表中的数据之间关系的要求</p><p>使用范式来设计表可以得到最优表结构, 避免数据冗余, 减少存储空间占用, 使得数据库完整性的维护更简单</p><p>总共有六大范式: 1NF 2NF 3NF 4NF 5NF 6NF</p><p>每个范式都包含前面所有范式的内容</p><blockquote><p>也就是说当一个数据库满足6NF时, 它也同时会满足1NF 2NF 3NF 4NF 5NF</p></blockquote><p>但是通常数据库只需要满足3NF即可</p><p>1NF 2NF 3NF合称范式三约定</p><p>1NF: 每个字段都必须具备原子性</p><blockquote><p>每个字段不能再分解</p></blockquote><p>2NF: 每个字段都必须与主键有关系(1NF的基础上要求)</p><blockquote><p>2NF要求每一行记录都具有唯一性, 也就是说每行中的每个字段都必须与唯一的主键相关联</p></blockquote><p>3NF: 每个字段都必须与主键直接相关(不能时间接关系)</p><p>2NF示例:</p><p>当一个表中同时包含了商品信息和订单信息时, 这个表不满足2NF</p><p>因为商品信息以商品编号为主键, 而订单信息不依赖于商品编号</p><h1 id="JUnit测试框架"><a href="#JUnit测试框架" class="headerlink" title="JUnit测试框架"></a>JUnit测试框架</h1><p>JUnit是一个测试框架</p><p>提供了四种注释用于控制程序执行顺序</p><p>@Before</p><p>@After</p><p>@Test</p><p>@Ignore</p><p>JUnit注释的测试方法有以下限制条件</p><ol><li>public修饰</li><li>void定义</li><li>没有形参列表</li></ol><p>不满足限制条件时会报编译错误</p><h1 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h1><p>DAO: 数据访问对象(Data Access Object)</p><p>dao是采用面向对象的思想去访问数据库的数据</p><p>orm: 对象关系映射(Object Relational Mapping)</p><p>使用orm可以将数据库的表映射为java对象</p><p>数据库开发中, 会使用java程序来操作对象, 然后使用orm将对象映射为表数据, 再执行sql操作</p><p>数据库系统流程:</p><p><img src="/2022/11/03/%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/image-20220601093830192.png" alt="image-20220601093830192"></p><blockquote><p>数据层也被称为持久层</p></blockquote><blockquote><p>上图也可以被简化为dao三层架构: 视图层 业务层 持久层</p></blockquote><p>数据层的组成有:</p><ol><li><p>VO, 数值对象 (value object), 用于实现orm映射 每个vo实例对应表中的一行记录</p><blockquote><p>vo可以用java_bean代替</p></blockquote></li><li><p>dao: dao是一套接口api, 封装了对vo实例的操作</p></li><li><p>impl: dao接口的实现类, 对vo对象实现curd操作</p></li><li><p>DatabaseConnection: 负责数据库连接的建立和关闭</p></li><li><p>daofactory</p></li><li><p>Proxy</p></li></ol><p>dao模式优势:</p><ol><li>将数据库访问进行抽象. 使得业务逻辑层与数据源相互独立开, 简化业务逻辑层</li><li>由于数据库的所有操作都在dao层执行, 降低系统的耦合性, 提高可维护性</li><li>将数据访问划分为抽象接口层和实现层, 提高代码复用性</li><li>提高系统移植性, 只要数据库结构不发生改变, dao层可以直接复用</li></ol><p>dao设计原则:</p><ol><li>一个方法只负责执行一条sql语句</li><li>不能在dao层之外使用sql语句</li><li>每个表都创建对应的dao实现类</li></ol><p><strong>SQLite是一种小型的数据库, 通常运行在手机或者嵌入式设备中, 数据存放在内存中</strong></p><h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>javabean类编程规范:</p><ol><li>类必须是可序列化的(实现Serializable接口)</li><li>属性用private修饰, 提供public修饰的getter或setter</li><li>尽可能提供有参构造方法</li></ol><h1 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h1><p>完整性约束有四种:</p><ol><li>域完整性</li><li>实体完整性</li><li>参照完整性</li><li></li></ol><p><strong>JDK1.8新特性</strong>:</p><ol><li>接口可以定义默认方法和类方法</li><li>新的日期类 LocalDate    LocalTime    LocalDate    TIme</li><li>lambda表达式</li><li>Stream流(用于操作集合)</li></ol><p>lambda表达式只能用于实现函数接口</p><p>匿名内部类不仅能实现函数接口, 还能实现抽象类或普通接口</p><blockquote><p>注意lambda表达式也被称为匿名方法</p><p>是函数式编程思想在java中的实现</p></blockquote><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>jdbc连接数据库需要创建Connection对象,有两个方法可以用</p><ol><li>DriverManager.getConnection()方法</li><li>DataSource.getConnection()方法</li></ol><blockquote><p>两个类都是在java.sql包下</p></blockquote><p>两个类的区别:</p><p>DataSource使用连接池技术, 不用重复建立同一个数据库的连接</p><p>DriverManager没有连接池, 每次调用都会新建一个数据库连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">#Class.forName()方法会在classpath路径下寻找对应的类文件, 用于动态加载或者连接指定的类<br>Class.forName(驱动程序类);<br></code></pre></td></tr></table></figure><p>调用getConnection方法得到Connection对象后, 可以调用该对象的实例方法创建语句对象</p><blockquote><p>Statement是java.sql包下的一个接口</p></blockquote><p>jdbc可以使用三类语句对象</p><ol><li>Statement一个Statement对象代表一个sql语句</li><li>PreParedStatement 1的子接口, 预编译sql语句, 需要在执行前给参数赋值才能使用</li><li>CallableStatement 2的子接口, 用于调用数据库存储过程</li></ol><blockquote><p>通常编程中使用预编译语句(PreParedStatement), 因为预编译的执行效率最高, 代码可以复用, 更安全</p></blockquote><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>xml: 可扩展标记语言 extensible markup language</p><p>html: 超文本标记语言 hyper text markup language</p><p>xml和html都是w3c定义的标准, 用于处理数据传输 存储或展示</p><p>区别: </p><p>xml用于存储要传输的数据, html用于控制数据的展示</p><p>xml没有预定义的标签, html提供了多种预定义的标签</p><p>xml特点:</p><ol><li>xml是一种标记语言, 与html类似</li><li>设计用于传输数据</li><li>没有预定义的标签, 只能自定义标签</li><li>具有自我描述性(self descript)</li><li>优点: 结构清晰 可读性强</li></ol><blockquote><p>标记语言中许多符号都有特殊的语法意义, 如果需要将符号作为字符串使用时, 需要使用特殊实体</p></blockquote><p>xml特殊实体</p><table><thead><tr><th>Entity</th><th>符号</th></tr></thead><tbody><tr><td>&amp;lt;</td><td>&lt;</td></tr><tr><td>&amp;gt;</td><td>&gt;</td></tr><tr><td>&amp;amp;</td><td>&amp;</td></tr><tr><td>&amp;#160;</td><td>空格</td></tr><tr><td>&amp;quot;</td><td>双引号</td></tr><tr><td>&amp;apos;</td><td>单引号</td></tr></tbody></table><blockquote><p>一般记住大于号 小于号 空格的使用即可</p></blockquote><blockquote><p>xml示例</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> standalone=<span class="hljs-string">&quot;no&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">datasource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">driver</span>&gt;</span>com.mysql.cj.jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">driver</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>jdbc:mysql://127.0.0.1:3306/szdx2<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>liujinru<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">datasource</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>version代表xml版本</p><p>encoding表示使用的编码集</p><p>stadalone表示xml是否独立</p></blockquote><p>xml中的内容有:</p><p>标记文本特殊实体静态字符属性</p><p><strong>xml校验</strong></p><p>可以用DTD Schema来检验xml的格式是否符合要求</p><p>dtd: 文档内容定义 document type definition</p><p>特点:</p><ol><li>一个xml只能对应一个dtd文件</li><li>xml的标签要严格遵循dtd定义</li></ol><p><strong>DOM4J</strong></p><p>DOM4J可以将xml文件解析为dom节点树</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>位运算符</title>
    <link href="/2022/11/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2022/11/03/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>java支持6种位运算符: &amp; | ~ ^ &lt;&lt; &gt;&gt;  &gt;&gt;&gt;</p><p>&amp; 按位与(并且) </p><p>| 按位或(或者) </p><p>~ 按位非(直接取反)</p><p>^ 异或(如果不同则为真):相同返回0, 不同返回1</p><p>**移位运算符 **:</p><p>&lt;&lt; 左移 将数值向左移, 后面的位数用0补完</p><p>&gt;&gt; 右移 将数值向右移动, 后面的位数用0补完</p><p>&gt;&gt;&gt; 无符号右移, 跟右移操作符类似, 但是仅对符号位外的位进行操作</p><p>注意: &amp; | ^这三个运算符的操作数可以是数值也可以是布尔值(表达式)</p><p>而~ 按位非和移位运算符的操作数只能是数值</p><p>移位运算符操作正数是对它的原码进行操作</p><p>操作负数是对它的补码进行操作</p><p>对于位运算符需要熟悉, 因为面试题和看底层源码的时候需要用到对应的知识, 但是日常开发中很少用到</p><p>(需要多背理论知识)</p><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>布尔表达式的运算结果是布尔值</p><p>&amp; 与(不短路且) 并且 </p><p>| (不短路或) 或者 </p><blockquote><p>不短路说明对两个操作数都会进行计算</p></blockquote><p>!非 直接取反</p><p>&amp;&amp; 短路与 (逻辑与) </p><p>|| 短路或(逻辑或)</p><blockquote><p>&amp;&amp; 和|| 只能用于布尔表达式的运算</p><p>两个操作数都必须是布尔值</p><p>短路运算符会先对第一个操作数进行判断</p><p>如果已经可以得出结果则会直接忽略第二个操作数(代表程序执行会直接跳过第二个操作数)</p></blockquote><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>Java中代码的默认执行顺序都是从上到下, 从左到右</p><p>在Java可以通过循环结构 条件语句 调用方法来实现控制代码的执行顺序</p><p>条件语句包括 :if语句和switch语句</p><blockquote><p>if else, else if</p><p>switch case break</p></blockquote><p>三元运算符也是条件语句(用if语句来实现三元运算符的功能)</p><blockquote><p>三元运算符只能组成双分支语句</p></blockquote><p>条件语句有单分支和多分支的, 都可以用if语句组成</p><h4 id="在Java中一个表达式不能作为完整的语句来执行-必须要有对应的变量来接收返回值才算完整的语句"><a href="#在Java中一个表达式不能作为完整的语句来执行-必须要有对应的变量来接收返回值才算完整的语句" class="headerlink" title="在Java中一个表达式不能作为完整的语句来执行, 必须要有对应的变量来接收返回值才算完整的语句"></a>在Java中一个表达式不能作为完整的语句来执行, 必须要有对应的变量来接收返回值才算完整的语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>()&#123;&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span>()&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>尽量避免在if语句中嵌套多层if语句, 多层嵌套的if语句会降低代码可读性</p></blockquote><p>使用if else if语句来实现多分支语句</p><p>单分支 if</p><p>双分支 if else</p><p>多分支 if else if</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二维数组</title>
    <link href="/2022/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2022/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>Java中没有从底层实现真正的多维数组, </p><p>例如:在Java里面的二维数组本质还是一维数组, 其数组元素储存引用变量, 引用变量指向另外的一维数组</p><p>如何定义多维数组: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">type[][] arrName;<br></code></pre></td></tr></table></figure><p>初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">arrName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">type</span>[length][]<br></code></pre></td></tr></table></figure><p>上述语句实际上相当于初始化了一个一维数组, 该一维数组的长度为length, 其数组元素为引用类型, 被系统自动初始化赋值为null</p><p><img src="/2022/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/image-20220427102048009.png" alt="image-20220427102048009"></p><blockquote><p>注意上图中定义了一个元素为对象的数组, 其数值在内存的存储方式如图所示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>][];<br></code></pre></td></tr></table></figure><p><img src="/2022/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/image-20220427102324663.png" alt="image-20220427102324663"></p><blockquote><p>上图中该二维数组进行了(一维)初始化, 其堆内存存储方式跟一维数组非常类似</p></blockquote><p><img src="/2022/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/image-20220427102454276.png" alt="image-20220427102454276"></p><blockquote><p>上图显示了二维数组对其数组元素进行了(二维)初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p><img src="/2022/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/image-20220427103350502.png" alt="image-20220427103350502"></p><blockquote><p>Java里面的三维数组也是一维数组, 其数组元素是二维数组, 二维数组里面的数组元素是一维数组, 所以Java多维数组的本质都是一维数组</p></blockquote><p>二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] nums=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] list:nums)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> item:list)&#123;<br>        System.out.println(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码用增强for循环遍历了一个二维数组</p><p>一维数组: ArrayList集合的底层</p><h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p>Java中通过new 关键字来调用对应类的构造器, 构造器会返回该类的一个实例</p><p>构造器是类创建对象的默认途径</p><p>没有构造器的类通常无法创建实例</p><p>如果没有自定义的构造器, 系统会自动为类生成一个构造器</p><p>构造器是一个特殊的方法(构造方法)</p><p>构造器不能声明返回值的类型, 也不能用void关键字来修饰</p><p>因为一旦用类型关键字来声明后, Java不会将其当作构造方法来执行, 而是作为普通方法来执行</p><p>构造方法的语法结构包括: 修饰符 构造方法名 形参列表</p><blockquote><p>系统默认提供的构造方法是不带形参的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-string">&quot;nih&quot;</span>,<span class="hljs-number">18</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student1</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中的无参构造器通过this关键字来调用了另一个有参构造器</p><blockquote><p>当一个类被创建时候, 未显式赋值的类成员一定会进行自动初始化</p></blockquote><blockquote><p>使用new关键字创建对象时, 一定会对未显式赋值的实例变量进行自动初始化</p></blockquote><blockquote><p>构造器又称为构造方法</p></blockquote><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>extends关键字来实现继承</p><p>通过继承, 子类可以继承父类中的成员变量(类中方法外的变量)和方法</p><p>访问控制允许的情况下, 子类实例(对象)可以直接调用父类中方法</p><blockquote><p>继承是实现类复用的重要手段, 类的复用也可以通过组合关系来实现 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br></code></pre></td></tr></table></figure><p>上述代码将子类的对象赋值给了父类变量, 使得该变量具有了多态性</p><blockquote><p>如果是用组合关系来实现复用, 无法这样子来实现多态</p><p>灵活性差</p></blockquote><p><strong>程序设计应该遵循高内聚， 低耦合原则</strong></p><p>高内聚： 每个类的功能性应该全面、完善， 尽量不需要依赖于其他类</p><p>低耦合： 类和类之间的关系尽量简单化， 减少关联性</p><blockquote><p>面向对象三大特征: 继承 封装 多态</p></blockquote><p>继承是实现代码复用的重要手段</p><p>Java中的继承为单继承, 一个子类只能有一个父类</p><blockquote><p>Java舍弃了C++中复杂的多继承特性</p></blockquote><blockquote><p>但是也可以通过父类继承间接父类, 来使得子类间接继承多个(间接)父类</p></blockquote><p><strong>在Java中如果一个类没有显示指定一个类作为直接父类, 则会默认指定java.lang.Object类为其直接父类</strong></p><p><strong>java.lang.Object是Java中所有类的直接&#x2F;间接父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClass</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>上述代码中通过extends关键字, SubClass类继承了父类SuperClass</p><blockquote><p>extends原意为扩展, 所以也可以说子类是对父类的扩展</p></blockquote><blockquote><p>注意Java中子类无法继承父类的构造器</p></blockquote><p>derive(派生) 父类派生了子类</p><p>extends(继承) 子类继承了父类</p><p>derive extends都是描述同一动作, 但是角度&#x2F;方向不同</p><p>子类大部分情况下都是在父类的基础上增加新的成员变量和方法</p><p>但是存在例外情况: 方法重写(覆盖) (Override)</p><p>方法重写(override)与方法重载(overload)是完全不同的概念</p><p>方法重写:</p><p>子类中存在于父类同名的方法称为方法重写</p><p>方法重写规则: 两同两小一大</p><p>两同: 方法名 形参列表必须相同 (是否被static修饰符修饰也需要保持一致)</p><p>两小: 子类中的方法返回值<strong>类型</strong>必须小于或等于父类方法的返回值类型</p><p>子类方法抛出的异常类也应该比父类方法更小或相等</p><p>一大: 子类方法的访问权限应该比父类方法的更大或相等</p><blockquote><p>注意父类中用private修饰的方法对于子类来说是不存在的(隐藏) 这时候在子类中定义同名的方法不是方法重写</p></blockquote><p>super关键字用于在子类中调用被覆盖的父类方法</p><blockquote><p>super关键字不能出现在static修饰的方法中</p><p>但是可以调用被static修饰的方法</p></blockquote><p>super关键字也可以用于在子类中调用被隐藏的父类变量</p><blockquote><p>当子类中定义了与父类重名的变量时会导致父类变量被隐藏, 子类可以通过super关键字调用被隐藏的父类变量</p></blockquote><p>程序查找变量的顺序(优先级)为:</p><ol><li>找该方法中的局部变量</li><li>找该类中的成员变量</li><li>找父类中的成员变量</li><li>按结构遍历所有间接父类的成员变量直至最终的java.lang.Object</li><li>最终仍无法找到变量将出现编译错误</li></ol><p>找到同名变量后不会再执行后续步骤</p><p><img src="/2022/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/image-20220505172804617.png" alt="image-20220505172804617"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Son s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><span class="hljs-comment">//int num=s.tag;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>((Parent)s).tag<br></code></pre></td></tr></table></figure><p>上述代码显示了在创建子类对象后, 用(Parent)来调用父类中被隐藏的变量</p><p><strong>子类可以用super关键字来调用父类的构造器</strong></p><blockquote><p>使用this或super关键字调用构造器必须出现在构造器执行体第一行, 因此不能同时出现</p></blockquote><p><strong>子类构造器一定会调用父类构造器一次</strong></p><p>三种情况:</p><ol><li>用super关键字调用父类构造器</li><li>用this关键字调用本类中另一个构造器, 另一个构造器调用父类构造器</li><li>以上两种情况都没有发生时, 系统默认调用父类无参数构造器</li></ol><p><strong>创建一个对象时, 一定是从对应类所在的继承树最顶层类的构造器开始依次向下执行, 因此最开始一定会执行java.lang.Object类的构造体, 最后才会执行本类的构造体</strong></p><p>方法重写原则：</p><ol><li><strong>子类的修饰符必须大于或等于父类中的修饰符</strong></li><li>子类中的返回值范围必须小于或者等于父类的返回类型范围， 并且两者需要为继承关系</li></ol><p><strong>父类也被称为超类</strong></p><p><strong>在子类中打算重写父类方法时，应该写@Override注释， 但是不写也不会出问题</strong></p><h1 id="注解（Annotation"><a href="#注解（Annotation" class="headerlink" title="注解（Annotation)"></a>注解（Annotation)</h1><p>JDK5增加了Annotation功能</p><p>Java用@来声明注解语句</p><p>注解（Annotation)与注释(Commit)相似， 都不会改变程序的逻辑</p><p>但是Commit是写给人看的</p><p>Annotation是写给开发工具、代码分析器、 部署工具看的， 用于补充代码信息进行验证或者部署</p><blockquote><p>Annotation的本质是一种接口， 用于给代码元素设置元数据（MetaData)</p></blockquote><blockquote><p>例如Java类库中不推荐使用的方式是使用@Deprecated进行注解， IDE会读取该注解，并在代码使用该方法时进行提示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">User u=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>System.out.println(<span class="hljs-string">&quot;&quot;</span>+u);<br></code></pre></td></tr></table></figure><p>将字符串与一个对象拼接时, 将调用对象的toString方法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内存空间</title>
    <link href="/2022/11/03/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/11/03/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>内存空间</p><p>JVM的内存可以划分为: 线程栈stack, 堆heap, 程序计数器, 本地方法栈, 元空间</p><p>栈: 先进后出 LIFO(last in first out)</p><p>队列: 先进先出 FIFO(First in first out)</p><p><img src="/2022/11/03/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/image-20220429103419795.png" alt="image-20220429103419795"></p><p>线性数据结构 高速访问</p><p>内存空间高效利用, 但是导致变量的大小固定不可变</p><p>低成本</p><p>栈内存里面的变量一般不需要GC进行内存回收, 因为它的内存空间会随着方法或代码块的运行结束而销毁</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>初始化块</title>
    <link href="/2022/11/03/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/"/>
    <url>/2022/11/03/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h1><p>类的四种组成成员: 成员变量 方法 构造器 初始化块</p><p>(都可以有多个, 也可以没有)</p><p>一个类中的多个初始化块会按照先后顺序执行</p><p>初始化块里面可以包含任何执行语句</p><p>初始化块如果被static修饰, 则称为静态初始化块</p><p>初始化块不能有标识符来标记,因此初始化块无法被调用, 对于类外界来说是隐形的</p><p>初始化块在创建对象时会隐式执行, 并且在构造器之前执行</p><p><strong>static初始化块在类第一次加载时运行</strong></p><p><strong>非static初始化块在对象每次创建时都会运行</strong></p><p><strong>构造器在初始化块执行后执行</strong></p><p><strong>类的加载是在对象创建之前</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">//static初始化块 也被称为类代码块 编译时代码块</span><br>    <span class="hljs-keyword">static</span>&#123;&#125;<br>    <span class="hljs-comment">//非static初始化块 也被称为 实例代码块 运行时代码块</span><br>    &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的Person类包含两个初始化块</p><p>一个静态初始化块和一个非静态初始化块</p><p>**在Java中创建一个对象时, 系统会首先为该对象的所有实例变量(非成员变量)分配内存</p><p>接着开始执行初始化</p><p>Java中对象初始化步骤执行顺序是:</p><ol><li>声明实例变量时指定的初始化值进行赋值或者执行初始化块 由于它们是相同的优先级, 所以执行顺序要看在代码中的先后顺序</li><li>最后再执行构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span>&#123;<br>    <span class="hljs-comment">//第一步执行</span><br>    <span class="hljs-type">int</span> age=<span class="hljs-number">18</span>;<br>    &#123;<br>        <span class="hljs-comment">//第二步执行 同优先级看先后顺序</span><br>        age=<span class="hljs-number">19</span>;<br>    &#125;<br>    Girl()&#123;<br>        <span class="hljs-comment">//第三步执行</span><br>        age=<span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>初始化块与构造器的不同之处:</strong></p><ol><li>执行顺序的不同</li><li>初始化块可以有多个,每次创建对象都必须执行所有的构造器</li><li>构造器可以有多个, 但是创建对象时候只会执行被调用的构造器</li></ol><p>可以将多个构造器中的相同代码提取到初始化块中,</p><p>可以有效提高代码复用性, 程序的维护性</p><blockquote><p>普通初始化块会按照继承关系, 从Java.lang.Object类开始从上到下执行,</p><p>从上到下执行时, 会执行java.lang.Object的普通初始化块和构造器, 再到下一个间接父类的初始化块和构造器</p></blockquote><blockquote><p>初始化块在经过编译后会加到每个构造器的执行块代码前面, 所以本质上初始化块是构造器的补充</p></blockquote><h1 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h1><p>static修饰的初始化块称为静态初始化块</p><p>静态初始化块在类初始化时就会执行, 通常用于对类变量进行初始化, 不能对实例变量进行初始化处理</p><p>static初始化块属于类的静态成员, 类的静态成员不能访问非静态成员</p><blockquote><p>注意构造器是不能被静态修饰符修饰的, 因此静态初始化块可以在类初始化时执行, 但是构造器不能</p></blockquote><p>只有类初始化完成后, 程序才能开始使用这个类</p><blockquote><p>疑问: 当父类中自定义了构造器, 不提供无参构造器时, 子类会如何调用父类的构造器</p><p>会报错, 必须提供无参构造器才能被子类继承</p></blockquote><p><strong>类的初始化</strong></p><p>仅当对象第一次被创建时候, 会执行类的初始化(执行静态初始化块)</p><p>当类初始化过一次后, 该类会一直保留在jvm中直到程序结束, 所以后面再次创建对象时无须再对该类进行初始化</p><blockquote><p>继承和组合都是属于Java提供的类复用机制</p></blockquote><h1 id="API学习"><a href="#API学习" class="headerlink" title="API学习"></a>API学习</h1><p>API : Application Programming Interface 应用软件编程接口</p><p>JAVA中的API是指系统类库里提供的公共类和接口</p><p>使用API可以提高编程效率</p><blockquote><p>Java常用的包:</p><p>java.langJava的核心包, 默认被所有的程序导入</p><p>包括 String(字符串) Math(数学运算) System(系统) Thread</p><p>java.utiljava的工具包</p><p>Arrays(数组) List(列表) Set(有序集合)</p><p>java.iojava的io开发包</p><p>java.sql数据库编程</p><p>java.net网络编程</p><p>javax.* 由第三方提供的Java扩展包</p></blockquote><h2 id="Object类常用API"><a href="#Object类常用API" class="headerlink" title="Object类常用API"></a>Object类常用API</h2><p>Object类在Java中是所有类的超类, 所有类都间接或直接继承Object类</p><p>常用方法:</p><ol><li><p>clone(), 复制该对象, 返回副本</p></li><li><p>equals(Object obj) 对比两个对象, 一般需要重写, 默认调用&#x3D;&#x3D;运算符对比两个对象的地址是否相同</p></li><li><p>finalize() 销毁该对象, 回收其内存空间</p><blockquote><p>当一个对象在程序中不存在引用变量时, GC会调用该方法</p></blockquote><blockquote><p>注意clone()和finalize()方法不能简单被对象调用</p></blockquote></li></ol><h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p>Java中的字符串一般是String类的对象</p><p>字符串创建后内容不可修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br></code></pre></td></tr></table></figure><p>因为在String类底层中, 用char数组实现存储字符串, 并且该数组被final修饰</p><p>导致字符串一旦创建则不可改变</p><p><strong>static成员的创建一定是在类加载期间</strong></p><p>类的创建是在编译时, 对象创建是在运行时</p><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object类是所有类的父类, 所以Object类中提供的方法会被所有类继承</p><p>Object类中提供了toString() 实例方法, 其返回值为”类名+@+hashCode”</p><p>在自定义类中可以重写toString()方法来实现自定义功能</p><blockquote><p>数组类重写了toString()方法, 可以将数组元素作为字符串输出</p></blockquote><p><strong>当&#x3D;&#x3D;运算符的操作数包含引用变量时, 必须是两个有父子关系的对象才能进行比较, 或者是相同类的对象</strong></p><blockquote><p>这里的父子关系不可以是间接父子关系, 必须是直接父子关系</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;her&quot;</span>;<br><span class="hljs-comment">//直接量 直接使用常量池管理, 将常量池中的对象给s1引用变量</span><br>String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;he&quot;</span>);<br><span class="hljs-comment">//先使用常量池管理对象, 再调用String类构造器创建新的String对象给s2引用变量</span><br><span class="hljs-comment">//new String(&quot;he&quot;)会产生两个对象</span><br></code></pre></td></tr></table></figure><p>上述代码使用了两种方式赋值给字符串变量</p><blockquote><p>常量池 (constant pool): 用于管理编译时已经创建并保存在类文件(.class)中的数据, 通常包括 常量(类 方法 接口中) 字符串常量</p></blockquote><p>用new String(“”)创建的字符串对象将保存在堆内存(运行时内存区), 但是常量池中的对象将在编译时就确定并保存, 不需要在运行时候再创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">1</span>==<span class="hljs-number">1.0</span>);<br><span class="hljs-comment">//输出ture</span><br>System.out.println(<span class="hljs-number">65</span>==<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-comment">//输出true</span><br></code></pre></td></tr></table></figure><p>Object类提供了equals()实例方法用于将两个对象进行比较 注意equals()方法的判断逻辑和要求与使用&#x3D;&#x3D;运算符进行两个对象的比较时是完全相同的</p><blockquote><p>实际上Object类提供的equals()仅仅对两个引用变量指向的对象内存地址进行比较, 地址相同就返回true</p></blockquote><blockquote><p>String类已经重写了equals()方法, 只要两个字符串的内容是相同的, 就返回true</p></blockquote><blockquote><p>instanceof运算符与equals方法不同, instanceof运算符的操作数为前面实例 后面类</p><p>equals为两个对象的比较</p></blockquote><p>equals方法重写一般要遵循下面的原则:</p><p>自反性: x.equals(x)一定返回true</p><p>对称性: 如果x.equals(y)为true, 则y.equals(x)一定为true</p><p>传递性: 对于x, y, z, 如果x.equals(y)为true, x.equals(z)为true, 则y.equals(z)为true</p><p>一致性:对于x ,y, 如果用于对比的信息没有改变, 那么x.equals(y)的结果不会发生改变</p><p>如果x不为null, x.equals(null)一定为false</p><h1 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h1><p>用static修饰的成员叫做类成员</p><p>Java中类有5种成员: 成员变量  方法 构造器 初始化块 内部类</p><p>内部类包括接口 枚举 </p><p>用static修饰的类成员属于整个类</p><p>非static成员属于单个实例&#x2F;对象, 为实例&#x2F;对象成员</p><p><strong>类成员变量存储在元空间中</strong></p><p><strong>实例成员变量存储在堆内存(运行时内存)中</strong></p><blockquote><p>在大部分的语言中都不允许通过对象来访问类变量, Java虽然可以通过对象来访问类变量, 但是不建议使用这个特性</p></blockquote><blockquote><p>规范的编程应该是只通过对象来访问实例成员</p><p>访问类成员只通过类来访问</p></blockquote><blockquote><p>在Java中null对象可以正常访问其所属的类成员</p><p>但是试图访问null对象的实例成员时, 将引发NullPointerException错误, 表示null对象实际上是不存在的</p></blockquote><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;1&quot;</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>;<br><span class="hljs-comment">//该代码运行中一共创建了4个字符串</span><br></code></pre></td></tr></table></figure><p><strong>字符串调用的方法都不会修改字符串本身</strong></p><p>indexOf()</p><p>charAt()</p><p>concat()</p><p>contains()</p><p>equals()</p><p>equalsIgnoreCase()</p><p>startWith()</p><p>endWith()</p><p>getBytes()</p><p>toCharArray()</p><p>isEmpty()</p><p>trim()</p><p>split()</p><p>substring()</p><p>replace()</p><p>lastIndexOf()</p><p>toUpperCase()</p><p>toLowerCase()</p><p>valueOf()</p><p>Intern()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;123&quot;</span>;<br>      String str3=<span class="hljs-string">&quot;abc&quot;</span>;<br>      String str4=<span class="hljs-string">&quot;ABC&quot;</span>;<br>      System.out.println(str.indexOf(<span class="hljs-string">&quot;23&quot;</span>));<br>      <span class="hljs-comment">//返回字符所在index</span><br>      System.out.println(str.charAt(<span class="hljs-number">1</span>));<br>      <span class="hljs-comment">//返回index对应的字符</span><br>      String str2=str.concat(<span class="hljs-string">&quot;456&quot;</span>);<br>      <span class="hljs-comment">//进行字符串拼接,等同于+操作</span><br>      System.out.println(str2.contains(<span class="hljs-string">&quot;56&quot;</span>));<br>      <span class="hljs-comment">//判断是否包含另一个字符串</span><br>      System.out.println(str3.equals(str4));<br>      <span class="hljs-comment">//判断字符串内容是否相等</span><br>      System.out.println(str3.equalsIgnoreCase(str4));<br>      <span class="hljs-comment">//判断字符串内容是否相等, 忽略字母大小写的区别</span><br>      System.out.println(str3.startsWith(<span class="hljs-string">&quot;a&quot;</span>));<br>      <span class="hljs-comment">//判断字符串的开头是否是另一个字符串</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>包装类</title>
    <link href="/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <url>/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>Java中的8个基本类型都有对应的包装类</p><blockquote><p>8种基本数据类型: byte short char int long float double boolean</p></blockquote><p>包装类可以将基本数据类型的值转换成对象使用</p><p>并且JDK1.5提供了自动装箱和自动拆箱的功能</p><p>允许同类型的包装类对象和基本类型变量间可以直接赋值</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>除了int和char的对应包装类为其单词全写外, 其他包装类都是首字母大小即可</p><p>在Java1.5提供自动装箱(Autoboxing)和自动拆箱(AutoUnboxing)之前必须使用包装类中的valueOf()和xxxValue()方法来实现基本数据类型和包装类对象的相互转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer integer1=Integer.valueOf(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//手动装箱</span><br><span class="hljs-type">int</span> i2=integer1.intValue();<br><span class="hljs-comment">//手动拆箱</span><br>integer1=i2;<br><span class="hljs-comment">//自动装箱</span><br>i2=integer1;<br><span class="hljs-comment">//自动拆箱</span><br>String str2=<span class="hljs-string">&quot;2.2&quot;</span>;<br><span class="hljs-comment">//str2无法转换为Integer对象, 因为该字符串并非整数格式</span><br>String str2=<span class="hljs-string">&quot;2&quot;</span>;<br>integer1 =Integer.parseInt(str2);<br><span class="hljs-comment">//通过Integer.parseInt方法将字符串转为Integer对象</span><br>Double d=Double.parseDouble(str2);<br><span class="hljs-comment">//但是Double.parseDouble可以接受整数格式的字符串</span><br></code></pre></td></tr></table></figure><p>如图:</p><p><img src="/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/image-20220506173943789.png" alt="image-20220506173943789"></p><p>在包装类中, 还提供了将字符串和其他基本类型进行相互转换的方法</p><ol><li>parseXxx(String s) :除了Character类的所有包装类都提供该方法</li><li>valueOf(String s)</li></ol><p>将基本类型变量与””空字符串进行拼接操作, 会自动将基本类型变量转换为字符串, 更方便</p><blockquote><p>包装类作为引用变量可以直接与基本类型变量进行比较(发生了自动拆箱)</p><p>两个包装类对象引用变量进行比较时, 只有两个引用变量是指向同一个对象时才会返回true</p></blockquote><p>JDK1.5后的自动装箱有缓存机制, -128~127之间的整数装箱成Integer实例后将存储到一个cache数组中, 第二次使用时将直接从cache数组中取出不再重复创建</p><p>所以-128~127自动装箱创建的实例进行相等比较将返回true</p><blockquote><p>byte范围-128~127</p></blockquote><p><strong>为什么byte的范围是-128~127</strong></p><p>0000 0000</p><p>byte</p><p>00000000</p><p>符号位占一位 存储数值的位有7位</p><p>2^(8-1)-1</p><p>128-1&#x3D;127</p><blockquote><p>Java使用二进制补码来存储负数</p></blockquote><p><img src="/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/image-20220507111215881.png" alt="image-20220507111215881"></p><p>正数和负数在计算机底层均以补码的形式存储</p><p>2*(9-1)-1&#x3D;255</p><p>255&#x3D;128+127</p><blockquote><p>-128以8位2进制表示: 1000 0000</p><p>1000 0000补码</p><p>0111 1111 +1</p><p>1000 0000</p><p>负数补码计算方式</p><p>正数的补码是其本身</p></blockquote><p>Java7中提供了包装类对象的比较方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.compare(Integer val1, Integer vla2)<br><br>Integer.compare(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//输出1</span><br>Integer.compare(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//输出-1</span><br>Integer.compare(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//输出0</span><br></code></pre></td></tr></table></figure><p>Java7中还为Character包装类增加了大量工具方法, 用于对字符进行判断</p><p>Java8为整数包装类提供了无符号运算方法</p><p>如:</p><p>static String toUnsignedString(int&#x2F;long i):</p><p>将int&#x2F;long整数转换为无符号整数对应的字符串</p><blockquote><p>这些方法好像有字符串拼接, 强制转换等替代方法可以实现相同的功能</p></blockquote><blockquote><p>注意将负数转换成无符号整数时, 不会是直接取其绝对值, 而是将其补码的符号位1作为数值位, 作为原码计算出对应的无符号整数 </p></blockquote><p>如8位byte存储的-3</p><p>原码: 1000 0011</p><p>补码: 1111 1100+1</p><p>1111 1101</p><p>其无符号整数为253</p><p><strong>自动装箱时, 如果数值在-128到 127之间的范围，Integer会有缓存机制</strong></p><p><strong>所有的包装类都被final修饰, 不能被继承</strong></p><p>常见API:</p><ol><li><p>两个类常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.MIN_VALUE;<br><span class="hljs-comment">//int类型的最小取值</span><br>Integer.MAX_VALUE; <br><span class="hljs-comment">//int类型的最大取值</span><br></code></pre></td></tr></table></figure></li><li><p>将字符串转换为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.parseInt(String str);<br></code></pre></td></tr></table></figure></li><li><p>将十进制转换为其他进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> i=<span class="hljs-number">15</span>;<br>Integer.toBinaryString(i);<br><span class="hljs-comment">//转换成2进制字符串</span><br>Integer.toOctalString(i);<br><span class="hljs-comment">//转换成8进制字符串</span><br>Integer.toHexString(i);<br><span class="hljs-comment">//转换成16进制字符串</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h1><blockquote><p>Date中的大部分方法已经被废弃, 因为Date显示的时间为当前系统的所在时区的当地时间, 不支持国际化</p><p>可以使用Calender类来代替Date类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Date d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis());<br><span class="hljs-comment">//以1970-1-1到某个时间的时间差(毫秒为单位)创建Date对象</span><br>Date d2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>Date d3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-comment">//创建一个当前时间的Date对象</span><br>System.out.println(d);<br>System.out.println(d2);<br><span class="hljs-comment">//d和d2的输出相同</span><br>d.equals(d2);<br><span class="hljs-comment">//true</span><br>d3.equals(d2);<br><span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h1 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h1><p>需要先创建对象再通过对象调用实例方法</p><p>getTime()</p><blockquote><p>将Calendar对象转换为Date对象</p></blockquote><p>get()set()add()</p><blockquote><p>获取时间 修改时间 在存储的时间基础上加减时间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br><span class="hljs-comment">//注意Calendar对象储存的是创建的时间, 创建后不会变化</span><br>Date d1= cal.getTime();<br><span class="hljs-comment">//转换成Date对象</span><br>cal.get(Calendar.DAY_OF_YEAR);<br><span class="hljs-comment">//今年的第几天</span><br>cal.get(Calendar.DAY_OF_MONTH);<br><span class="hljs-comment">//这个月的第几天</span><br>cal.get(Calendar.DAY_OF_WEEK);<br><span class="hljs-comment">//这周的第几天</span><br>cal.get(Calendar.YEAR);<br><span class="hljs-comment">//公元第几年</span><br>cal.get(Calendar.MONTH);<br><span class="hljs-comment">//今年第几个月</span><br>cal.get(Calendar.DATE);<br><span class="hljs-comment">//和Calendar.DAY_OF_MONTH相同</span><br>cal.get(Calendar.HOUR_OF_DAY);<br><span class="hljs-comment">//今天的第几个小时</span><br>cal.get(Calendar.MINUTE);<br><span class="hljs-comment">//当前小时的第几分钟</span><br>cal.get(Calendar.SECOND);<br><span class="hljs-comment">//当前分钟的第几秒</span><br>cal.set(<span class="hljs-number">1997</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//将时间修改为1997年6月1日,修改对象本身</span><br>cal.add(Calender.YEAR,<span class="hljs-number">60</span>);<br><span class="hljs-comment">//将时间修改为60年后, 会修改对象本身</span><br>cal.add(Calender.YEAR,-<span class="hljs-number">60</span>);<br><span class="hljs-comment">//将时间修改为60年前, 会修改对象本身</span><br></code></pre></td></tr></table></figure><h1 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h1><p>用于将字符串和Date对象按照一定格式进行相互转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>String str=<span class="hljs-string">&quot;2022-05-16 12:00:12&quot;</span>;<br>SimpleDateFormat sdf=<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br><span class="hljs-comment">//注意月份和分钟分别用大小写的M和m表示</span><br>Date date=sdf.parse(str);<br><span class="hljs-comment">//将格式的字符串转换成对应时间的Date对象</span><br>System.out.println(date);<br>Date date1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>sdf.format(date1);<br><span class="hljs-comment">//将Date对象转换成格式化的字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>必须加上throws ParseException捕获异常, 否则编译会报错</p><blockquote><p>完整格式参考表格</p></blockquote><p><img src="/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/image-20220516145849340.png" alt="image-20220516145849340"></p><h1 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h1><p><strong>LocalDate按照系统所在语言的格式来输出时区对应的日期</strong></p><p><strong>注意LocalDate对象储存的是年月日, 不包含小时 分钟 秒</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDate ld=LocalDate.now();<br><span class="hljs-comment">//创建LocalDate对象存储当前时间</span><br>System.out.println(ld);<br><span class="hljs-comment">//输出2022-05-16格式的年月日</span><br>ld.getYear();<br><span class="hljs-comment">//输出年份</span><br>ld.getMonth().getValue();<br><span class="hljs-comment">//输出第几个月</span><br><span class="hljs-comment">//使用ld.getMonth()会输出月份的英文单词</span><br>ld.getDayOfMonth();<br><span class="hljs-comment">//输出一个月中的第几天</span><br>ld.getDayOfYear();<br><span class="hljs-comment">//输出一年中的第几天</span><br>ld.getDayOfWeek();<br><span class="hljs-comment">//输出一周的第几天</span><br>LocalDate ld2=LocalDate.of(<span class="hljs-number">2022</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>);<br><span class="hljs-comment">//修改时间</span><br>ld2.isLeapYear();<br><span class="hljs-comment">//判断是否是闰年</span><br><span class="hljs-comment">//输出假</span><br>ld2.isAfter(ld);<br><span class="hljs-comment">//判断ld2的时间是否在ld之后</span><br><span class="hljs-comment">//输出假</span><br>String str=ld.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH时-mm分钟-ss秒&quot;</span>));<br><span class="hljs-comment">//上行代码会报16错, 因为LocalDate对象中不存储小时 分钟 秒</span><br>String str=ld.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>));<br><span class="hljs-comment">//将LocalDate对象转换为格式化字符串</span><br>String str2= <span class="hljs-string">&quot;2022年05月16日&quot;</span>;<br>LocalDate ld3=LocalDate.parse(str2,DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>));<br><span class="hljs-comment">//将字符串转换为LocalDate对象</span><br>LocalDate ld4=ld3.plusDays(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//将时间加10天, 返回修改后的时间, 不会修改对象本身</span><br>ld4=ld4.plusDays(-<span class="hljs-number">10</span>);<br><span class="hljs-comment">//减10天, 不修改原对象</span><br>ld4=ld4.plusMonths(<span class="hljs-number">5</span>);<br><span class="hljs-comment">//加5个月,不修改原对象</span><br>ld4=ld4.plusYears(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//加一年, 不修改原对象</span><br></code></pre></td></tr></table></figure><h1 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h1><p>跟LocalDate类似, 但是存储的是时分秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalTime lt= LocalTime.now();<br>lt.getHour();<br>lt.getMinute();<br>lt.getSecond();<br>lt=LocalTime.of(<span class="hljs-number">23</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>);<br><span class="hljs-comment">//修改时间</span><br>String str=lt.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>));<br><span class="hljs-comment">//不能使用hh,这里只能使用HH</span><br><span class="hljs-comment">//将LocalTime对象转换为字符串</span><br>lt=LocalTime.parse(<span class="hljs-string">&quot;11点45分30秒&quot;</span>,DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH点mm分ss秒&quot;</span>));<br><span class="hljs-comment">//不能使用hh,这里只能使用HH</span><br></code></pre></td></tr></table></figure><h1 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h1><p>存储年月日 时分秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime ldt=LocalDateTime.now();<br>ldt.getDayOfYear();<br>ldt.getDayOfMonth();<br>ldt.getHour();<br>ldt=LocalDateTime.of(<span class="hljs-number">2022</span>,<span class="hljs-number">3</span>,<br>        <span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>);<br>String str=ldt.format(DateTimeFormatter<br>        .ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));<br><span class="hljs-comment">//注意HH为24小时制</span><br><span class="hljs-comment">//hh为12小时制</span><br>ldt=LocalDateTime.parse(str,DateTimeFormatter<br>        .ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));<br></code></pre></td></tr></table></figure><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>错误(error): 对程序来说不可预测, 不可避免</p><blockquote><p>例如OOM(out of memory) 内存不足导致程序被关闭</p></blockquote><p>异常(exception)分为编译时异常和运行时异常, 都可以通过修改代码处理</p><p>编译时异常:编译器编译时检查出的问题</p><p>运行时异常:程序运行时在JVM抛出的异常</p><p><img src="/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/image-20220516193158131.png" alt="image-20220516193158131"></p><blockquote><p>异常继承树</p></blockquote><p><strong>exception可以通过代码来解决, 体现了Java的健壮性</strong></p><blockquote><p>编译时异常的父类是Exception</p><p>运行时异常的父类是RuntimeException</p></blockquote><p>编译时异常有:</p><p><img src="/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/image-20220516193429760.png" alt="image-20220516193429760"></p><p>运行时异常有:</p><p><img src="/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/image-20220516193455333.png" alt="image-20220516193455333"></p><p>方法栈中的调用关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainEnter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        meth01();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meth01</span><span class="hljs-params">()</span> &#123;<br>        meth02();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meth02</span><span class="hljs-params">()</span> &#123;<br>        meth03();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meth03</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;猜猜我是谁！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中运行的方法栈如图所示</p><p><img src="/2022/11/03/%E5%8C%85%E8%A3%85%E7%B1%BB/image-20220516193642011.png" alt="image-20220516193642011"></p><blockquote><p>当一个方法主动抛出异常时, 将导致该方法被弹出方法栈, 并导致方法栈中在该方法上的方法也被弹出</p></blockquote><p>编译时异常的解决方案:</p><ol><li><p>不捕获异常, 直接向外抛出</p><blockquote><p>异常未被内部处理, 并且会异常方法会被弹出方法栈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;wrong input&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>捕获异常, 但不抛出</p><blockquote><p>异常会被内部消化, 方法不会被弹出栈</p><p>方法会全部执行完</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;wrong input&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>捕获异常并向外抛出</p><blockquote><p>异常被内部消化, 并告知调用的方法</p><p>导致产生异常的方法被弹出方法栈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-comment">//指定抛出异常的类型</span><br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> sdf.parse(<span class="hljs-string">&quot;wrong input&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> e;<br>        <span class="hljs-comment">//将捕获到的异常抛出给外部</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>总结: 1,3会导致方法被弹出栈结构, 剩余代码不会被执行</p><p>2不会弹出, 完整执行完方法的代码</p><p>通常编程中使用1,2方案</p><p>使用原则: 在栈结构允许的最高处捕获并处理异常, 其他层直接将异常外抛</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/11/03/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/11/03/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射用于在程序运行时获取类或接口的内部信息, 并直接操作对象的内部属性或方法</p><p>java.lang.Classs是java反射机制的核心类</p><p>java反射API由java.lang.Classs和java.lang.reflect组成</p><p>这两个类库包含了Field MethodConstructor等类, 用于表示未知类的成员</p><blockquote><p>通过反射可以获取未知对象或者未知类中的方法 属性,并在程序运行时对这些未知方法 类 接口进行修改</p></blockquote><blockquote><p>意味着反射可以用于在运行时对未知对象进行临时性的修改, 该修改仅仅在程序运行时生效, 不会对类的字节码文件进行修改</p></blockquote><p><img src="/2022/11/03/%E5%8F%8D%E5%B0%84/image-20220607153149029.png" alt="image-20220607153149029"></p><p><img src="/2022/11/03/%E5%8F%8D%E5%B0%84/image-20220607144819280.png" alt="image-20220607144819280"></p><blockquote><p>使用反射调用方法时, 不受访问修饰符限制</p></blockquote><p>获取Class对象的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过类的实例获取</span><br>Person person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>Class&lt;Person&gt; class01=person.getClass();<br><span class="hljs-comment">//通过调用类的class属性获取</span><br>Class&lt;Person&gt; class02=Person.calss;<br><span class="hljs-comment">//通过调用Class.forName()方法获取, 注意要输入包名加类名</span><br>Class&lt;Person&gt; class03=Class.forName(<span class="hljs-string">&quot;com.lee.project.Person&quot;</span>);<br><span class="hljs-comment">//通过类加载器获取</span><br>ClassLoader classLoader=<span class="hljs-built_in">this</span>.getClass().getClassLoader();<br>Class&lt;Person&gt; class04=classLoader.loadClass(<span class="hljs-string">&quot;com.lee.project.Person&quot;</span>)<br></code></pre></td></tr></table></figure><p>常用的反射API(实例方法)有:</p><blockquote><p>java.lang.Class</p></blockquote><blockquote><p>反射通过方法名和形参列表来调用方法, 形参列表为空时需要null作为参数</p></blockquote><table><thead><tr><th>API</th><th>功能</th></tr></thead><tbody><tr><td>获取类的内部信息</td><td></td></tr><tr><td>getClass()</td><td>获取对象所属类的类名</td></tr><tr><td>getConstructors()</td><td>获取类的构造器</td></tr><tr><td>getDeclaredConstructor()</td><td>获取私有构造器</td></tr><tr><td>getMethods()</td><td>获取类的公有方法</td></tr><tr><td>getDeclareMethod()</td><td>获取类的私有方法</td></tr><tr><td>getField()</td><td>获取类的公有属性</td></tr><tr><td>getDeclareField()</td><td>获取类的私有属性</td></tr><tr><td>invoke()</td><td>获取方法后用方法对象调用方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取私有成员后, 在操作前需要将访问权限设置为可访问</span><br>setAccessible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>利用反射可以操作类的元素: 构造器  属性  方法  注解</p><p>反射API的特性:</p><ol><li>可扩展性</li><li>可以作为调试测试工具: 检查类的私有成员</li><li>性能效率偏低: 反射操作的性能比非反射操作要慢, 效率较低</li><li>内部暴露: 反射允许代码执行非正常操作, 会导致代码的可移植性降低, 使抽象性被破坏</li><li>安全限制: 反射要求程序的运行环境没有安全限制</li></ol><p>反射属于Java的动态特性之一</p><blockquote><p>注解动态代理类加载器都属于java的动态特性</p></blockquote><p>动态特性经常被框架用来增强灵活性</p><p>例如:</p><ol><li>Spring MVC框架利用反射和注解将用户的请求转换为对应的Java对象, 也能将Java对象转变为响应式内容</li><li>单元测试库JUnit用到了反射</li><li>AOP编程利用java的动态特性将业务逻辑代码和通用代码(例如安全检查)分离, 减少代码冗余, 增强可维护性</li></ol><blockquote><p>AOP编程: 面向切面编程</p></blockquote><p><strong>类的生命周期</strong></p><ol><li>加载:    使用类加载器将class文件用IO流读入JVM, 生成Class对象(每个类都有一个对应的Class对象)</li><li>连接</li></ol><blockquote><p>连接包括验证 准备 解析三步</p><ol><li>验证:    验证字节码信息是否符合当前JVM的版本</li><li>准备:    给类变量(static变量)分配内存空间并赋初值</li><li>解析: 将常量池变量修改为内存地址</li></ol></blockquote><ol start="3"><li>初始化: 调用类身上的init()方法来执行static{}静态代码块, 并对static变量进行赋值</li><li>运行</li><li>卸载</li></ol><p>类的加载阶段分为 加载 连接 初始化三步</p><p>面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>    &#125;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>    A()&#123;<br>        System.out.println(<span class="hljs-string">&quot;aa&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>    B()&#123;<br>        System.out.println(<span class="hljs-string">&quot;bb&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainEnter</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上述代码输出A B a aa b bb</p></blockquote><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>使用类之前需要使用加载器加载类的信息</p><blockquote><p>java有三种类加载器</p></blockquote><ol><li>引导类加载器: 加载核心代码, java.*</li><li>扩展类加载器: 加载扩展代码, javax.*</li><li>应用类加载器: 加载当前程序的代码</li></ol><blockquote><p>加载器分类执行可以使java的核心类更安全</p></blockquote><blockquote><p>2继承了1, 3继承了2</p></blockquote><p>![image-20220607115855967](C:&#x2F;Users&#x2F;libolon&#x2F;Downloads&#x2F;java_note&#x2F;Mybatis 动态SQL&#x2F;image-20220607115855967.png)</p><blockquote><p>反射示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用反射加载JDBC驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>xml用反射加载类文件</p></blockquote><p><img src="/2022/11/03/%E5%8F%8D%E5%B0%84/image-20220607144447836.png" alt="image-20220607144447836"></p><p>反射的作用:</p><p>反向加载外部类</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程 Thread</p><p>进程 Process</p><p>一个进程可以有多个线程</p><p>一个process对应多个thread</p><p>线程的生命周期: 创建就绪运行阻塞死亡</p><h1 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h1><p>并行 Parallel</p><p>并发 concurrent</p><p>并行指多个任务在同一时刻运行(多核)</p><p>并发是指多个任务在同一时间段内有执行(单核, 时分复用)</p><p><img src="/2022/11/03/%E5%8F%8D%E5%B0%84/image-20220608094219469.png" alt="image-20220608094219469"></p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多线程优势: 可以充分利用多核CPU的计算能力, 提高程序的运行速度</p><blockquote><p> 单线程:只能利用单核CPU的计算能力java中通过继承Thread或 实现Runnable或Callable接口来使类获取多线程能力</p></blockquote><p>Java的多线程调度算法有两种: 分时调度优先级调度</p><blockquote><p>Java的多线程都是依靠C语言所写的底层算法, 等同于依靠CPU来控制线程调度(调度算法也是CPU本身用的调度算法)</p></blockquote><p>分时调度: 按照时间分配CPU运行的线程, 给每个线程分配CPU的运行时间片</p><p>优先级调度: 线程优先级越高, 分配到时间片的概率越高</p><blockquote><p>java设定的线程优先级默认是5, 范围是0-10</p></blockquote><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Thread实现多线程步骤:</p><ol><li>子类继承Thread类, 并重写run()方法, run()方法被称为线程执行体</li><li>new Thread子类的实例作为线程对象</li><li>调用创建实例的start()方法</li></ol><blockquote><p>Thread多线程生命周期图</p></blockquote><p><img src="/2022/11/03/%E5%8F%8D%E5%B0%84/image-20220608095946919.png" alt="image-20220608095946919"></p><blockquote><p>Thread实现多线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    Thread test=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;test线程&quot;</span>);<br>    <span class="hljs-comment">//获取线程状态 此时是NEW状态</span><br>    test.getState();<br>    <span class="hljs-comment">//设置线程优先级为10</span><br>    test.setPriority(<span class="hljs-number">10</span>)<br>    <span class="hljs-comment">//启动线程</span><br>    test.start();<br>    <span class="hljs-comment">//此时线程状态为RUNNABLE状态</span><br>    <span class="hljs-comment">//就绪, 已经通过start方法启动, 但是由于CPU有线程调度算法, 所以不会一直是运行中状态</span><br>    test.getState();<br>    <span class="hljs-comment">//让运行这行代码的线程休眠1秒</span><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>Runnable实现多线程的步骤</p><ol><li>实现类实现Runnable接口, 重写run()方法</li><li>创建实现类的实例, 并用该实例作为Thread的构造器参数创建Thread实例作为真正的线程对象</li><li>调用线程对象的start()方法</li></ol><p>可以认为Runnable的多线程是依赖于Thread类实现的</p><blockquote><p>Runnable实现多线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;主线程启动&quot;</span>);<br>        Thread mt=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgThread</span>();<br>        mt.start();<br>        System.out.println(<span class="hljs-string">&quot;主线程结束&quot;</span>);<br>        Thread mt2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgThread</span>();<br>        mt2.start();<br><br>        EmailTask et=<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmailTask</span>();<br>        Thread td=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(et);<br>        td.start();<br>        Thread td2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(et);<br>        td2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgThread</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发邮件&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意Thread或Runnable实现的多线程run方法被void修饰, 不能有返回值</p><p>但是Callable实现的call方法可以有返回值</p><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>Callable实现多线程步骤:</p><ol><li>实现类实现Callable接口, 重写call()方法, call方法是线程执行体</li><li>创建Callable的实现类的实例, 传入FutureTask或ExecutorService的构造器创建线程对象</li><li>调用线程对象的run或submit方法</li><li>可以用get方法获取返回值</li></ol><blockquote><p>FutureTask和ExecutorService都在java.util.concurrent包下面</p></blockquote><p><strong>Thread和Runnable的区别</strong></p><ol><li>Thread是类, Runnable是接口</li><li>Thread是线程对象, Runnable要依靠Thread类创建线程对象</li><li>实现Thread不能再继承其他的父类, 但是Runnable接口不影响实现类继承其他父类</li></ol><p><strong>Runnable和Callable的区别</strong></p><ol><li>Runnable没有返回值, Callable可以获取返回值</li><li>Runnable不能抛出异常, Callable可以抛出异常</li><li>Runnable是异步多线程, 一个线程完成会立刻开启新线程, 无阻塞状态</li><li>Callable是同步多线程, 一个线程完全要等其他多线程完成再一起创建新的多线程, 阻塞状态</li></ol><h2 id="线程池-ExecutorService"><a href="#线程池-ExecutorService" class="headerlink" title="线程池(ExecutorService)"></a>线程池(ExecutorService)</h2><blockquote><p>线程池实现Callable接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ThreadTask是具有多线程能力的类</span><br>ThreadTask tt=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadTask</span>;<br><span class="hljs-comment">//创建一个容量为5的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>Future&lt;Integer&gt; res = es.submit(rt);<br><span class="hljs-comment">//获取运行结果</span><br>res.get();<br><span class="hljs-comment">//结束线程池的运行</span><br>es.shutdown();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多态复习</title>
    <link href="/2022/11/03/%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/11/03/%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>多态复习</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-comment">//    public int i=10;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> i=<span class="hljs-number">20</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test05</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        B b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        A a=b;<br>        System.out.println(b.i);<br>        <span class="hljs-comment">//下行代码会报错, 因为a中只能调用A存在的成员变量</span><br>        <span class="hljs-comment">//如果注释掉A类中的代码将会输出10</span><br>        System.out.println(a.i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遍历HashMap的三种方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Map map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-comment">//通过keySet方法遍历key</span><br><span class="hljs-keyword">for</span> (Object key : map.keySet()) &#123;<br>    System.out.println(key);<br>&#125;<br><span class="hljs-comment">//通过values方法遍历value</span><br><span class="hljs-keyword">for</span> (Object value : map.values()) &#123;<br>    System.out.println(value);<br>&#125;<br><span class="hljs-comment">//通过entrySet和迭代器遍历map</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span>map.entrySet().iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    Map.Entry entry=(Map.Entry)it.next();<br>    entry.getKey();<br>    entry.getValue();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多表查询</title>
    <link href="/2022/11/03/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/03/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>遵循三大范式后设计的数据库中会存在多个表, 当需要的信息来自于多个数据表时, 会用到多表查询</p><blockquote><p>最简单粗暴的多表查询, 笛卡尔乘积</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">#直接将两个表的数据一条对应m条<br>#得到的组合表的记录数将是n<span class="hljs-operator">*</span>m<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student,score;<br></code></pre></td></tr></table></figure><blockquote><p>笛卡尔乘积一般用where语句配合外键进行筛选出有逻辑关联的数据</p></blockquote><h3 id="内联查"><a href="#内联查" class="headerlink" title="内联查"></a>内联查</h3><blockquote><p>内联查语法</p></blockquote><p>… inner join … on …</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#使用student的id作为外键进行筛选数据<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score<span class="hljs-operator">=</span>sc,student<span class="hljs-operator">=</span>st <span class="hljs-keyword">where</span> sc.fk_id<span class="hljs-operator">=</span>st.id;<br>#等同于上一条<span class="hljs-keyword">sql</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">as</span> sc <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> student <span class="hljs-keyword">as</span> st <span class="hljs-keyword">on</span> sc.fk_id<span class="hljs-operator">=</span>st.id<br></code></pre></td></tr></table></figure><p><strong>mysql不支持全外联查</strong></p><table><thead><tr><th>联查</th><th>区别</th></tr></thead><tbody><tr><td>内联查</td><td>只显示满足连接条件的数据</td></tr><tr><td>全外联查</td><td>不满足连接条件的数据也显示(全部数据)</td></tr><tr><td>左外联查</td><td>将右表不满足连接条件的数据丢弃</td></tr><tr><td>右外联查</td><td>将左表不满足连接条件的数据丢弃</td></tr></tbody></table><p>内联查要求两个表都必须有数据才输出到联合表</p><p>外联查是以其中一个表为基础, 将另一个表的匹配数据拼接到右边组成联合表</p><blockquote><p>外联查允许右边的表没有对应数据, 将没有数据的行都置为null</p></blockquote><p>外联查分为左外连接和右外连接</p><p>… left join … on …</p><blockquote><p>注意on语句等同于where语句</p></blockquote><p>左外连接以左表为基础, 右外连接以右表为基础</p><blockquote><p>注意 外联查都是将另一个表的匹配数据拼接到基础表的右边</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <br></code></pre></td></tr></table></figure><p><strong>注意 内联查和外联查必须有on语句作为筛选条件</strong></p><blockquote><p>但是on语句的筛选条件可以是普通字段, 不一定是外键或主键</p></blockquote><p><strong>注意</strong></p><ol><li><p>左右外联查不会影响字段的顺序, 永远是前表字段在前, 后表字段在后, 但是左右外联查的左右会影响哪一边的数据作为基础, 哪一边的数据可能被置为null</p></li><li><p><strong>如果用到group by, select的字段必须出现在group by, 否则需要用group_concat函数来进行聚合</strong></p></li><li><p><strong>select后如果两个表存在相同字段, 必须使用表名.字段来指定</strong></p></li><li><p><strong>如果要将两个表的数据都进行筛选, 需要使用inner join</strong></p><blockquote><p>用外联查会导致另一个表中不符合筛选的数据被填充为null</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#用group_concat函数聚合有重复值的字段<br><span class="hljs-keyword">select</span> GROUP_CONCAT(id),stu_no <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> stu_no;<br></code></pre></td></tr></table></figure></li></ol><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>查询语句中可以嵌套子查询, 子查询返回的结果实质为数据库的view(视图)对象</p><blockquote><p>由于子查询返回的视图为临时的, 因此也被称为行内视图</p><p>用create view 语句创建的视图是永久的</p></blockquote><p>子查询语句可以放在三个地方 select后 from后 where in 后</p><ol><li>select … from … where … in (子查询)</li><li>select 字段,(子查询) from …</li><li>select … from (子查询)</li></ol><blockquote><p>in可以用&#x3D;any代替</p></blockquote><blockquote><p>当子查询跟在select语句后作为字段使用时, 其返回结果必须只有一列或者一行</p></blockquote><p>子查询在select语句后作为字段使用时如果产生了相关子查询, 会导致查询效率非常低, 会执行n次查询(n为子查询返回结果的单元格数目n)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#相关子查询<br>#非相关子查询<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">#注意子查询返回的字段必须与<span class="hljs-keyword">where</span>语句后的字段一一对应<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> a_table <span class="hljs-keyword">where</span> (a_id,a_name) <span class="hljs-keyword">in</span><br>(<span class="hljs-keyword">select</span> b_id,b_name <span class="hljs-keyword">from</span> b_table);<br>#子查询作为视图也可以在<span class="hljs-keyword">from</span>语句后面作为数据源(等同于表)<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> a_table) <span class="hljs-keyword">as</span> a <span class="hljs-keyword">where</span> a.id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>#子查询作为字段使用<br>#将学生表和班级表进多表联查询<br><span class="hljs-keyword">select</span> stu_name,(<span class="hljs-keyword">select</span> class_name <span class="hljs-keyword">from</span> class_info <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>fk_class_id) <span class="hljs-keyword">from</span> student_info;<br>#面试题 如果需要去除某个字段中有重复值的记录, 该如何操作<br>#删除有重复学号的学生, 仅保留id最小的记录<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">where</span> id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">MIN</span>(id) <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> stu_no)<span class="hljs-keyword">as</span> X);<br></code></pre></td></tr></table></figure><h2 id="union连查表"><a href="#union连查表" class="headerlink" title="union连查表"></a>union连查表</h2><p>连查表可以将多个sql语句返回的view(结果视图)合并(直接将记录合并,并非字段拼接)</p><p>用途:将多张结构相同的数据表合并展示</p><p>union或者union all</p><blockquote><p>union all单纯将后一个表的记录接到前一个表的记录下面(后表的字段名不会保留)</p><p>union会将合并的view去除重复的记录</p></blockquote><p><strong>union要求两个view的字段数相同,字段类型不需要相同</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#将student_info表合并成一张<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student_info;<br>#将student_info表合并成一张并去除重复的记录<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student_info <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student_info;<br></code></pre></td></tr></table></figure><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC( java database connectivity)</p><p>jdbc是java数据库编程的基础, 提供了一套API用于在数据库中执行sql语句</p><blockquote><p>jdbc是跨平台跨数据库的</p></blockquote><p>jdbc编程是一套标准api, 可以使用相同的代码操作不同的数据库.</p><blockquote><p>但是需要切换数据库驱动(实现类)(切换层)</p></blockquote><p>JDBC工作步骤:</p><ol><li>连接数据库</li><li>在数据库中执行sql语句</li><li>将sql语句的执行结果返回</li></ol><p><img src="/2022/11/03/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/image-20220526154354456.png" alt="image-20220526154354456"></p><p>JDBC是模仿ODBC来设计的,但是JDBC更简单更安全</p><h1 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h1><p>DBMS: 数据库管理系统(database management system)</p><p>DBMS是直接管理数据库的系统, 通常会将数据库和DBMS统称为数据库</p><p>DBMS负责执行对数据库的所有操作, 并且维护着一个字典(系统表), 用于存储DBMS中每个事务的信息</p><p>这种关于数据的数据也被称为元数据(metadata)</p><blockquote><p>database中存储的只有数据和数据的关系</p></blockquote><p>数据库按照历史发展顺序有如下4种</p><ol><li>网状型数据库</li><li>层次型数据库</li><li>关系数据库</li><li>面向对象数据库</li></ol><p>其中关系数据库是最普遍 最成熟的数据库</p><p>也是需要重点学习的数据库</p><p>mysql的一个实例(server instance)可以包含多个数据库, 通过use命令切换数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">#显示当前mysql服务器实例下的所有数据库<br><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p>mysql支持两种存储机制:myisaminnodb</p><p>innodb为当前mysql默认使用的存储机制, 支持事务安全性</p><p>myisam为早期mysql的储存机制, 事务支持较差</p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束也被称为完整性约束, 可以视为对字段数据限制</p><blockquote><p>约束的对象都是以字段为单位</p></blockquote><p>mysql中的约束有4种: </p><table><thead><tr><th>关键字</th><th>功能</th></tr></thead><tbody><tr><td>not null</td><td>非空</td></tr><tr><td>unique</td><td>唯一</td></tr><tr><td>primary key</td><td>主键</td></tr><tr><td>foreign key</td><td>外键</td></tr></tbody></table><blockquote><p>mysql不支持check约束</p></blockquote><p><strong>注意defalut关键字不属于约束, 因为它仅仅是在插入新数据时将未填写的字段赋默认值(系统提供的默认值为null)</strong></p><blockquote><p>defalut字段可以有null值</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何处理空指针异常</title>
    <link href="/2022/11/03/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/11/03/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="如何处理空指针异常"><a href="#如何处理空指针异常" class="headerlink" title="如何处理空指针异常"></a>如何处理空指针异常</h1><ol><li>原因</li><li>常见的场景</li><li>解决方案<ol><li>接收参数使用StringUtils.isEmpty(str);校验</li><li>前端处理</li><li>返回值使用@NonNull、@CheckForNull进行检查</li></ol></li></ol><p>ArrayList扩容：</p><ol><li>ArrayList底层使用数组实现，默认数组长度为10</li><li>当达到数组最大长度时会执行扩容操作，使用位运算将长度增长为原来的1.5倍，创建新的数组并将旧数组的数据复制到新的数组</li></ol><table><thead><tr><th>常用接口</th><th>作用</th></tr></thead><tbody><tr><td>Serializable</td><td>支持序列化</td></tr><tr><td>RandomAccess</td><td>快速随机访问</td></tr><tr><td>Cloneable</td><td>可克隆</td></tr><tr><td>Runnable</td><td>可运行</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>存储过程</title>
    <link href="/2022/11/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/11/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程是一组sql语句, 通常用于完成特定的功能</p><p>存储过程存储在数据库中, 一次编译可以多次使用</p><p>存储过程优点:</p><ol><li>完成复杂的逻辑判断&#x2F;运算</li><li>灵活</li><li>相当于sql编程, 代码可重用</li><li>减少网络开销</li><li>执行速度快(编译后使用)</li></ol><blockquote><p>存储过程的创建和调用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">#创建存储过程<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> test()<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">order</span>;<br><span class="hljs-keyword">end</span>;<br>#调用存储过程<br><span class="hljs-keyword">call</span> test();<br></code></pre></td></tr></table></figure><blockquote></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何实现分页(Myabtis-plus)</title>
    <link href="/2022/11/03/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5(Myabtis-plus)/"/>
    <url>/2022/11/03/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5(Myabtis-plus)/</url>
    
    <content type="html"><![CDATA[<h1 id="如何实现分页-Myabtis-plus"><a href="#如何实现分页-Myabtis-plus" class="headerlink" title="如何实现分页(Myabtis-plus)"></a>如何实现分页(Myabtis-plus)</h1><ol><li>底层使用Sql语句的limit关键字 </li><li>前端element分页</li><li>后端pageHelper插件</li><li>page方法</li><li>原理 拦截sql语句 用了limit</li><li>分页问题 最后一页 一条数据删除后无法回退 解决方案: 前端进行逻辑判断（获取全部的数据量）</li></ol><p>element实现分页：</p><ol><li>el-pagination标签，@size-change绑定页面刷新时执行的方法，:current-page绑定当前页数 :page-size绑定页面数据大小</li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>定时任务</title>
    <link href="/2022/11/03/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/11/03/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><ol><li>Timer</li><li>ScheduledExecutorService</li><li>Scheduled(Spring Task)</li><li>队列时间轮</li></ol><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>底层使用TaskQueue存放定时任务</p><p>TaskQueue: 基于最小堆实现的优先级队列, 按照任务距离下一次执行时间的大小来排序, 保证堆顶任务最先执行</p><blockquote><p>代码实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例代码：</span><br><span class="hljs-type">TimerTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;n&quot;</span> +<br><span class="hljs-string">&quot;线程名称: &quot;</span> + Thread.currentThread().getName());<br> &#125;<br>&#125;;<br>System.out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;n&quot;</span> +<br><span class="hljs-string">&quot;线程名称: &quot;</span> + Thread.currentThread().getName());<br><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(<span class="hljs-string">&quot;Timer&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<br>timer.schedule(task, delay);<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:18:47 CST 2021n线程名称: main</span><br><span class="hljs-comment">//当前时间: Fri May 28 15:18:48 CST 2021n线程名称: Timer</span><br></code></pre></td></tr></table></figure><p>Timer是串行执行, 性能很差, 会抛出InterruptedException异常</p><h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><p>ScheduledThreadPoolExecutor是一个定时线程池实现类, 底层使用DelayQueue作为任务队列</p><blockquote><p>定时线程池实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">/ 示例代码：<br><span class="hljs-type">TimerTask</span> <span class="hljs-variable">repeatedTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;n&quot;</span> +<br><span class="hljs-string">&quot;线程名称: &quot;</span> + Thread.currentThread().getName());<br> &#125;<br>&#125;;<br>System.out.println(<span class="hljs-string">&quot;当前时间: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;n&quot;</span> +<br><span class="hljs-string">&quot;线程名称: &quot;</span> + Thread.currentThread().getName());<br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<br>executor.scheduleAtFixedRate(repeatedTask, delay, period,<br>TimeUnit.MILLISECONDS);<br>Thread.sleep(delay + period * <span class="hljs-number">5</span>);<br>executor.shutdown();<br><span class="hljs-comment">//输出：</span><br>当前时间: Fri May <span class="hljs-number">28</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">46</span> CST 2021n线程名称: main<br>当前时间: Fri May <span class="hljs-number">28</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">47</span> CST 2021n线程名称: pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>当前时间: Fri May <span class="hljs-number">28</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">48</span> CST 2021n线程名称: pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span><br>当前时间: Fri May <span class="hljs-number">28</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">49</span> CST 2021n线程名称: pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br>当前时间: Fri May <span class="hljs-number">28</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">50</span> CST 2021n线程名称: pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br>当前时间: Fri May <span class="hljs-number">28</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">51</span> CST 2021n线程名称: pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br>当前时间: Fri May <span class="hljs-number">28</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">52</span> CST 2021n线程名称: pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><p>注意Timer和ScheduledExecutorService都不支持Cron表达式</p></blockquote><h2 id="Spring-Task-Scheduled"><a href="#Spring-Task-Scheduled" class="headerlink" title="Spring Task(@Scheduled)"></a>Spring Task(@Scheduled)</h2><p>Spring Task使用Spring提供的@Scheduled注解来实现定时任务, 该注解直接作用于方法</p><p>@Scheduled基于ScheduledThreadPollExecutor线程池实现, 支持Cron表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* cron：使⽤Cron表达式。　每分钟的1，2秒运⾏</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Scheduled(cron = &quot;1-2 * * * * ? &quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportCurrentTimeWithCronExpression</span><span class="hljs-params">()</span> &#123;<br>log.info(<span class="hljs-string">&quot;Cron Expression: The time is now &#123;&#125;&quot;</span>, dateFormat.format(<span class="hljs-keyword">new</span><br><span class="hljs-title class_">Date</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><p>优点: 简单 支持Cron表达式</p><p>缺点: 功能单一 只支持单机系统</p><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><p>时间轮基于MQ实现, 时间轮可以视为一个环形队列, 每个元素(时间格)存放一个定时任务列表</p><p>走完全部时间格为时间轮的一轮时间</p><p>通过多圈时间轮或多层次时间轮可以实现定时任务的时间扩展</p><h1 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h1><p>分布式定时任务框架有三个角色:</p><ol><li>任务</li><li>调度器</li><li>执行器</li></ol><blockquote><p>常用的分布式定时任务框架</p></blockquote><p><img src="/2022/11/03/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20220915173412839.png" alt="image-20220915173412839"></p><h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP理论也被称为布鲁尔定理</p><p>CAP: </p><ol><li>一致性 Consistency: 数据一致性</li><li>可用性 Availability: 健康节点需要返回正确响应, 不能超时</li><li>容错性 Partition Tolerance: 网络分区不能影响正常服务</li></ol><p>网络分区:</p><p>系统多个集群间因为网络故障导致不互通</p><p><img src="/2022/11/03/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20220915174102229.png" alt="image-20220915174102229"></p><p>网络容错性P是CAP理论的必须满足条件, 而CA两点不能同时满足, 只能二选一</p><p>因此CAP架构的最终实现为CP(一致性)或AP(可用性)架构</p><blockquote><p>Nacos同时支持CP和AP架构, Eureka为AP架构</p></blockquote><p>银行系统一般采用CP架构, 保证业务的强一致性</p><p>互联网系统一般采用AP架构, 保证业务的高可用性</p><p><strong>BASE理论</strong></p><p>BASE理论基于互联网系统实践对CAP理论进行延伸和补充, 要求比CAP理论低</p><blockquote><p>BASE理论可以说是对AP架构的补充</p></blockquote><p>BASE的三大特点:</p><ol><li>BA: 基本可用</li><li>S:软状态</li><li>E: 最终一致性</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>序列化</title>
    <link href="/2022/11/03/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/11/03/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p><strong>序列化是指将内存中的对象转换为二进制信息写入IO流中, 也就是二进制流</strong></p><blockquote><p>通过对象序列化机制可以将对象转换为二进制流, 二进制流可以保存到硬盘中或者通过网络传输</p></blockquote><p><strong>反序列化是指程序通过硬盘或者网络接收到二进制流后在内存中将其恢复为原来的java对象</strong></p><blockquote><p>注意类的信息的是在编译时内存中, 也就是类文件中, 但是对象只有当程序运行时才能在内存中创建</p></blockquote><p>java中的序列化机制允许将对象转换为字节序列, 字节序列信息可以脱离内存和程序, 通过硬盘或网络进行传输和储存</p><blockquote><p>要求对象的类实现序列化接口</p></blockquote><p>java9中对序列化机制进行增强, 增加了数据校验机制, 提高了安全性和健壮性</p><p>将对象进行序列化时要求其对应的类必须实现序列化接口</p><p>java中有两种序列化接口 SerializableExternalizable</p><blockquote><p>如果类不实现序列化接口, 会在试图序列化其对象时抛出NotSerializableException</p></blockquote><p><strong>Serializable是一个标记接口, 实现该接口不需要实现任何方法</strong></p><blockquote><p>java中大部分系统提供的类已经实现了Serializable接口</p></blockquote><p>在网络编程中会有大量场景必须用到序列化</p><p>通常在编程中自定义的类可以实现Serializable接口来实现序列化</p><blockquote><p>不需要实现任何方法</p></blockquote><p>序列化步骤:</p><ol><li><p>创建ObjectOutputStream流(高级流)(对象序列化流)</p><blockquote><p>高级流的创建必须使用到低级流</p></blockquote></li><li><p>调用writeObject实例方法</p></li></ol><p>反序列化步骤</p><ol><li>创建ObjectInputStream流</li><li>调用readObject实例方法</li></ol><p><strong>序列化时只保存对象信息, 不会保存类信息</strong></p><p><strong>因此反序列化时必须确保类信息已经在当前程序中, 否则无法恢复对象</strong></p><blockquote><p>没有类信息时, 强行调用readObject方法会抛出ClassNotFoundException</p></blockquote><p><strong>序列化对象时, 其对应的类如果有父类或间接父类, 父类必须有无参构造器或者实现序列化接口, 否则会抛出InvalidClassException异常</strong></p><p>如果父类没有实现序列化接口,但是有无参构造器, 那么父类中的成员变量(实例变量)的值不会保存到对象中</p><p>而是调用无参构造器对父类的成员变量进行自动初始化</p><blockquote><p>序列化和反序列化代码示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-type">int</span> gender;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;gender=&quot;</span> + gender +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test41</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            Cat cat=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-number">123</span>);<br>            cat.gender=<span class="hljs-number">99</span>;<br>            System.out.println(cat);<br>            <span class="hljs-comment">//创建输出流</span><br>            ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;1.txt&quot;</span>));<br>            <span class="hljs-comment">//将对象序列化后写入文件</span><br>            oos.writeObject(cat);<br>            <span class="hljs-comment">//创建输入流</span><br>            ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;1.txt&quot;</span>));<br>            Object object=<span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//读取文件中的序列化对象信息</span><br>            <span class="hljs-comment">//在if语句中嵌套赋值语句</span><br>            <span class="hljs-keyword">if</span>((object=ois.readObject())!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//反序列化恢复对象</span><br>                Cat copyCat=(Cat)object;<br>                System.out.println(copyCat);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上述代码的输出是</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//序列化前的对象信息</span><br>Cat&#123;gender=<span class="hljs-number">99</span>, name=<span class="hljs-string">&#x27;小白&#x27;</span>, age=<span class="hljs-number">123</span>&#125;<br><span class="hljs-comment">//反序列化后恢复的对象信息</span><br>Cat&#123;gender=<span class="hljs-number">0</span>, name=<span class="hljs-string">&#x27;小白&#x27;</span>, age=<span class="hljs-number">123</span>&#125;<br></code></pre></td></tr></table></figure><p>注意这里恢复的对象信息中丢失了父类成员变量gender的值,变成了无参构造器自动初始化的值</p><blockquote><p>如果一个文件写入了多个序列化的对象, 反序列化时必须按顺序读取</p></blockquote><p>进行序列化时, 如果类中的成员变量是引用变量, 那么其引用的类也必须是可序列化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;1.txt&quot;</span>));<br>Person per=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">500</span>);<br>Teacher t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;唐僧&quot;</span>,per);<br>Teacher t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;菩提祖师&quot;</span>,per);<br>oos.writeObject(t1);<br>oos.writeObject(t2);<br>oos.writeObject(per);<br></code></pre></td></tr></table></figure><p>上面的代码只会产生一个”小白”的Person对象不会产生三个Person类型对象</p><p>Java采用一种特殊的序列化算法, 确保在其他对象中引用类型变量对应的对象不会产生重复</p><p>算法原则如下:</p><ol><li>所有保存到磁盘的对象都有一个对应的序列化编号</li><li>当对一个对象执行序列化时, 会先检查该对象已经被序列化过, 只有从未(在JVM的生命周期内)被序列化的对象才会执行序列化</li><li>如果是已经序列化过的对象, 将直接使用其对应的序列化编号, 而不会重新执行序列化</li></ol><blockquote><p>序列化编号机制</p></blockquote><p><img src="/2022/11/03/%E5%BA%8F%E5%88%97%E5%8C%96/image-20220521164041253.png" alt="image-20220521164041253"></p><blockquote><p>如果是重新序列化实质上将产生一个新的对象, 与java中的对象引用思想冲突</p></blockquote><p><img src="/2022/11/03/%E5%BA%8F%E5%88%97%E5%8C%96/image-20220521163302254.png" alt="image-20220521163302254"></p><p><strong>如果多次序列化同一个对象, 只有第一次序列化会被执行, 后面会直接返回该对象的序列化编号, 不会执行序列化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Cat cat=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>);<br><span class="hljs-comment">//第一次序列化将会正常执行</span><br>oss.writeObject(cat);<br><span class="hljs-comment">//更改该对象已经序列化</span><br>cat.name=<span class="hljs-string">&quot;小黑&quot;</span>;<br><span class="hljs-comment">//第二次序列化直接返回&quot;小白&quot;对应的序列化编号, 不会重复将对象转换成二进制流</span><br>oss.writeObject(cat);<br></code></pre></td></tr></table></figure><p>**由于java的序列化机制不允许重复序列化, 将导致</p><h1 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h1><p>PrintStream是一种输出流, 可以输出字节信息或字符信息</p><blockquote><p>输出字符信息的时候使用的是当前系统的编码器</p></blockquote><p>System.out.println就是用PrintStream作为系统输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PrintStream ps=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;2.txt&quot;</span>);<br>ps.println(<span class="hljs-string">&quot;123&quot;</span>);<br>ps.close();<br></code></pre></td></tr></table></figure><p>PrintWriter是字符输出流, 不能输出字节信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PrintWriter pw=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-string">&quot;22.txt&quot;</span>);<br>pw.println(<span class="hljs-string">&quot;1234&quot;</span>);<br>pw.close();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2022/11/03/Redis/"/>
    <url>/2022/11/03/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><strong>Redis</strong>是一种<strong>NoSql</strong>数据库</p><p>NoSql是非关系型数据库, 仅仅保存数据本身,不会保存数据间的关系</p><p>非关系型数据库是为了适应现代互联网服务的高并发 大数据场景而设计, 一般都将数据存储在内存中提高数据读写速度(需要一直通电, 易丢失), 后续再通过持久化将需要长久保存的数据</p><blockquote><p>一般NoSql保存的都是需要频繁使用(访问)的热点数据</p><p>持久化保存的是冷却的数据</p></blockquote><p>常见的NoSql数据库： redis  mongoDB memcache HBase</p><p>Redis是典型的NoSql数据库, 使用数据以键值的形式保存在内存上</p><blockquote><p>redis应用场景： 作为分布式系统的公共内存</p></blockquote><p>redis特点：</p><ol><li>单线程， 原子性操作。 保证在高并发场景下的事务性</li><li>基于内存的存储设计， 性能高</li><li>支持主从复制。 主服务器可以自动将数据同步到多个从服务器，需要进行读写分离(主服务器负责处理写入操作, 从服务器负责读取操作)</li><li>非阻塞IO模型， 多个网络连接可以复用同一个线程</li><li>支持持久化（AOF和RDB两种方式）， 使用写拷贝（copy on write）技术进行数据更新</li><li>key和value的大小最高可以到512M</li><li>数据结构为键值对， 操作简单</li><li>数据类型丰富</li></ol><p>redis缺点:</p><ol><li>主从同步会导致数据延迟</li><li>容量受内存大小限制, 一般需要搭配mysql使用才能支持大数据场景</li></ol><p>redis和Memcached对比</p><table><thead><tr><th>redis</th><th>Memcached</th></tr></thead><tbody><tr><td>支持复杂数据类型</td><td>不支持</td></tr><tr><td>支持主从同步</td><td>不支持</td></tr><tr><td>支持持久化, 数据更安全</td><td>不支持</td></tr></tbody></table><p>redis常用命令：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dbsize</td><td>返回当前数据库key的数量</td></tr><tr><td>info</td><td>返回当前redis服务器的状态</td></tr><tr><td>monitor</td><td>实时监听redis服务器收到的所有请求信息</td></tr><tr><td>shutdown</td><td>将数据持久化， 并关闭服务器</td></tr><tr><td>config get parameter</td><td>获取对应redis配置信息</td></tr><tr><td>set</td><td>存储键值对</td></tr><tr><td>get</td><td>通过键获取对应的值</td></tr><tr><td>根据键查询</td><td></td></tr><tr><td>ttl</td><td>查询过期时间</td></tr><tr><td>type</td><td>查询数据类型</td></tr><tr><td>exists</td><td>查询数据是否存在</td></tr><tr><td>strlen</td><td>查询值的长度</td></tr></tbody></table><h2 id="数据类型和数据结构"><a href="#数据类型和数据结构" class="headerlink" title="数据类型和数据结构"></a>数据类型和数据结构</h2><p>redis的五种常见数据类型：</p><ol><li><p>字符串： 字符串包括整数和浮点数， redis中的字符串为动态字符串， 支持修改， 并且通过预分配多余空间来减少重新分配内存空间的次数</p><p>注意redis和一般的数据库都不支持存储二进制数据， 一般会通过使用base64编码将二进制文件转换为对应的字符串再存储到redis中</p></li><li><p>字典(hash table)： 无序字典, 当字典的第一维数组位置碰撞时(冲突), 会将两个数组元素存储的第二维链表合并起来</p></li><li><p>list: list相当于java中的链表, 有序, 可重复, 根据元素进出顺序可以充当队列(FIFO)或栈(FILO)</p><blockquote><p>链表特性:修改(插入删除)操作快, 查找操作慢 </p></blockquote></li><li><p>set: set是字典(hashTable)的特殊实现, 与hashTable的区别:list只存储key, value都是null, 并且list新增数据时会进行去重</p></li><li><p>zset: zsetsorted set, 基于set实现的有序集合, 并且支持设置权重</p><blockquote><p>通过zset可以实现实时排行榜</p></blockquote></li></ol><p>数据类型示例</p><p><img src="/2022/11/03/Redis/image-20220726152044499.png" alt="image-20220726152044499"></p><p>redis字符串内存示例</p><p><img src="/2022/11/03/Redis/image-20220725163929037.png" alt="image-20220725163929037"></p><p> redis中的字符串为动态字符串</p><p>len表示实际存储的字符串长度，capacity表示当前字符串已经分配的内存空间</p><p>当字符串修改扩容时超过了capacity， 会先申请重新分配内存空间， 并且每次扩容最多扩容1M, 最大可以扩容到512M的容量</p><blockquote><p>超过1M的扩容需要申请多次扩容直到满足内存要求</p></blockquote><p>hash的存储结构是数组和链表组成的二维结构</p><p><img src="/2022/11/03/Redis/image-20220725173620467.png" alt="image-20220725173620467"></p><p>set的链表数据结构</p><p><img src="/2022/11/03/Redis/image-20220725175145776.png" alt="image-20220725175145776"></p><p>zset的链表数据结构</p><p><img src="/2022/11/03/Redis/image-20220725175203577.png" alt="image-20220725175203577"></p><p>redis存储键值时不需要指定数r据类型， redis服务器会自动识别</p><p>如果值可以被识别为十进制整数或浮点数， 那么可以在redis中对该值进行加减操</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>redis持久化的方式</p></blockquote><p>redis支持两种持久化方式：RDB AOF</p><p>RDB (Redis DataBase): 定时将内存中数据快照写入磁盘， 以二进制文件的形式压缩存储</p><p>AOF (Append Only File): 使用日志将服务器的增删查改操作记录到文本文件中</p><blockquote><p>redis应用场景</p></blockquote><p>redis应用场景:</p><ol><li>会话缓存 (session cache)</li><li>排行榜 rank</li><li>订阅发布系统 subscribe</li><li>热点数据缓存 </li><li>实时统计数据</li></ol><blockquote><p>常见的redis集群架构</p></blockquote><p><img src="/2022/11/03/Redis/image-20220726155405190.png" alt="image-20220726155405190"></p><blockquote><p>三台服务器组成的redis集群</p><p>一主两从</p></blockquote><p>主从</p><p>哨兵: (<strong>Sentinel</strong>)哨兵是redis提供的高可用方案, 用于处理redis主服务器宕机时选择一个slave切换为master</p><blockquote><p>哨兵是一个进程, 一般运行在主从服务器中, 不会单独运行在一台服务器上</p></blockquote><p>哨兵的作用:</p><ol><li>持续监控master slave的工作状态</li><li>当master宕机时通过选举机制切换master</li><li>通知其他的slave执行replicaof与新的master同步</li></ol><p><img src="/2022/11/03/Redis/image-20220726170906713.png" alt="image-20220726170906713"></p><p>哨兵工作步骤:</p><ol><li><p>哨兵集群只需要配置当前master的ip和端口, 不需要配置其他哨兵或者slave信息</p></li><li><p>哨兵与master建立通信, 并通过redis的订阅发布机制与其他的哨兵建立通信</p></li><li><p>哨兵通过发送info到master获取slave的列表, 与列表上每一个slave都建立连接, 进行持续监控</p></li></ol><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><strong>如何防止redis被黑：</strong></p><ol><li><p>设置好防火墙， 进行IP白名单管理， 或者只允许内网访问</p></li><li><p>禁用掉危险命令（config）， 一般的黑客攻击会利用config命令修改redis配置来进一步植入木马攻击系统</p><blockquote><p>rename-command FLUSHDB “”</p></blockquote></li><li><p>修改端口号， 将默认的6379改成其他的端口</p></li><li><p>使用非 root 用户启动 redis进程</p></li><li><p>redis配置密码</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis应用场景</title>
    <link href="/2022/11/03/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2022/11/03/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h1><p>**如何保证 redis 中的数据都是热点数据？ **</p><ol><li>redis设置数据过期时间</li><li>设置数据容量阈值，根据置换策略，淘汰溢出的数据。</li></ol><h2 id="Redis设置过期时间"><a href="#Redis设置过期时间" class="headerlink" title="Redis设置过期时间"></a>Redis设置过期时间</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>expire 键 ttl秒</td><td>设置生存时间</td></tr><tr><td>pexipre 键 ttl毫秒</td><td>设置生存时间</td></tr><tr><td>expireat 键 ttl秒</td><td>设置过期时间</td></tr><tr><td>pexpireat 键 ttl毫秒</td><td>设置过期时间</td></tr><tr><td>set 键 值</td><td>保存一个键值（值类型为字符串）</td></tr><tr><td>get 键</td><td>获取键的值</td></tr><tr><td>setnx 键值</td><td>当键不存在时保存键值</td></tr><tr><td>del 键</td><td>删除一个键</td></tr><tr><td>exists 键</td><td>检测键是否存在</td></tr><tr><td>ttl 键</td><td>检查键的生存时间</td></tr><tr><td>pttl 键</td><td>检查键的过期时间</td></tr><tr><td>type 键</td><td>检查键的类型</td></tr><tr><td></td><td></td></tr></tbody></table><p>Redis常用的数据类型：</p><table><thead><tr><th>数据类型</th><th>命令</th><th>特点</th></tr></thead><tbody><tr><td>String</td><td>set 键 值</td><td>基本数据类型 二进制安全 最大512MB</td></tr><tr><td>Set</td><td>sadd 键 值</td><td></td></tr><tr><td>Hash</td><td>hmset 键 值</td><td>常用于存储对象</td></tr><tr><td>List</td><td>lpush 键 值</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>2、Redis 有哪些适合的场景？<br>  <strong>1）会话缓存（Session Cache）</strong><br>最常用的一种使用 Redis 的情景是会话缓存（<a href="https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020">session</a> cache）。用 Redis 缓存会话比其他存储（如 Mem<br>cached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车<br>信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？<br>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为<br>人知的商业平台 Magento 也提供 Redis 的插件。 </p><p> <strong>2）全页缓存（FPC）</strong><br>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实<br>例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FP<br>C。<br>再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。<br>此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快<br>速度加载你曾浏览过的页面。 </p><p> <strong>3）队列</strong><br>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队<br>列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push&#x2F;pop<br>操作。<br>如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是<br>利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作<br>为 broker，你可以从这里去查看。 </p><p> <strong>4）排行榜&#x2F;计数器</strong><br>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted<br>Set）也<br>使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。<br>所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下<br>面一样执行即可：<br>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执<br>行：<br>ZRANGE user_scores 0 10 WITHSCORESAgora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可<br>以在这里看到。 </p><p> <strong>5）发布&#x2F;订阅</strong><br>最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常多。在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用 Redis 的发布&#x2F;订阅功搭建聊天系统。</p><p>Redis框架：</p><ol><li>Redisson：RLock分布式锁 WatchDog锁更新机制</li><li>RedisTemplate：</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis面试</title>
    <link href="/2022/11/03/Redis%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/11/03/Redis%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis面试"><a href="#Redis面试" class="headerlink" title="Redis面试"></a>Redis面试</h1><p>Redis优点(为什么这么快):</p><ol><li>数据存储在内存中, 读写速度非常快</li><li>数据结构简单, 操作速度快</li><li>单线程运行, 避免了多线程的锁竞争导致性能消耗</li><li>采用多路复用IO模型,效率高</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Review</title>
    <link href="/2022/11/03/Review/"/>
    <url>/2022/11/03/Review/</url>
    
    <content type="html"><![CDATA[<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>Code &#x2F;2022&#x2F;11&#x2F;03&#x2F;Review&#x2F; 代码审查: 是对项目中其他人提交的代码进行审查,</p><p>确保代码的可读性 可维护性 规范性</p><p>进行代码审查可以使个人:</p><ol><li>了解团队中其他人的工作</li><li>学习其他人的代码规范</li><li>纠正自己不好的代码规范</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Shiro身份验证</title>
    <link href="/2022/11/03/Shiro%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/11/03/Shiro%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Shiro身份验证"><a href="#Shiro身份验证" class="headerlink" title="Shiro身份验证"></a>Shiro身份验证</h1><p>用户设置密码 abc，如果数据库保存明文 abc，一旦泄露就等于泄露密码，黑客就可以登录。</p><p>所以服务器不存密码明文，存摘要的哈希值，比如存 md5(“abc”) 的结果 900150983cd24fb0d6963f7d28e17f72，但登录只接受明文输入，不接受哈希值。</p><p>黑客将服务器的数据库资料拖库下来时, 只能哈希值 900150983cd24fb0d6963f7d28e17f72，他们就要想办法知道哈希值对应哪个明文。于是他们就穷举出尽可能多字符串的哈希值，做成一个表，叫彩虹表。拿着表逐个去对，哈希值对上了就知道是哪个明文了。</p><p>为了防止彩虹表这种破解方式，于是就有了盐 salt，在摘要的时候加进去，比如 md5(“a 盐 1b 盐 2c 盐 3”)，这样一来摘要输入变长了，简单的彩虹表就不够用了，得制作足够大的彩虹表去对，而且就算你对出来了你还要知道哪部分是盐哪部分是真正的密码。</p><h2 id="MD5-加密存储用户密码"><a href="#MD5-加密存储用户密码" class="headerlink" title="MD5 加密存储用户密码"></a>MD5 加密存储用户密码</h2><p>当用户注册时, 前端将用户名和明文密码传递给后端</p><p>后端拿到明文密码后将密码用哈希函数转成md5值再存储到数据库中</p><p>当用户登陆时, 只需要按照相同的步骤将密码转为md5值再与数据库中存储的md5进行校验</p><p>就算黑客拿到了服务器的数据库数据,  也无法用md5值进行登陆, 一般也不能将md5值逆向转换为明文密码</p><p><strong>加盐</strong></p><p>虽然没有算法可以将md5值转换为明文, 但是可以通过穷举简单密码, 将密码和转换后的md5存储为彩虹表, 根据彩虹表可以在一定范围内破解简单密码的md5值</p><p>因此我们需要加盐</p><p>盐并非md5算法提供的功能, 而是我们将一段字符有规律地重复插入用户使用的明文密码中, 将拼接后的字符转成md5值存储</p><p>加盐实质上就是将用户的简单密码使用字符串拼接变得更复杂</p><blockquote><p>例如abc加盐123后会变成a123b123c123</p></blockquote><p>大多数 hash 算法都有两个效应: 雪崩效应和定长输出，雪崩即原始的微小改变会带来结果的巨大改变，从而抵御推测，定长输出导致原始数据 hash 后不可逆</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring MVC</title>
    <link href="/2022/11/03/Spring%20MVC/"/>
    <url>/2022/11/03/Spring%20MVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>SpringMVC是Spring内置的web开发框架</p><p>工作流程:</p><ol><li><p>客户端发送请求, DispatcherServlet(主控制器)接收请求</p></li><li><p>DispatcherServlet调用HandlerMapping处理请求</p></li><li><p>根据HandlerMapping存储的请求和Controller关系, 将请求转发给对应的Controller</p></li><li><p>Controller根据业务逻辑对请求进行处理(如果需要访问数据库会调用到DAO组件)</p></li><li><p>Controller处理完请求后返回ModelAndView对象</p><blockquote><p>ModelAndView相当于响应的原始信息, 在该对象中封装了模型数据和视图资源标识</p></blockquote></li><li><p>Servlet控制器调用ViewResolver组件, 将ModelAndView对象解析为响应信息返回给客户端</p></li></ol><p>Spring MVC要重点掌握的知识:</p><ol><li>SpringMVC的架构和各组成部分的作用</li><li>如何处理请求和响应</li><li>REST设计模式</li><li>SSM整合</li><li>拦截器</li></ol><p>REST是一种url的设计风格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--传统风格--&gt;</span><br>http://127.0.0.1/user/getById?id=1<br><span class="hljs-comment">&lt;!--REST风格--&gt;</span><br>http://127.0.0.1/user/1<br><span class="hljs-comment">&lt;!--传统风格--&gt;</span><br>http://127.0.0.1/user/saveUser<br><span class="hljs-comment">&lt;!--REST风格--&gt;</span><br>http://127.0.0.1/user<br></code></pre></td></tr></table></figure><p>REST风格需要将url进行简化, 隐藏资源行为(降低可读性)(防止通过url地址知道url背后的服务操作)</p><p>REST风格的url示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">get : http://localhost/users <br>查询全部用户信息<br>get : http://localhost/users/1<br>查询指定用户信息<br>post : http://localhost/users <br>添加用户信息<br>put : http://localhost/users <br>修改用户信息<br>delete : http://localhost/users/1 <br>删除指定用户信息<br></code></pre></td></tr></table></figure><h1 id="Spring-SSM注解"><a href="#Spring-SSM注解" class="headerlink" title="Spring SSM注解"></a>Spring SSM注解</h1><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Configuration</td><td>声明该类为配置类</td></tr><tr><td>@ComponentScan(“包或类路径”)</td><td>设置初始化容器时扫描的类的路径, 比如servlet类包, mapper类包, service(dao)类包</td></tr><tr><td>@PropertySource(“classpath:mapper&#x2F;*.xml”)</td><td>配置需要扫描的配置, 需要放置在Resource资源下</td></tr><tr><td>@Import({MybatisConfig.class})</td><td>加载指定的配置类写的注解</td></tr><tr><td>@Bean</td><td>将指定的类对象添加到IOC容器中管理</td></tr><tr><td>@MapperScanner(“com.lee.mapper”)</td><td>指定mybatis的mapper类的扫描路径</td></tr><tr><td>@RestController</td><td>等同于@Controller+@ResponseBody</td></tr><tr><td>@Controller</td><td>声明该类为servlet类, 可以绑定url接收处理请求</td></tr><tr><td>@RequestMapping(“url”)</td><td>将类或方法绑定对应url, 接收请求</td></tr><tr><td>自动序列化注解</td><td></td></tr><tr><td>@ResponseBody</td><td>使用插件将返回值序列化为对应的json字符串</td></tr><tr><td>@EnableWebMvc</td><td>启用自动序列化插件, 一般在spring配置类中添加该注解</td></tr><tr><td>异常处理类注解</td><td></td></tr><tr><td>@RestControllerAdvice</td><td>统一处理异常</td></tr><tr><td>@ExceptionHandler</td><td>处理指定的异常</td></tr></tbody></table><h2 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h2><p>SpringMVC 按层异常抛出处理流程</p><ol><li>controller层</li><li>service层</li><li>dao层</li></ol><blockquote><p>注意是自底向上的结构</p></blockquote><p>SpringMvc启动类</p><p>REST风格的要求:</p><p>(一)同一条url, 根据客户端发送http请求的方法不同而提供不同的功能:</p><ol><li>GET 查询</li><li>POST 添加</li><li>PUT 修改</li><li>DELETE 删除</li></ol><p>(二)servlet响应统一格式: code msg data</p><blockquote><p>code:状态码 msg:信息 data:数据</p></blockquote><p><strong>SSM项目</strong></p><p>SSM项目是指同时整合了三大框架(Spring+Spring MVC+MyBatis)的项目, 可以</p><p><strong>初始化容器</strong></p><ol><li>ServletContainer创建后加载springmvcConfig</li><li>根据@ComponentScan注解的路径扫描有@Controller注解的类, 并通过@RequestMapping将类或方法和url绑定</li><li>根据getServletMappings配置当前项目总的拦截方法</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/2022/11/03/Servlet/"/>
    <url>/2022/11/03/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet-url匹配"><a href="#Servlet-url匹配" class="headerlink" title="Servlet url匹配"></a>Servlet url匹配</h1><p>servlet的url匹配是有优先级的, 并且每个url只能被优先级最高的那个servlet匹配, 不会被多个servlet匹配</p><p>优先级顺序: 全路径匹配(精确匹配) &gt; 目录匹配 &gt; 扩展名匹配(后缀匹配) &gt; 缺省匹配(不属于前三种的所有匹配)</p><table><thead><tr><th>匹配类型</th><th>规则</th><th align="right">示例</th></tr></thead><tbody><tr><td>精确匹配</td><td>&#x2F;开头, 不能包含*</td><td align="right">&#x2F;login</td></tr><tr><td>路径匹配(目录匹配)</td><td>&#x2F;开头, &#x2F;*结尾</td><td align="right">&#x2F;path&#x2F;*</td></tr><tr><td>扩展名匹配</td><td>.*开头</td><td align="right">*.jsp</td></tr><tr><td>缺省匹配(default)</td><td>只能是&#x2F;</td><td align="right">&#x2F;</td></tr></tbody></table><blockquote><p>路径匹配中有特殊的情况: &#x2F;* 这种url-pattern会匹配当前网站下所有的路径</p></blockquote><h1 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h1><p>BeanUtrils是一个第三方类库, 提供了大量的static方法来调用</p><table><thead><tr><th>类方法</th><th>参数列表</th><th>作用</th></tr></thead><tbody><tr><td>getProperty</td><td>对象,”属性名”</td><td>获取对象对应属性的值</td></tr><tr><td>setProperty</td><td>对象,”属性名”,属性值</td><td>设置对象的</td></tr><tr><td>populate</td><td>对象,map</td><td>根据map的键值将数据填充到对象中</td></tr></tbody></table><p>BeanUtrils的方法利用了反射实现了对象的填充和读取功能, 可以使用相同的代码对不同的对象进行操作 </p><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><blockquote><p>HttpServlet类属于Servlet接口的实现类</p></blockquote><p>在HttpServlet的继承类中可以重写doPost和doGet方法, 对于浏览器的post请求和get请求</p><blockquote><p>一般开发中只需要实现doPost和doGet其中一个方法, 另一个方法直接调用复用代码</p></blockquote><p>两个方法的形参列表形同, 都包含HttpServletRequest req和HttpServletResponse resp</p><p>req对应浏览器发来的请求</p><p>resp对应服务器返回给浏览器的响应</p><h2 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h2><p>tomcat会将接收到的请求封装为一个请求对象(ServletRequest)</p><p><strong>HttpServletRequest</strong></p><p>HttpServletRequest是ServletRequest类的继承类, 用于封装http请求</p><p>http请求的数据()请求行, 请求头, 请求体)都在HttpServletRequest里面</p><p>HttpServletRequest的实例方法有</p><table><thead><tr><th>实例方法</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>setCharacterEncoding</td><td>“编码集”</td><td>设置解析请求的编码集, 可以解决中文乱码问题</td></tr><tr><td>getHeader</td><td>“字段”</td><td>通过字段获取请求头的值</td></tr><tr><td>getHeaderNames</td><td>空</td><td>返回所有的字段名</td></tr><tr><td>getParameter</td><td>参数名</td><td>通过参数名获取单个提交里的值</td></tr><tr><td>getParameterValue</td><td>参数名</td><td>可以获取多个提交的值</td></tr><tr><td>getParameterNames</td><td>空</td><td>获取所有的参数名</td></tr><tr><td>getParameterMap</td><td>空</td><td>将所有的参数名和对应的值封装在map里面返回, 键值</td></tr><tr><td>getRequestURI</td><td>空</td><td>返回请求的URI</td></tr><tr><td>getRequestURL</td><td>空</td><td>返回请求的URL</td></tr><tr><td>getContextPath</td><td></td><td></td></tr><tr><td>getMethod</td><td></td><td></td></tr><tr><td>getCookies</td><td></td><td></td></tr><tr><td>getSession</td><td></td><td></td></tr><tr><td>getRemoteAddr</td><td>空</td><td>返回发送请求的IP地址</td></tr><tr><td>getRemotePort</td><td>空</td><td>返回发送请求的端口</td></tr><tr><td>getContextPath</td><td>空</td><td>返回项目部署的路径</td></tr></tbody></table><p>HttpServletResponse</p><table><thead><tr><th>实例方法</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>getWriter</td><td>空</td><td>返回一个java.io.PrintWriter对象, 用于发送文本</td></tr><tr><td>getOutputStream</td><td>空</td><td>返回一个java.io.PrintWriter对象, 用于发送文本</td></tr><tr><td>addCookie</td><td>Cookie对象</td><td>为当前session的用户添加cookie</td></tr><tr><td>sendRedirect</td><td>location字符串</td><td>重定向</td></tr><tr><td>setContentType</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot</title>
    <link href="/2022/11/03/Spring%20Boot/"/>
    <url>/2022/11/03/Spring%20Boot/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>SpringBoot框架基于Spring4.0设计, 在Spring的基础上将配置进行简化, 实现了约定大于配置(Convention over configuration)的思想</p><p>约定大于配置: 由SpringBoot自动配置框架, 开发者仅需要提b供必要信息的思想, 该特性降低了开发的灵活性, 但是可以降低开发者的配置工作量, 并实现代码编译测试打包的自动化</p><p>SpringBoot通过Parent版本方案对依赖进行集成方案管理, 开发者只需要提供列出需要使用的依赖坐标(名称), 框架会根据parent方案的版本自动选择依赖的版本</p><blockquote><p>parent实现了整个项目依赖的版本统一管理</p></blockquote><p>SpringBoot可以集成大量的框架, 并对框架提供了开箱即用(OutOfBox)(自动化配置)功能</p><p>SpringBoot特点:</p><ol><li>有内置的Servlet容器可以独立启动, 不依赖于外部Tomcat容器, 启动速度快</li><li>提供各种starters(parent版本方法)来简化Maven依赖配置</li><li>对大量框架实现了自动化配置, 简化了程序员的工作</li><li>提供了大量的预定义特性, 可以从外部监控程序的特性(监控, 效率)</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2022/11/03/Spring/"/>
    <url>/2022/11/03/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring是一款JavaEE架构级的开源框架, Spring框架通过IoC和AOP(反向控制和面向切面)两项技术将各种框架和资源低耦合的集成到一个项目中</p><p>Spring是轻量级框架</p><blockquote><p>轻量级框架是指其运行不依赖于特定的容器</p><p>重量级框架运行必须依赖特定的容器</p></blockquote><p>使用Spring最重要的原因: 通过Spring容器统一管理项目中创建的对象, 通过Spring容器统一管理业务中的调用关系, 从而降低业务代码间的耦合度, 不再需要手动在业务代码中创建其他业务的对象</p><blockquote><p>实现高内聚, 低耦合</p></blockquote><p>Spring特点:</p><ol><li>轻量级: 大小和系统开支低, Spring框架开发的项目不依赖于特点容器, 不需要引入特定API(非侵入式)</li><li>IOC(反向控制): 反向控制实现了项目中各种组件的低耦合集成</li><li>AOP(面向切面编程): AOP与java的OOP(面向对象编程)不同, AOP可以将业务流程分为多个切片, 对每个切片进行独立开发</li><li>容器化: Spring容器可以管理项目的生命周期和配置</li></ol><blockquote><p>如果一个分层架构的项目中, 上层调用下层时直接创建下层的实例, 会造成上下层耦合性高的问题</p><p>使用Spring框架可以将代码分为不同的模块, 将代码的关联用配置说明, 从而实现多层代码间的解耦</p></blockquote><p><strong>IOC</strong></p><p>IOC反向控制是一种编程思想, 指将程序中的对象由传统的手动创建管理转换为用容器进行自动化管理</p><p>Spring容器的作用: 1. 管理对象的创建和赋值 2.管理依赖</p><p>在Spring中IOC通过DI(依赖注入, Dependecy Injection)来实现</p><p>依赖: 当A类的代码中创建了B类的对象, 并且调用了B类的方法来实现功能, 则被称为A依赖于B</p><p>依赖注入: 在程序运行时如果需要调用外部类对象, 不需要在代码中手动创建, 可以通过依赖注入直接从外部容器引入对应的对象</p><p>Spring的依赖注入具有通用性(调用者和被调用者可以是任意类), 并且支持依赖关系管理</p><p>Spring容器也被称为工厂, 在容器中的对象被称为Bean, Spring容器使用依赖注入来管理Bean对象间的依赖关系, 通过IOC实现对象间的解耦</p><blockquote><p>项目中所有的类都在容器中管理, Bean类间的依赖(相互调用)都通过依赖注入管理</p></blockquote><p>Spring架构图</p><p><img src="/2022/11/03/Spring/image-20220707113414148.png" alt="image-20220707113414148"></p><p>Spring包含7个核心模块:</p><ol><li>Core: 核心容器, 提供了Spring框架的基础功能, 该模块包括了BeanFactory类, 这个类是Spring框架系统的核心</li><li><strong>Application Context</strong>: Spring的重要模块之一, 通过配置文件提供信息在Spring框架中实现Bean资源共享. 提供了大量的企业级服务: JNDI, EJB, 电子邮件</li><li>AOP: 通过动态代理技术(Dynamic Proxy)实现了面向切面的编程支持, 可以将一个业务按照流程分为多个切面, 每个切面相互独立, 多个切面组装成一个完整的业务流程</li><li>ORM: Spring对主流的ORM框架都提供了模板, 可以使用Spring一致的编程风格进行编程</li><li>DAO: 提供数据库支持, 将持久层独立为一个模块, 将JDBC封装为API提供调用</li><li>Web: 在context模块的基础上进一步为Web程序提供了上下文, 并且可以对内置或外部的Web框架进行整合</li><li>MVC(Spring MVC): Spring内置的Web框架, 通过MVC思想实现, 支持多角色划分和多视图技术</li></ol><blockquote><p>AOP的动态代理模式有两种: </p><ol><li>ProxyFactoryBean(代理工厂对象): 通过引入中间层来实现任何形式的AOP</li><li>TransactionProxyFactoryBean(事务代理工厂对象): 通常用于数据库编程, 对数据库的事务进行管理</li></ol></blockquote><p>AOP可以作为OOP的一种补充, 减少重复代码, 更容易实现项目工程化</p><p>AOP架构示例</p><p><img src="/2022/11/03/Spring/image-20220708152405296.png" alt="image-20220708152405296"></p><p><strong>MVC</strong></p><p>MVC三层架构:</p><ol><li>Model: 数据模型, 包括了数据以及业务</li><li>View: 用户界面展示</li><li>Controller: 充当View和Model的双向调度员</li></ol><blockquote><p>与vue的MVVM架构类似, ViewModel相当于Controller的角色</p></blockquote><p><strong>创建一个简单的Spring项目</strong></p><ol><li><p>导入Spring的依赖包</p></li><li><p>定义实体类, 需要定义无参构造器和setXX方法</p></li><li><p>创建Spring配置文件(推荐路径为resources目录下的applicationContext.xml)</p><blockquote><p>配置文件中需要引入约束文件, 约束文件的后缀为.xsd</p></blockquote></li><li><p>在配置文件中的Bean对象中绑定对应的实体类</p></li><li><p>在其他类中调用Bean对象</p></li></ol><p>配置文件Bean对象绑定实体类实例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--id属性是Bean对象的id, class是绑定的对应实体类--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.wn.bean.Student&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>获取Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过配置文件获取spring容器</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-comment">//通过context容器获取bean对象</span><br>Student stu=(Student) applicationContext.getBean(<span class="hljs-string">&quot;stu&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>ApplicationContext接口</strong></p><p>ApplicationContext接口是一个容器, 有两个实现类</p><blockquote><p>ClassPathXmlApplicationContext和FileSystemXmlApplication</p></blockquote><p>一般通过ClassPathXmlApplicationContext的构造器来加载Spring配置文件创建对应的spring容器</p><p>容器对象初始化时, 会将容器中的所有Bean对象都进行装配, 代码中使用Bean对象时会直接从内存中调用. 这样的设计提高了代码的执行效率, 但是由于对象全部保存在容器中, 会导致内存占用较高</p><blockquote><p>spring容器创建Bean对象时会默认调用无参构造器, 要求对应的实体类必须提供无参构造器</p></blockquote><p><strong>注入</strong></p><p>Spring容器对bean对象进行初始化的过程被称为注入</p><p>注入分为set注入和构造注入</p><p>1.set注入通过调用实例的setter方法进行赋值, 由于简单直观所以是Spring依赖注入中常用的方法</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><strong>常用的java代理模式有5种</strong></p><ol><li>静态代理: 手动创建代理类, 在编译</li><li>基于JDK: 通过JDK提供的Proxy.newProxyInstance方法动态生成代理类</li><li>基于CGlib: </li><li>基于Aspectj:</li><li>基于instrumentation:</li></ol><blockquote><p>其中2到5都是动态代理模式</p></blockquote><p>Spring一般使用的是2或3代理模式: 基于JDK或CGlib</p><p>动态代理和静态代理的区别:</p><p>静态代理需要在程序运行前手动创建代理类, 并生成class文件</p><p>动态代理是在程序运行中创建的代理模型</p><p>jdk动态代理实现步骤</p><ol><li><p>创建被代理类, 被代理的类需要有实现的自定义接口</p></li><li><p>创建代理对象获取类</p><p>代理对象获取类通过调用Proxy.newProxyInstance方法, 获取真正的代理对象</p><blockquote><p>Proxy.newProxyInstance方法需要传入三个参数, 类加载器, 代理类对象的接口参数列表</p></blockquote></li></ol><p>jdk动态代理缺点:</p><ol><li>由于jdk动态代理是基于接口的代理, 所以代理对象必须有实现的接口</li><li>动态代理的基本单位是类</li></ol><blockquote><p>创建代理获取类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetProxy</span> &#123;<br>    UserInterface userInterface;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserInterface</span><span class="hljs-params">(UserInterface userInterface)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userInterface=userInterface;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getJdkProxy</span><span class="hljs-params">()</span>&#123;<br>        Object proxy= Proxy.newProxyInstance(<br>                userInterface.getClass().getClassLoader(),<br>                userInterface.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-comment">//method是被代理的方法</span><br>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                        Object result=<span class="hljs-literal">null</span>;<br>                        <span class="hljs-comment">//注入代码到方法中</span><br>                        System.out.println(<span class="hljs-string">&quot;注入代码&quot;</span>);<br>                        result=method.invoke(userInterface);<br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;<br>        );<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过代理获取类对象调用注入后的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        UserInterface userInterface=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        GetProxy getProxy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">GetProxy</span>();<br>        getProxy.setUserInterface(userInterface);<br>        UserInterface proxy=(UserInterface) getProxy.getJdkProxy();<br>        proxy.hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>动态代理运行流程图</p></blockquote><p><img src="/2022/11/03/Spring/image-20220711142014002.png" alt="image-20220711142014002"></p><p>面试题:</p><p>AOP术语, 需要掌握</p><ol><li>Aspect 切面</li><li>JoinPoint 连接点</li><li>Pointcut 切入点</li><li>Target 目标对象</li><li>Advice 通知&#x2F;增强</li><li>Weaving 植入</li></ol><h1 id="Spring测试"><a href="#Spring测试" class="headerlink" title="Spring测试"></a>Spring测试</h1><p>Spring测试和传统测试的区别</p><blockquote><p>传统测试是运行Juint框架然后在测试程序中运行Spring容器</p><p>每个测试都会重新启动Spring容器, 开销较大</p></blockquote><p><img src="/2022/11/03/Spring/image-20220708092852725.png" alt="image-20220708092852725"></p><blockquote><p>Spring测试是在Spring容器中运行Junit框架 测试程序</p></blockquote><p><img src="/2022/11/03/Spring/image-20220708093039733.png" alt="image-20220708093039733"></p><p><strong>创建spring测试的步骤</strong></p><ol><li>添加spring-test依赖</li><li>添加@RunWith注解</li><li>添加@ContextConfigration注解</li></ol><blockquote><p>测试类示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWidth(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    ApplicationContext context;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSpring</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//获取context容器</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-comment">//测试代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架底层</title>
    <link href="/2022/11/03/Spring%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82/"/>
    <url>/2022/11/03/Spring%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring框架底层"><a href="#Spring框架底层" class="headerlink" title="Spring框架底层"></a>Spring框架底层</h1><p><strong>Spring 监听器作用</strong></p><p>创建IOC容器, 并将容器存放到application域(ServletContext)中 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取ioc容器</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> WebApplicationContextUtils.getWebApplicationContext(application);<br></code></pre></td></tr></table></figure><p>ServletContextListener监听器接口:监听ServletContext创建和销毁</p><ol><li>服务器启动时(ServletContext创建), 创建IOC容器</li><li>服务器停止或项目卸载时(ServletContext销毁), 销毁IOC容器</li></ol><p>在源码中IOC容器对象是XmlWebApplicationContext类型</p><p>Spring初始化在refresh()中进行</p><blockquote><p>关键方法</p></blockquote><p>Spring常用的web监听器有6种:</p><ol><li><p>ServletContextListener (最重要)</p><p>监听ServletContext对象的创建和销毁</p><p>应用场景:在系统启动时</p><ol><li>执行初始化任务</li><li>加载数据常量缓存, 提供效率</li><li>获取项目context路径, 提供给页面使用</li><li>启动计数器, 计算在线用户数</li></ol></li><li><p>ServletContextAttributeListener </p><p>监听ServletContext对象的属性变化: 增删改</p></li><li><p>HttpSessionListener </p><p>监听HttpSession对象的创建销毁</p></li><li><p>HttpSessionAttributeListener</p><p>监听HttpSession对象的属性变化: 增删改</p></li><li><p>ServletRequestListener </p><p>监听HttpServletRequest对象的创建销毁</p></li><li><p>ServletRequestAttributeListener </p><p>监听HttpServletRequest对象的属性变化: 增删改</p></li></ol><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Spring中的过滤器需要实现Filter接口, 并实现该接口的三个方法:</p><ol><li>init(FilterConfig filterConfig)  服务器启动时执行<ol><li>读取web.xml中设置的init</li></ol></li><li>doFilter  根据匹配规则, 每匹配到一次执行一次</li><li>destory  服务器关闭时执行</li></ol><p>CharacterEncodingFilter(字符编码过滤器)解决乱码问题只能解决post方法, 不能处理get请求乱码(因为get请求的参数已经被硬编码在url里以明文方式传输)</p><p>Get请求乱码解决方法: 在Tomcat的server.xml配置文件中设置编码</p><blockquote><p>&lt;Connector URIEncoding&#x3D;”UTF-8” /&gt;</p></blockquote><p><img src="/2022/11/03/Spring%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82/image-20220822140037819.png" alt="image-20220822140037819"></p><blockquote><p>其中forceEncoding设置响应的编码</p><p>encoding设置解析请求的编码</p></blockquote><p>过滤器默认只在请求传入和响应返回时进行过滤, 不对服务器组件间转发请求过滤, </p><p>可以配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">#处理转发<br><span class="hljs-tag">&lt;<span class="hljs-name">dispatcher</span>&gt;</span>FORWARD<span class="hljs-tag">&lt;/<span class="hljs-name">dispatcher</span>&gt;</span><br>#处理请求<br><span class="hljs-tag">&lt;<span class="hljs-name">dispatcher</span>&gt;</span>REQUEST<span class="hljs-tag">&lt;/<span class="hljs-name">dispatcher</span>&gt;</span><br></code></pre></td></tr></table></figure><p>过滤器执行优先级:</p><ol><li>过滤器按照匹配规则处理匹配到的请求</li><li>如果多个过滤器都匹配到一个请求, <ol><li>根据匹配的精确度, 先后执行 (精确匹配, 扩展匹配, 模糊匹配)</li><li>如果两个过滤器都是相同的过滤模式, 按照&lt;filter-mapping&gt;在配置文件中顺序来执行过滤器(过滤器都会执行, 但是要按照优先级顺序依次执行)</li></ol></li></ol><p>过滤器迭代执行: doFilter中放行chain.doFilter(req,resp);</p><p>HiddenHttpMethodFilter: 支持RESTful风格, 将post请求转换为put或delete请求</p><blockquote><p>通过读取post请求中的隐含参数: “_method”</p></blockquote><p>pom.xml</p><p>在maven中, 每个依赖都会有一个唯一的坐标, 坐标包 含多个元素: groupId artifactId version packaging classifier</p><p>通过parent标签可以从父pom文件中引入对应的坐标版本, 子pom只需要提供坐标的其他元素, 并自动继承父pom中的version元素, 解决了依赖版本冲突问题</p><p>packaging标签(打包)有三种属性:</p><ol><li>jar  普通java项目</li><li>war web项目</li><li>pom 聚合项目</li></ol><p>depencyManagement:</p><p>​仅提供依赖版本坐标给子项目继承, 子项目需要手动添加对应的依赖</p><p>servlet配置servlet</p><p>servlet默认在第一次被访问时才创建对象， 通过配置&lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;标签可以使指定的servlet在服务器启动时就被创建对象</p><blockquote><p>值越大创建顺序的优先级越高</p></blockquote><p><strong>数据库解决乱码问题</strong>:</p><p>配置文件中设置</p><p>default-character-set&#x3D;utf8</p><p>character-set-server&#x3D;utf8</p><p>jdbc连接数据库的url加上参数</p><blockquote><p>useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</p></blockquote><p>url中的参数配置的是mysql的中间转换编码</p><blockquote><p>服务器与数据库进行通信时, 数据都需要转换为中间转换编码再传输, 因此服务器的编码可以与数据库不同, 并且不会有乱码问题</p></blockquote><p><img src="/2022/11/03/Spring%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82/image-20220822150057663.png" alt="image-20220822150057663"></p><p>Java中将字符串转换为指定编码</p><ol><li>byte[] getBytes(String charsetName)</li><li>String(byte bytes[], String charsetName)</li></ol><p>classpath*:mapper&#x2F;*Mapper.xml</p><blockquote><p>两个*的含义： 第一个*表示在多个jar包的类路径下进行匹配</p><p>第二个*表示模糊匹配文件名</p></blockquote><p>classpath:mapper&#x2F;*Mapper.xml</p><blockquote><p>只在当前项目的类路径下进行匹配</p></blockquote><p>Spring</p><ol><li><p>IOC: 声明bean对象, 管理对象生命周期</p></li><li><p>AOP: 依赖注入过程中, 使用代理对象使框架可以注入事务管理方法</p><blockquote><p>doBegin doCommit doRollback</p></blockquote></li></ol><p>JDK1.5, 类实现接口不是重写方法, 不允许用Override注释</p><p>JDK1.6以上, 类实现接口是重写方法, 允许用Override注释</p><p>Servlet匹配规则：</p><ol><li>精确匹配: &#x2F;user&#x2F;save</li><li>扩展匹配: *html</li><li>路径匹配（模糊匹配）: &#x2F;*</li><li>默认匹配: &#x2F;</li></ol><blockquote><p>&#x2F;user&#x2F;*html 是非法的匹配规则</p></blockquote><p>父容器： Spring容器： 管理Dao Service层</p><p>子容器： Spring MVC容器： 负责管理Controller</p><blockquote><p>use-default-filters&#x3D;”false”</p><p>不配置该属性会导致事务出问题</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Super关键字</title>
    <link href="/2022/11/03/Super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/11/03/Super%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><p>关键字用于在子类中调用被覆盖的父类方法</p><blockquote><p>super关键字不能出现在static修饰的方法中</p><p>但是可以调用被static修饰的方法</p></blockquote><p>super关键字也可以用于在子类中调用被隐藏的父类变量</p><blockquote><p>当子类中定义了与父类重名的变量时会导致父类变量被隐藏, 子类可以通过super关键字调用被隐藏的父类变量</p></blockquote><p>程序查找变量的顺序(优先级)为:</p><ol><li>找该方法中的局部变量</li><li>找该类中的成员变量</li><li>找父类中的成员变量</li><li>按结构遍历所有间接父类的成员变量直至最终的java.lang.Object</li><li>最终仍无法找到变量将出现编译错误</li></ol><p>找到同名变量后不会再执行后续步骤</p><p><img src="/super%E5%85%B3%E9%94%AE%E5%AD%97/image-20220505172804617.png" alt="image-20220505172804617"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Son s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><span class="hljs-comment">//int num=s.tag;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>((Parent)s).tag<br></code></pre></td></tr></table></figure><p>上述代码显示了在创建子类对象后, 用(Parent)来调用父类中被隐藏的变量</p><p><strong>子类可以用super关键字来调用父类的构造器</strong></p><blockquote><p>使用this或super关键字调用构造器必须出现在构造器执行体第一行, 因此不能同时出现</p></blockquote><p><strong>子类构造器一定会调用父类构造器一次</strong></p><p>三种情况:</p><ol><li>用super关键字调用父类构造器</li><li>用this关键字调用本类中另一个构造器, 另一个构造器调用父类构造器</li><li>以上两种情况都没有发生时, 系统默认调用父类无参数构造器</li></ol><p><strong>创建一个对象时, 一定是从对应类所在的继承树最顶层类的构造器开始依次向下执行, 因此最开始一定会执行java.lang.Object类的构造体, 最后才会执行本类的构造器</strong></p><p><strong>this()和super()都只能放在构造器方法体的第一行</strong></p><blockquote><p>所以this()和super()不能同时存在于同一个构造器里</p></blockquote><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>final关键字可用于修饰类 变量 方法</p><p>当变量用final修饰时, 该变量一旦被赋予了初始值, 则不能再被重新赋值</p><p>成员变量被final修饰时, 该变量不会被系统自动初始化赋值, 必须在特定位置进行显式指定初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num1=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//类变量可以在声明时赋值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num2;<br>    <span class="hljs-keyword">static</span>&#123;<br>        num2=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//类变量可以在静态初始化块赋值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num5=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//实例变量可以在声明时赋值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num3;<br>    &#123;<br>        num3=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//实例变量可以在非静态初始化块赋值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num4;<br>    TestClass()&#123;<br>        num4=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//实例变量还可以在构造器中进行初始化赋值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码展示了final类变量的两个赋值地点, final实例变量的三个赋值地点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num5;<br>    &#123;<br><span class="hljs-comment">//    System.out.println(num5);</span><br>        test();<br>        num5=<span class="hljs-number">6</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(num5);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>();<br>        <span class="hljs-comment">//将输出0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码显示了final成员变量可以在初始化被方法访问, 并且输出0, 这是Java的设计缺陷</p><p><strong>final局部变量</strong></p><p>final局部变量只能进行一次赋值</p><p>final局部变量作为形参时, 会在值传递时被系统赋值, 不能再次赋值</p><p><strong>final基本类型变量和final引用变量的区别</strong></p><p>final基本类型变量只能进行一次赋值</p><p>final修饰引用变量时, 该引用变量所指向的对象地址无法再次改变, 也就是说无法重新指向其他的对象. </p><p>但是注意引用变量指向的对象本身是不受final修饰符影响, 可以正常修改</p><p>当一个变量满足三个条件时, 其相当于一个直接量, 成为宏变量</p><ol><li>被final修饰</li><li>声明时指定了初始值</li><li>初始值在编译时就被确定</li></ol><p>宏变量在代码中出现的地方会被编译器直接替换成对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test37</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> String book1=<span class="hljs-string">&quot;1&quot;</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">final</span> String book2=<span class="hljs-string">&quot;1&quot;</span>+String.valueOf(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">final</span> String book3=<span class="hljs-string">&quot;11&quot;</span>;<br>        String book5=<span class="hljs-string">&quot;1&quot;</span>+<span class="hljs-number">1</span>;<br>        System.out.println(book1==book2);<br>        <span class="hljs-comment">//输出false, 因为宏变量是在常量池中</span><br>        System.out.println(book1==book3);<br>        <span class="hljs-comment">//输出ture, 因为两个都是宏变量</span><br>        System.out.println(book1==book5);<br>        <span class="hljs-comment">//也是true, 代表不需要final修饰也是可以在常量池中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>final方法</strong></p><p>当父类中的方法用final修饰时, 子类不能重写该方法</p><p>与private的隐藏不同, final修饰的方法如果被子类重写将造成编译错误</p><p>但是如果方法同时被final 和 private修饰时, 方法对于子类来说将是隐藏状态, 不再是方法重写而是定义了新的方法, 可以正常运行</p><p>final不会影响方法重载</p><p><strong>final类</strong></p><p>final修饰的类将不可被继承</p><p>用final修饰符修饰的类无法被其他类继承</p><blockquote><p>也可以通过用private修饰类中所有的构造器, 保证无法被继承</p></blockquote><p><strong>final关键字类似于C++中的const, 被final修饰符修饰的变量 方法 类 将不允许再发生修改</strong></p><p>通过final关键字可以实现不可变类, 使系统安全性加强</p><blockquote><p>this的常量范围包括super的常量</p></blockquote><p><img src="/super%E5%85%B3%E9%94%AE%E5%AD%97/image-20220510121429395.png" alt="image-20220510121429395"></p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>为什么需要设计抽象类：因为多态实现的父类类型 引用变量虽然是指向子类对象， 但是无法通过该引用变量调用父类中没有， 但是子类中有的方法。 抽象类可以设计出无方法体， 仅有方法名的类模板可以解决该方法</p><p>抽象类提供了子类的通用方法，并将方法执行体留给子类实现 </p><p>抽象类是模板模式的一种实现</p><p>抽象方法和抽象类必须使用abstract修饰</p><p>一个类中含有抽象方法, 则该类必须为抽象类</p><p>但是用abstract修饰的抽象类可以不含抽象方法</p><p><strong>抽象类不能实例化，只能被子类继承</strong></p><p>抽象方法和抽象类的规则:</p><ol><li><p>抽象方法和抽象类必须使用abstract修饰, 抽象方法不能有方法体(具体代码块)</p></li><li><p>抽象类不能被实例化, 意味着它的构造器无法被new 关键字调用来创建实例</p></li><li><p>抽象类可以包含普通类中的五种成分: 成员变量 方法 构造器 初始化块 内部类(接口, 枚举)</p><blockquote><p>抽象类的构造器不能创建实例, 但是可以被子类调用(在子类创建实例时, 会按照继承树的顺序调用父类和间接父类中的构造器和初始化块)</p></blockquote></li><li><p><strong>含有抽象方法的类必须是抽象类或者接口,不能是普通类</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>abstract和static不能修饰同一个方法， 但是可以修饰同一个内部类</p><p>abstract和private也不能修饰同一个方法</p></blockquote><h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><p>接口和抽象类的相同特征:</p><ol><li>都不能被实例化, 只能被实现或继承</li><li>都可以包含抽象方法, 普通类不能含有抽象方法, 必须将继承的抽象方法实现</li></ol><p>接口和抽象类的设计目的差别巨大:</p><ol><li>接口体现规范标准, 接口的改变将可能导致实现该接口的类都需要重写</li><li>抽象类体现模板式设计, 抽象类只是一个中间产品, 需要进一步完善实现</li></ol><p>接口和抽象类的用法有差异:</p><ol><li><p>抽象类可以有普通方法(包含方法体), 但是接口不能有</p></li><li><p>接口只能有static final变量 (类常量), 抽象类可以定义普通成员变量</p></li><li><p>接口不能有构造器和初始化块, 抽象类可以有构造器和初始化块 </p><blockquote><p>抽象类中的构造器和初始化块是提供给子类调用的</p></blockquote></li><li><p>普通类继承抽象类为单继承, 但是可以实现implement多个接口(模拟多继承)</p></li></ol><blockquote><p>抽象方法不能被static修饰</p></blockquote><p>vehicle: 车辆, 泛指陆地上的一切运输工具</p><p><strong>默认方法的default是作为关键字使用, 和权限访问修饰符中的默认(default)权限不一样</strong></p><blockquote><p>default不能作为访问修饰符使用</p></blockquote><p>抽象方法不能有方法体</p><p>抽象类不能创建实例, 只能被继承</p><p>接口特点:</p><ol><li>接口不能被实例化(抽象类特点)</li><li>接口中的方法默认被public abstract修饰</li><li>非抽象类implements接口时,必须实现接口中的所有抽象方法</li><li>一个接口可以继承多个接口(模拟多继承)</li><li>一个类可以实现多个接口</li></ol><p>接口属于类的一种, 所以接口是引用数据类型</p><p>在Java中除了8种数据类型之外的类型都是引用数据类型</p><p>接口的成员有: 抽象方法 静态常量(abstract static)</p><p>jdk1.8中新增的 default默认方法和static静态方法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Switch</title>
    <link href="/2022/11/03/Switch/"/>
    <url>/2022/11/03/Switch/</url>
    
    <content type="html"><![CDATA[<h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><p>switch可以用于匹配值的条件语句</p><p>注意 switch的控制表达式中(匹配值)</p><p>只能用四种整数类型进行匹配(byte char short  int )</p><p>在Java7中还增加了对枚举类型和java.lang.String的支持</p><blockquote><p>注意StringBuffer StringBuilder boolean类型是不支持的</p></blockquote><p>case语句必须在最后加上break语句来确保可以正常跳出</p><p>switch语句更适合处理固定值的匹配</p><p>if语句更适合对范围进行判断</p><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>for循环语句可以有4个部分</p><p>初始化语句(init_statement): 在整个循环开始前执行的语句, 仅执行一次</p><p>循环条件(test_expression): 应当是一个boolean表达式, 决定循环是否结束</p><p>循环体(body_statement): 一个代码块, 作为循环的执行主体在每次循环中都会执行</p><p>迭代语句(iteration_statement): 执行在循环体结束后, 在循环条件判断前</p><p>各语句的执行顺序:</p><p>循环执行:</p><ol><li><p>初始化语句(循环开始前执行)</p></li><li><p>条件语句判断</p><p><strong>如果不符合条件</strong>: 直接结束循环</p><p><strong>符合条件</strong>:第三步</p></li><li><p>执行循环体</p></li><li><p>执行迭代语句</p></li><li><p>返回第二步继续</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(;;)&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上例代码中将for循环语句的四个部分省略不写, 也是符合语法的代码, 但是它本身是个死循环, 会导致程序无法退出结束</p></blockquote><p><strong>尽量避免在循环体中对循环条件中的变量进行修改</strong></p><p>作为goto的替代, 在Java中可以用continue break (return)关键字来控制循环结构</p><p>break: 默认跳出当前所在的循环</p><p>continue: 直接进入迭代语句开始新的一轮循环,</p><p><strong>注意使用return关键字会导致整个方法的结束</strong></p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">flag:<br></code></pre></td></tr></table></figure><p>上例代码中定义了一个标识符为flag的标签</p><p>标签可以接在continue和break关键字的后面</p><blockquote><p>for循环和while循环都是先验循环</p><p>代表他们先验证条件语句再执行循环体</p></blockquote><p>do while语句是后验循环, 先执行一遍循环体, 再验证</p><blockquote><p>while和for循环的区别</p><p>for循环用于已知循环次数的情形</p><p>while循环更适合用于未知循环次数, 但是知道退出条件的情况</p></blockquote><blockquote><p>建议循环的嵌套不要超过三层</p></blockquote><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的特点:</p><ol><li>数组必须在声明的时候确认类型, 并且存入数组的元素都必须是同一类型</li><li>数组的空间结构是连续, 有序的, 可以通过索引去访问数组内的元素</li><li>数组的长度是固定的, 在初始化时就确定好, 不发生改变</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2022/11/03/Swagger/"/>
    <url>/2022/11/03/Swagger/</url>
    
    <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><blockquote><p>使用maven打包SpringBoot程序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mvn <span class="hljs-keyword">package</span><br></code></pre></td></tr></table></figure><p>打包会生成jar文件, 可以直接被java解释器运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#运行打包的jar程序</span><br>java -jar 工程.jar<br><span class="hljs-comment">#使用命令行临时参数启动程序</span><br>java -jar 工程.jar --server.port=80<br><span class="hljs-comment">#命令行的临时参数相当于main函数中的形参String[] args</span><br></code></pre></td></tr></table></figure><blockquote><p>注意命令行临时参数优先级比程序的配置文件中的参数优先级高, 优先级高的参数会覆盖低优先级的参数</p></blockquote><p>swagger是一个用于自动生成web api文档的框架</p><p>会生成url 请求内容和响应内容的示例</p><p>注解</p><table><thead><tr><th>注解</th><th>作用</th><th>位置</th></tr></thead><tbody><tr><td>@Api(“解释类的作用”)</td><td></td><td>需要生成文档的工具类</td></tr><tr><td>@EnableSwagger2</td><td></td><td>配置类</td></tr><tr><td>@ApiOperation(Value&#x3D;”all” note&#x3D;””)</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat</title>
    <link href="/2022/11/03/Tomcat/"/>
    <url>/2022/11/03/Tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>tomcat是开源的java web服务器, 实现了Servlet JSP Java WebScoket等web技术</p><p>Tomcat目录解析:</p><table><thead><tr><th>目录</th><th>作用</th></tr></thead><tbody><tr><td>lib</td><td>存放java的jar包</td></tr><tr><td>bin</td><td>二进制可执行文件</td></tr><tr><td>conf</td><td>存放配置</td></tr><tr><td>logs</td><td>存放日志</td></tr><tr><td>webapps</td><td>存放所有部署的web项目</td></tr></tbody></table><p>当前常用的Tomcat版本为8.0对应Servlet3.1</p><p>tomcat配置server.xml解决乱码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;--!解决乱码--&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Connector</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当web程序部署到tomcat时, web文件夹会作为项目的根目录, src下面的资源会被编译为字节码后放到web-INF的class目录下</p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>servlet和tomcat处理用户请求的步骤</p><ol start="0"><li><p>浏览器对指定的url发送请求(post,get等)到特定的服务器</p></li><li><p>服务器(tomcat)接收请求并解析</p></li><li><p>服务器(tomcat)根据uri将请求转发给对应的servlet</p><blockquote><p>如果对应的servlet对象还不存在将创建servlet对象, 运行的servlet对象都将由tomcat统一管理</p></blockquote></li><li><p>servlet对象处理请求并生成响应</p></li><li><p>服务器(tomcat)将响应转发给对应的用户</p></li></ol><p>创建一个简单servlet程序的步骤:</p><ol><li>创建servlet类需要继承HttpServlet类并重写其doGet和doPost方法</li><li>在doGet或doPost方法中处理请求(req)并生成响应(sesp)</li><li>使用web.xml或@WebServlet注解将servlet类映射到对应的url路径中(触发关系)</li><li>在前端中调用接口地址</li></ol><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--一个类可以对应多个servlet-name--&gt;</span><br><span class="hljs-comment">&lt;!--一个servlet-name可以对应多个url--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>servlet名<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>servlet类名(全限定名)<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置servlet中使用的参数--&gt;</span><br>    <span class="hljs-comment">&lt;!--通过servletconfig来获取--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>配置好的servlet名<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>servlet对应的url路径(注意路径前一般要加/)<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-comment">&lt;!--配置全局参数--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>init-param只能在单个servlet中配置和使用</p><p>context-param可以在整个web程序中配置和使用</p></blockquote><p>全局参数一般用来配置编码或加载初始化文件</p><p>@webServlet注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns=&quot;/register&quot;)</span><br><span class="hljs-comment">//绑定多个url</span><br><span class="hljs-meta">@WebServlet(name=&quot;loginServlet&quot;,urlPatterns=&#123;&quot;/login01&quot;,&quot;/login02&quot;&#125;)</span><br><span class="hljs-comment">//注意urlPatterns的路径可以使用*通配符进行范围匹配对应的url</span><br><span class="hljs-string">&quot;/*/abc&quot;</span>注意这个url会匹配所有的url，实际上等同于<span class="hljs-string">&quot;/*&quot;</span><br><span class="hljs-meta">@WebServlet(urlPatterns=&quot;/register02&quot;,</span><br><span class="hljs-meta">           initParams=&#123;</span><br><span class="hljs-meta">               @WebInitParam(name=&quot;username&quot;,value=&quot;admin&quot;)</span><br><span class="hljs-meta">           &#125;)</span><br></code></pre></td></tr></table></figure><p>获取配置中的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ServletConfig servletConfig=getServletConfig();<br>String username=servletConfig.getInitParameter(<span class="hljs-string">&quot;username&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><strong>servlet是单实例多线程的对象</strong></p><p>在tomcat中一个servlet只能对应一个实例, 但是该实例可以被多个线程同时访问(一个servlet对象同时服务多个请求)</p><blockquote><p>意味着tomcat中只需要创建一个servlet就同时可以处理多个请求, 不需要创建重复的对象</p></blockquote><p>servlet的生命周期:</p><p>编译 加载 实例化 服务化 销毁</p><p>由于servlet单实例多线程的特性, 因此编译 加载 实例化都只需要进行一次, 而服务化在一个生命周期中可以重复进行多次直到销毁</p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>在java中servlet是一个接口, javax.servlet, 需要从外部导入使用(不属于JDK自带的类库)</p><p>实现一个servlet类有三种方法:</p><ol><li>实现Servlet接口, 并实现该接口的所有方法</li><li>继承HttpServlet类, 并实现doPost或doGet方法</li><li>继承GenericServlet类, 实现service()方法</li></ol><p>继承关系: GenericServlet类实现了Servlet接口, HttpServlet继承了GenericServlet类</p><p><strong>Servlet接口的</strong></p><p>Servlet接口需要实现5个方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>init</td><td>初始化时执行, 对应生命周期的实例化, 每个生命周期内只会执行一次</td></tr><tr><td>service</td><td>对应生命周期的服务化, 每次处理请求都会调用</td></tr><tr><td>destory</td><td>对应生命周期的销毁,在tomcat关闭时被自动调用</td></tr><tr><td>getServletConfig</td><td>获取servlet的配置</td></tr><tr><td>getServletInfo</td><td>获取servlet对象的状态信息</td></tr></tbody></table><blockquote><p>实现Servlet的service方法并调用自定义的doPost或doGet方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//service方法的参数均由tomcat传入</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    HttpServletRequest req=(HttpServletRequest)servletRequest;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> req.getMethod();<br>    <span class="hljs-keyword">if</span>(method.equals(<span class="hljs-string">&quot;GET&quot;</span>))&#123;<br>        doGet();<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(method.equals(<span class="hljs-string">&quot;POST&quot;</span>))&#123;<br>        doPost();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>面试题</p><p>jsp和servlet的区别</p><p>单独使用jsp或者servlet都可以编写一个网页应用</p><p>jsp和servlet都可以包含html代码和java代码</p><table><thead><tr><th>区别</th><th>servlet</th><th>jsp</th></tr></thead><tbody><tr><td></td><td>后端</td><td>前端</td></tr><tr><td>本质</td><td>java后端api, 可以在java中写html</td><td>一种动态网页, 本质是在html代码中插入java代码 servlet</td></tr><tr><td>mvc模型</td><td>属于controller控制器</td><td>属于view视图</td></tr><tr><td>重写service()方法</td><td>可以</td><td>不可以</td></tr><tr><td>接受的请求协议</td><td>所有协议都支持</td><td>http请求</td></tr><tr><td>会话管理</td><td>默认开启</td><td>默认关闭</td></tr><tr><td>修改后如何生效</td><td>需要重新编译和重启服务器</td><td>直接刷新页面</td></tr><tr><td>隐式对象</td><td>没有</td><td>有</td></tr><tr><td>导包</td><td>作为库导入</td><td>将包导入jsp代码中</td></tr></tbody></table><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>ServletContext是由Tomcat提供的上下文对象, 每个运行的servlet web程序都有一个对应的ServletContext对象</p><p>该对象的生命周期与对应web程序的生命周期相同</p><p>ServletContext对象是tomcat和web程序通信的唯一方法, 可以用于数据通信, servlet间的数据共享, 全局配置</p><p>有4种对象都提供了相同的方法来获取ServletContext</p><p>getServletContext()方法</p><ol><li>ServletConfig对象</li><li>HttpServlet对象</li><li>HttpSession对象</li><li>ServletContextEven对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在HttpServlet中可以调用父类的getServletContext()方法;</span><br>getServletContext();<br><span class="hljs-comment">//通过config获取</span><br>getServletConfig.getServletContext();<br><span class="hljs-comment">//通过session获取</span><br>req.getSession().getServletContext();<br></code></pre></td></tr></table></figure><p>Java Web四大域对象:</p><ol><li>ServletContext</li><li>PageContext</li><li>ServletRequest</li><li>HttpSession</li></ol><p>这些域对象使用map来提供数据存储功能</p><p>servletContext有各种实例方法</p><table><thead><tr><th>方法名</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>setAttribute</td><td>键,值</td><td>存储context属性</td></tr><tr><td>getAttribute</td><td>键</td><td>读取</td></tr><tr><td>removeAttribute</td><td>键</td><td>删除对应的context属性</td></tr><tr><td>getRealPath</td><td>相对路径</td><td>获取绝对路径</td></tr></tbody></table><blockquote><p>getRealPath通常用于读取项目中的资源(调用字节流读取时需要提供绝对路径)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里的相对路径中 /代表classes目录</span><br><span class="hljs-comment">//  不加/或者./ 代表当前所在package的目录</span><br>servlet类.class.getResourceAsStream(<span class="hljs-string">&quot;相对路径&quot;</span>);<br><span class="hljs-comment">//这里的相对路径 /代表web目录</span><br>servletContext.getResourceAsStream(<span class="hljs-string">&quot;相对路径&quot;</span>);<br>String path=servletContext对象.getRealPath(<span class="hljs-string">&quot;相对路径&quot;</span>);<br>InutStream(path);<br></code></pre></td></tr></table></figure><p><strong>重定向和转发</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转发请求</span><br>requestDispatcher.forward(req,resp);<br><span class="hljs-comment">//重定向过程</span><br><span class="hljs-comment">//手动重定向</span><br><span class="hljs-comment">//设置302响应码</span><br>resp.setStatus(<span class="hljs-number">302</span>);<br>resp.setHeader(<span class="hljs-string">&quot;Location&quot;</span>,<span class="hljs-string">&quot;url地址&quot;</span>);<br><span class="hljs-comment">//使用resp自带的重定向方法</span><br>resp.sendRedirect(<span class="hljs-string">&quot;url地址&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>jsp</strong></p><p>jsp是一种动态网页技术, 可以视为简化的servlet(可以用于实现servlet的功能)</p><p>jsp不能直接被浏览器解析, 必须在tomcat容器中运行, 会被服务器解析为对应的html代码</p><p><strong>applet</strong></p><p>applet是一种过时的java Web技术, applet的代码可以直接被浏览器解析成应用(网页), 相对于一种前端技术</p><blockquote><p>目前applet技术已经被淘汰, 主流浏览器中只有IE浏览器还在支持applet</p></blockquote><p><strong>通过反射将map封装为对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> User <span class="hljs-title function_">mapToBean</span><span class="hljs-params">(Map&lt;String,Object&gt; map,Class&lt;User&gt; clazz)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>    Field[] fields = clazz.getDeclaredFields();<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-comment">//通过反射遍历属性名</span><br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        <span class="hljs-comment">//关闭安全检查</span><br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> field.getName();<br>        Class&lt;?&gt; type = field.getType();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-comment">//对user对象的特定属性进行赋值</span><br>        field.set(user,o);<br>    &#125;<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TreeSet</title>
    <link href="/2022/11/03/TreeSet/"/>
    <url>/2022/11/03/TreeSet/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是一种分层结构, 不是线性结构</p><p>树中的每个节点(node)会包含三部分: </p><ol><li>当前节点的数据</li><li>指向左子节点的指针(null表示不存在左子节点)</li><li>指向右子节点的指针(null表示不存在右子节点)</li></ol><blockquote><p>(?正确性存疑)注意这里并没有指向父节点的指针, 也就是说无法从叶子节点向根节点进行遍历</p></blockquote><blockquote><p>常见线性数据结构: 数组(Arrays) 链表(Linked List) 栈(Stack) 队列(Queue)</p></blockquote><p>根节点(root): 没有父节点的节点(node)(每个树结构只能有一个根节点)(处于二叉树的最顶端)</p><p>叶子节点(leave): 没有子节点的节点(处于二叉树的最末端)</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-code">     tree</span><br><span class="hljs-code">     ----</span><br><span class="hljs-code">      j    &lt;-- root</span><br><span class="hljs-code">    /   \</span><br><span class="hljs-code">   f      k  </span><br><span class="hljs-code"> /   \      \</span><br><span class="hljs-code">a     h      z    &lt;-- leaves</span><br></code></pre></td></tr></table></figure><p>树结构的特点:</p><ol><li><p>可以存储层次结构信息</p></li><li><p>访问&#x2F;搜索元素的速度适中(比链表快, 比数组慢)</p></li><li><p>插入&#x2F;删除速度适中(比数组快,无序链表慢)</p></li><li><p>节点数量可变(无上限)</p><blockquote><p>因为节点使用指针链接到不同节点</p></blockquote></li></ol><p>树的常见应用场景:</p><ol><li>操作层次结构的数据</li><li>树遍历可以用于信息的搜索</li><li>路由算法</li><li>多阶段决策</li></ol><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>二叉树(Binary Tree)属于一种递归结构, 并且每个节点最多有两个子节点</p><p>二叉搜索树(Binary Search Tree)属于一种特殊的二叉树, 要求每个节点都大于或等于左子节点值, 小于等于右子节点</p><p>左子节点&lt;&#x3D;当前节点&lt;&#x3D;右子节点</p><blockquote><p>下图是二叉搜索树示例</p></blockquote><p><img src="/2022/11/03/TreeSet/image-20220519100114435.png" alt="image-20220519100114435"></p><p>BST(Binary Search Tree)常用操作:</p><p>搜索 寻找最大值 寻找最小值 插入 删除</p><p>这些操作的时间复杂度为O(h) </p><blockquote><p>O(h)说明值与h成正相关, 所以O(O(h))&#x3D;O(h)</p></blockquote><blockquote><p>h为BST的高度, 对于偏斜的二叉树, 时间成本可能会变为O(n)n:树的节点数</p></blockquote><p><strong>红黑树的高度可以始终保持在O(log n), 因此红黑树在进行BST操作时可以将时间复杂度保持在O(log n)</strong></p><blockquote><p>红黑树可以保证进行BST操作后,将树高度保持在log n(自平衡特性)</p></blockquote><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种自平衡的二叉搜索树, 并且每个节点都会有一个额外的位(被解释为红, 黑颜色的状态)</p><p>红黑是用于确保树在进行插入删除操作时可以保存平衡</p><p>红黑树不是一个prefet balanced的树, 但是已经可以将树搜索的时间复杂度降低到0 (log n)</p><blockquote><p>其中n代表树的元素总数</p></blockquote><p><strong>红黑树是一种特殊的二叉搜索树, 它通过给每个节点加入额外颜色位, 并遵循红黑树原则实现了自平衡</strong></p><p><strong>由于红黑树每个节点仅多出一位额外颜色位, 因此红黑树的内存占用量其实与(无色)二叉搜索树相等</strong></p><p>红黑树原则:</p><ol><li><p>每个节点都必须有一个额外位来保存红黑的颜色信息</p></li><li><p>黑红树的根节点必须是黑色节点</p></li><li><p>红黑树的叶子节点必须是黑色节点</p></li><li><p>红色节点不能是另一个红色节点的父节点或子节点</p><blockquote><p>两个红色节点可以是兄弟节点(sinlings)</p></blockquote></li><li><p>对于同一个起始节点来说, 从该节点到该节点的叶子节点的所有路径上经过的黑色节点数目总是相同的</p><blockquote><p>这里的起始节点包括根节点</p></blockquote></li></ol><p>红黑树的特点:</p><ol><li>只有两种节点: 红节点 黑节点</li><li>根节点一定为黑节点</li><li>红节点的子节点一定为黑节点</li><li>(正确性存疑) 从任何一个节点到根节点的路程中, 必定经过相同的黑节点</li></ol><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>TreeSet是具有树形结构的集合</p><p>TreeSet的底层通过红黑树实现</p><p>TreeSet的元素也是不重复的,但是去重原理与HashSet不同</p><blockquote><p>TreeSet是有序的, HashSet是无序的</p></blockquote><blockquote><p>TreeSet通过调用元素本身实现的Comparable接口(自然排序)或者实现Comparator类的去重器(compare方法)(自定义排序)来实现去重</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeSet&lt;User&gt; userTreeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(((o1, o2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> o1.name.compareTo(o2.name);<br>&#125;));<br><span class="hljs-comment">//实现Comparator函数接口中的compare方法</span><br>userTreeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;ll&quot;</span>, <span class="hljs-number">12</span>));<br>userTreeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;l2&quot;</span>, <span class="hljs-number">12</span>));<br>userTreeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;l3&quot;</span>, <span class="hljs-number">12</span>));<br>userTreeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;l2&quot;</span>, <span class="hljs-number">12</span>));<br>userTreeSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;ll&quot;</span>, <span class="hljs-number">12</span>));<br></code></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><strong>java里面需要重点掌握两种Map实现类, ConcurrentHashMap(线程安全)和HashMap(非线程安全)</strong></p><blockquote><p>面试重点掌握内容</p></blockquote><p>Map里面通过两组值来保存数组: 键值(Key和value)</p><p>Map特点:</p><ol><li>键值是一对一的关系, 也就是说一个key只有唯一对应的value</li><li>不允许有重复的key, 允许有重复的value</li><li>1</li></ol><p><img src="/2022/11/03/TreeSet/image-20220519145209333.png" alt="image-20220519145209333"></p><p>注意Set与Map这两种集合间的关系非常密切</p><p>Map里面的key可以组成一个Set集合(key元素无序不重复), 并且Map有keySet()方法可以返回所有key组成的Set集合</p><table><thead><tr><th>Set实现类</th><th>Map实现类</th></tr></thead><tbody><tr><td>HashSet</td><td>HashMap</td></tr><tr><td>LinkedHashSet</td><td>LinkedHashMap</td></tr><tr><td>SortedSet</td><td>SortedMap</td></tr><tr><td>TreeSet</td><td>TreeMap</td></tr><tr><td>EnumSet</td><td>EnumMap</td></tr></tbody></table><p>这些Map实现类的key集储存方式与对应的Set实现类完全相同</p><blockquote><p>Map里面如果添加了重复key值的元素会导致之前放入的重复元素被替换为新的元素</p><p>Set里面如果试图添加重复的元素, 不会进行操作</p></blockquote><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>常用实例方法:</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>put</td><td>将一对键值加入map中, 如果存在重复的键会将替换成新的元素</td></tr><tr><td>toString</td><td>按照{key1&#x3D;value1,key2&#x3D;value2…}格式输出</td></tr><tr><td>get</td><td>传入键, 返回对应的值</td></tr><tr><td>replace</td><td>将map中重复的键替换成新元素, 但是如果不存在将不做任何操作</td></tr><tr><td>clear</td><td>清除map中所有的元素</td></tr><tr><td>remove</td><td>传入key,进行键匹配, 删除对应的元素   也可以传入配对的键值, 进行键值匹配</td></tr><tr><td>keySet</td><td>返回map中所有key组成的Set</td></tr><tr><td>values</td><td>返回map中所有值组成的Collection</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>hashMap.put(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;ll&quot;</span>);<br>hashMap.put(<span class="hljs-string">&quot;223&quot;</span>,<span class="hljs-string">&quot;ll&quot;</span>);<br>hashMap.put(<span class="hljs-string">&quot;323&quot;</span>,<span class="hljs-string">&quot;ll&quot;</span>);<br>hashMap.put(<span class="hljs-string">&quot;423&quot;</span>,<span class="hljs-string">&quot;ll&quot;</span>);<br>hashMap.put(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;lp&quot;</span>);<br>hashMap.put(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;lj&quot;</span>);<br>System.out.println(hashMap);<br>System.out.println(hashMap.get(<span class="hljs-string">&quot;123&quot;</span>));<br>hashMap.put(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>hashMap.put(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;124&quot;</span>);<br><span class="hljs-comment">//可以添加null作为键</span><br>System.out.println(hashMap.get(<span class="hljs-literal">null</span>));<br>hashMap.replace(<span class="hljs-string">&quot;999&quot;</span>,<span class="hljs-string">&quot;lj&quot;</span>);<br>hashMap.clear();<br>hashMap.remove(<span class="hljs-string">&quot;123&quot;</span>);<br>hashMap.keySet();<br><span class="hljs-comment">//实际返回类型为HashMap的内部类</span><br><span class="hljs-comment">//java.util.HashMap$KeySet</span><br><span class="hljs-comment">//Set接口的实现类</span><br>hashMap.values();<br><span class="hljs-comment">//实际返回类型为HashMap的内部类</span><br><span class="hljs-comment">//java.util.HashMap$Values</span><br><span class="hljs-comment">//Collection接口的实现类</span><br>Collection&lt;String&gt; c= hashMap.values();<br><span class="hljs-keyword">for</span> (String s : hashMap.keySet()) &#123;<br>    hashMap.get(s);<br>    <span class="hljs-comment">//通过键来遍历hashMap的值</span><br>&#125;<br>girlCatHashMap.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BiConsumer</span>&lt;Girl, Cat&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Girl girl, Cat cat)</span> &#123;<br>        System.out.println(girl);<br>        System.out.println(cat);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">//匿名内部类实现BiConsumer函数接口的accept方法</span><br>hashMap.forEach((str1,str2)-&gt;&#123;<br>    System.out.println(str1);<br>    System.out.println(str2);<br>&#125;);<br><span class="hljs-comment">//lambda表达式</span><br></code></pre></td></tr></table></figure><p>HashMap的key实质上就是HashSet的底层, 因此其去重原理就是HashSet的去重原理</p><ol><li><p>使用hashcode()将要添加的元素与集合中的其他元素一一对比, 如果不相等则进入第二步</p></li><li><p>使用equals()将要添加的元素与集合中的其他元素一一对比, 如果还是不相等则加入集合中</p></li></ol><p>HashMap在JDK1.7底层是数组+链表</p><p><img src="/2022/11/03/TreeSet/image-20220519163342856.png" alt="image-20220519163342856"></p><p>HashMap在JDK1.8的底层是数组+链表+红黑二叉树</p><p><img src="/2022/11/03/TreeSet/image-20220519163449890.png" alt="image-20220519163449890"></p><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>TreeSet用了TreeMap的key底层原理, 所以两者的去重原理相同</p><blockquote><p>TreeMap的去重是用key对象本身的实现的Comparable比较器(自然比较)或Comparator(自定义比较)</p></blockquote><p><img src="/2022/11/03/TreeSet/image-20220519164500135.png" alt="image-20220519164500135"></p><p>TreeMap特点:</p><ol><li>key是有序并且不重复的</li><li>值可以重复</li><li>key不能为null(底层去重需要用到对象本身的比较器, null没法去重)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeMap&lt;String,String&gt; stringStringTreeMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>stringStringTreeMap.put(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>stringStringTreeMap.put(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-comment">//编译不会检查出问题, 但是运行时会抛出异常(java.lang.NullPointerException)</span><br>stringStringTreeMap.remove(<span class="hljs-string">&quot;123&quot;</span>);<br>System.out.println(stringStringTreeMap);<br></code></pre></td></tr></table></figure><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><blockquote><p>注意table不用大写</p><p>因为Hashtable就是java中类的名称</p></blockquote><p>Hashtable与HashMap相似,但是</p><p>Hashtable是线程安全的, HashMap不是线程安全的</p><table><thead><tr><th>线程不安全</th><th>线程安全</th></tr></thead><tbody><tr><td>StringBuilder</td><td>StringBuffer</td></tr><tr><td>ArrayList</td><td>Vector</td></tr><tr><td>HashMap</td><td>Hashtable</td></tr></tbody></table><blockquote><p>一般线程不安全的类是最常用的, 因为性能较高</p></blockquote><h1 id="集合的交集-并集-差集"><a href="#集合的交集-并集-差集" class="headerlink" title="集合的交集 并集 差集"></a>集合的交集 并集 差集</h1><p>交集是两个集合的重复部分</p><p>并集是将两个集合合并为一个集合</p><p>差集是A集合中有, B集合中没有的元素的集合(相当于A集合减去AB并集的部分)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(stringList,<span class="hljs-string">&quot;张飞&quot;</span>,<span class="hljs-string">&quot;关羽&quot;</span>,<span class="hljs-string">&quot;黄忠&quot;</span>,<span class="hljs-string">&quot;赵云&quot;</span>);<br>List&lt;String&gt; stringList2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(stringList2,<span class="hljs-string">&quot;张飞&quot;</span>,<span class="hljs-string">&quot;关羽&quot;</span>,<span class="hljs-string">&quot;马超&quot;</span>,<span class="hljs-string">&quot;黄忠&quot;</span>);<br>stringList2.retainAll(stringList);<br><span class="hljs-comment">//求两个列表的交集 保留重复的元素</span><br>stringList2.removeAll(stringList);<br>stringList2.addAll(stringList);<br><span class="hljs-comment">//两个步骤的结果 求两个列表并集</span><br>stringList2.removeAll(stringList);<br><span class="hljs-comment">//求两个列表的差集</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web</title>
    <link href="/2022/11/03/Web/"/>
    <url>/2022/11/03/Web/</url>
    
    <content type="html"><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><p>互联网被称为www(world wide web)</p><p>大部分网站系统都是C&#x2F;S架构(Client Service)</p><p>其中Client分为浏览器(瘦客户端) 手机APP 电脑程序</p><p>Client是前端 Serivce是后端</p><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>前端三件套</p><p>HTMLCSSJavaScript</p><p>HTML和CSS负责页面布局的展示</p><p>JavaScript负责业务逻辑的编程</p><blockquote><p>注意常见的前端框架如Vue React都是JS底层的后端框架, 它们使用自定义的JavaScript作为动态功能, 编写的代码会在服务端解析为html和css返回给用户(响应式布局)</p></blockquote><p>最新的HTML版本为HTML5.0简称H5</p><p>HTML: 超文本标记语言 Hyper Text Markup Language</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>HTML的标签由W3C机构严格定义, 无法自定义扩展</p><p>标签特点:</p><ol><li>有开始标签和结束标签组成</li><li>标签都是放在&lt;&gt;里的</li></ol><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>头标签</td><td></td></tr><tr><td>&lt;head&gt;</td><td>存放元信息 子标签:title link meta script style base</td></tr><tr><td>&lt;title&gt;</td><td>网页标题(不会显示在网页主体body中, 显示在浏览器的标签标题中)</td></tr><tr><td>&lt;link&gt;</td><td>引入外部资源(JS脚本, css文件)</td></tr><tr><td>&lt;script&gt;</td><td>内嵌JS脚本</td></tr><tr><td>&lt;style&gt;</td><td>内嵌样式表</td></tr><tr><td>&lt;meta&gt;</td><td>元信息</td></tr><tr><td>文本标签</td><td></td></tr><tr><td>&lt;h1&gt;</td><td>标题标签,  有6级:h1 h2 h3 h4 h5 h6</td></tr><tr><td>&lt;p&gt;</td><td>文章的一段</td></tr><tr><td>&lt;b&gt;</td><td>加粗</td></tr><tr><td>&lt;strong&gt;</td><td>加粗, 语义强调&#x2F;重要(被程序解析时会加上语言, 在视觉上与b没有区别)</td></tr><tr><td>&lt;i&gt;</td><td>斜体</td></tr><tr><td>&lt;em&gt;</td><td>斜体, 语义强调&#x2F;重要(被程序解析时会加上语言, 在视觉上与em没有区别)</td></tr><tr><td>其他</td><td></td></tr><tr><td>&lt;img&gt;</td><td>图片标签, 有三个属性: src(图片路径或链接) alt(加载失败时显示的信息) title(加载成功时显示的信息)</td></tr><tr><td>&lt;a&gt;</td><td>超链接标签, 可以跳转到指定的网页或者当前网页的某个位置 有href属性和targer属性 target属性可以赋_blank self</td></tr><tr><td>&lt;div&gt;</td><td>分块标签</td></tr><tr><td>列表标签</td><td></td></tr><tr><td>&lt;ol&gt;</td><td>有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>无序列表</td></tr><tr><td>&lt;li&gt;</td><td>列表项</td></tr><tr><td>&lt;dl&gt;</td><td>定义列表</td></tr><tr><td>&lt;dt&gt;</td><td>定义项目</td></tr><tr><td>&lt;dd&gt;</td><td>定义描述</td></tr><tr><td>媒体标签</td><td></td></tr><tr><td>&lt;audio&gt;</td><td>音频</td></tr><tr><td>&lt;video&gt;</td><td>视频</td></tr><tr><td>表单标签</td><td></td></tr><tr><td>form</td><td>表单主体 action指定url作为提交数据的链接, method有GET和POST两种</td></tr><tr><td>input</td><td>type属性有很多类型: text password hidden file date radio checkbox button submit(提交按钮) reset(重置按钮) name属性作为提交的key和value作为提交的值(一个name会有多个value可选)</td></tr><tr><td>textarea</td><td>可以输入多行文本的框</td></tr><tr><td>select</td><td>下拉框</td></tr><tr><td>option</td><td>select的选项</td></tr><tr><td>表格标签</td><td></td></tr><tr><td>table</td><td>整个表格</td></tr><tr><td>thead</td><td>表头</td></tr><tr><td>th</td><td>表头的每个单元格</td></tr><tr><td>tr</td><td>表格的每行</td></tr><tr><td>td</td><td>表格的每个单元格, 属性: colspan合并列 rowspan 合并行</td></tr><tr><td></td><td></td></tr></tbody></table><blockquote><p>实体符号</p></blockquote><p>实体标签是html中的特殊符号, 直接输入这些符号不会被浏览器解析并显示, 只有输入实体符号才能在浏览器中显示对应的符号</p><table><thead><tr><th>名称</th><th>显示</th><th>实体符号</th></tr></thead><tbody><tr><td>空格</td><td></td><td>&amp;nbsp;</td></tr><tr><td>小于号</td><td>&lt;</td><td>&amp;lt;</td></tr><tr><td>大于号</td><td>&gt;</td><td>&amp;gt;</td></tr><tr><td>引号</td><td>“</td><td>&amp;quot;</td></tr><tr><td>和号</td><td>&amp;</td><td>&amp;amp;</td></tr><tr><td>撤号</td><td>&#96;</td><td>&amp;apos</td></tr><tr><td>乘</td><td>&amp;times;</td><td>&amp;times;</td></tr><tr><td>除</td><td>&amp;divide;</td><td>&amp;divide;</td></tr></tbody></table><h2 id="块级标签和行级标签"><a href="#块级标签和行级标签" class="headerlink" title="块级标签和行级标签"></a>块级标签和行级标签</h2><p>html中的标签都可以分为块级标签和行级标签</p><p>块级标签: 单独占一整行空间, 可以设置高度</p><p>行级标签(也可以称为行内标签, 一般放在块级标签的内部): 只占一行的部分空间, 无法设置高度, 根据内部填充的内容自动调整高度</p><p>常见块级标签: divph1-h6uloldllidddthrbrtabletheadtbodytfoottrh5header</p><p>常见行级标签: span a img select strong b eem i small sup sub form label button</p><p>框架集标签: frameset frame</p><blockquote><p>框架集标签已经是Deprecated废弃状态, 不推荐使用</p></blockquote><p><strong>Deprecated状态处以待淘汰状态, 目前还是被浏览器支持但是会在未来被淘汰</strong></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>css: 层叠样式表 (Cascading style sheet)</p><p>css有三种: 行内样式表  内嵌样式表外联样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>helloCss<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        &lt;!-内嵌样式表--&gt;</span><br><span class="language-css">        <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">13px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    &lt;!-引入外联样式表--&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;hello.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    &lt;!-行内样式表--&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title01&quot;</span>&gt;</span>蜗牛学苑<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>外联样式表的语法跟内嵌样式表相同</p><p>(但是注释是用&#x2F;&#x2F;, 内嵌样式表由于还在html文件中需要用&lt;!—&gt;来注释)</p><blockquote><p>注意内嵌js脚本可以用&#x2F;&#x2F;注释</p></blockquote><p>生效优先级(范围小的优先级最高,范围大的优先级最低):</p><p>行内样式表&gt;内嵌样式表&gt;外联样式表</p><h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><p>CSS中的元素选择器有4类:</p><table><thead><tr><th>选择器</th><th>示例</th></tr></thead><tbody><tr><td>通配选择器</td><td>*{}</td></tr><tr><td>标签选择器</td><td>div{}</td></tr><tr><td>类选择器</td><td>.class{}</td></tr><tr><td>ID选择器</td><td>#id{}</td></tr></tbody></table><p>生效优先级(范围小的优先级最高,范围大的优先级最低):</p><p>ID&gt;类&gt;标签&gt;通配</p><h2 id="背景样式-background-style"><a href="#背景样式-background-style" class="headerlink" title="背景样式(background-style)"></a>背景样式(background-style)</h2><blockquote><p>背景样式的前面都要加上background-前缀</p></blockquote><table><thead><tr><th>样式名</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>background-color</td><td>16进制或rgb颜色值</td><td>背景颜色</td></tr><tr><td>background-image</td><td>url或路径</td><td>设置背景照片</td></tr><tr><td>background-size</td><td>像素或百分比</td><td>设置背景大小</td></tr><tr><td>background-repeat</td><td>no-repeat, repeat-x, repeat-y, repeat</td><td>设置背景图是否重复平铺</td></tr><tr><td>background-position</td><td>top center bottom left center  right或x% y%或x,y</td><td>设置背景图片的起始位置(左上角位置)</td></tr><tr><td>background-attachment</td><td>scroll(默认, 随着页面一起滚动), fixed(固定, 不滚动), inherit(继承父元素的attachment属性)</td><td>设置背景是否滚动</td></tr></tbody></table><h2 id="字体样式-font-style"><a href="#字体样式-font-style" class="headerlink" title="字体样式(font-style)"></a>字体样式(font-style)</h2><blockquote><p>字体样式会绑定属性内显示的文本内容</p></blockquote><table><thead><tr><th>样式名</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>font-family</td><td>仿宋(字体名, 中文或英文)</td><td>设置字体的种类</td></tr><tr><td>font-size</td><td>px(像素)</td><td>设置字体大小</td></tr><tr><td>font-style</td><td>italic(斜体)bold(粗体)</td><td>设置字体的风格</td></tr><tr><td>font-weight</td><td>100-900</td><td>加粗</td></tr><tr><td>color</td><td>16进制或rgb颜色值</td><td>设置字体颜色</td></tr><tr><td>opacity</td><td>0.0-1.0</td><td>透明度</td></tr></tbody></table><h2 id="文本样式-text-style"><a href="#文本样式-text-style" class="headerlink" title="文本样式(text-style)"></a>文本样式(text-style)</h2><p>文本样式设定整个文本的样式</p><blockquote><p>文本样式都要加上text-前缀, 除了line-height和letter-spacing</p></blockquote><table><thead><tr><th>样式名</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>text-align</td><td>center left right</td><td>设置文字对齐的方向</td></tr><tr><td>text-decoration</td><td>underline overline line-through</td><td>添加下划线 上划线 删除线</td></tr><tr><td>text-transform</td><td>uppercase lowercase capitalize</td><td>全部大写 全部小写 首字母大写</td></tr><tr><td>text-shadow</td><td>px px px color</td><td>横向距离 纵向距离 阴影模糊程度 阴影颜色</td></tr><tr><td>letter-spacing</td><td></td><td>字间距</td></tr><tr><td>line-height</td><td></td><td>行高</td></tr></tbody></table><h2 id="列表样式-lists-style"><a href="#列表样式-lists-style" class="headerlink" title="列表样式(lists-style)"></a>列表样式(lists-style)</h2><p>列表样式可以应用于li</p><table><thead><tr><th>样式名</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>list-style-type</td><td>square upper-roman none</td><td>设置列表左边的1. 2. 3.的样式</td></tr><tr><td>list-style-image</td><td>url</td><td>设置列表左边为图标</td></tr></tbody></table><blockquote><p>不同的选择器可以叠加为后代选择器</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">//选择类为classd的父元素下面对应id的子元素<br><span class="hljs-selector-class">.class</span> <span class="hljs-selector-id">#id</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="边框样式-border-style"><a href="#边框样式-border-style" class="headerlink" title="边框样式(border-style)"></a>边框样式(border-style)</h2><p>边框样式可以用于表格元素</p><table><thead><tr><th>样式名</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>border</td><td>px solid color</td><td>设置边框的宽度 样式 颜色</td></tr><tr><td>border-spacing</td><td>px</td><td>边框间距</td></tr><tr><td>border-collapse</td><td>collapse</td><td>合并边框</td></tr><tr><td>border-radius</td><td>px</td><td>设置边框圆角</td></tr></tbody></table><h2 id="状态-伪类-选择器"><a href="#状态-伪类-选择器" class="headerlink" title="状态(伪类)选择器"></a>状态(伪类)选择器</h2><blockquote><p>一般的类选择器在元素上设置class</p></blockquote><p>伪类选择器不需要手动设置class, 会将元素的状态作为类名来选择, 从而实现同一元素在不同状态下样式的更新</p><p>伪类选择器一般应用场景: a标签(链接标签的样式变化), 鼠标选择元素的样式变化</p><p>状态选择器的语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">便签名:状态选择器<br>a:visited&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>状态选择器种类</p></blockquote><table><thead><tr><th>状态选择器</th><th>状态</th></tr></thead><tbody><tr><td>link</td><td>未点击过的链接</td></tr><tr><td>visited</td><td>已点击过的链接</td></tr><tr><td>hover</td><td>正在被鼠标指向(悬停)的链接</td></tr><tr><td>active</td><td>正准备访问的链接(鼠标按下还没放开)</td></tr><tr><td>鼠标焦点</td><td></td></tr><tr><td>enabled</td><td></td></tr><tr><td>focus</td><td></td></tr><tr><td>disabled</td><td></td></tr></tbody></table><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>html中每个标签都是一个盒子: 由外边距(margin) 边框(border) 内边距(padding) 内容(content)  组成</p><blockquote><p>盒子模型</p></blockquote><p><img src="/2022/11/03/Web/image-20220615093421505.png" alt="同时"></p><p>同时margin border padding也分为四个方向</p><blockquote><p>如margin-top marigin-right marigin-bottom marigin-left</p></blockquote><table><thead><tr><th>样式</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>mairgin</td><td>px</td><td>可以按照上右下左的顺时针方向设置内边距大小(一个px只能对应一个方向)</td></tr><tr><td>border</td><td>px style color</td><td>px会同时对应四个方向</td></tr><tr><td>padding</td><td>px</td><td>可以按照上右下左的顺时针方向设置内边距大小(一个px只能对应一个方向)</td></tr></tbody></table><blockquote><p>css中的样式赋多个值时用空格隔开</p></blockquote><p><strong>一般css中为顺时针方向, 上右下左</strong></p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>浮动(float)属性可以让标签浮动</p><p>块级元素: 独占一行的标签(自带换行)</p><p>行级元素: 占一行的一部分(不会自动换行)</p><table><thead><tr><th>样式</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>float</td><td>方向(left right top bottom)</td><td>使标签向某个方向浮动</td></tr><tr><td>clear</td><td>both</td><td>清除浮动</td></tr></tbody></table><blockquote><p>float可以使块级标签无法独占一行(行级标签的特性), 但是同时会有可能影响到父元素(如造成父元素边框塌陷)</p></blockquote><h2 id="CSS元素常用样式"><a href="#CSS元素常用样式" class="headerlink" title="CSS元素常用样式"></a>CSS元素常用样式</h2><table><thead><tr><th>样式名</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>width</td><td>px</td><td>设置元素的宽度</td></tr><tr><td>height</td><td>px</td><td>设置元素的长度</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>text-decoration</td><td></td><td></td></tr></tbody></table><h2 id="定位移动样式"><a href="#定位移动样式" class="headerlink" title="定位移动样式"></a>定位移动样式</h2><p>定位移动样式有4种:top bottom right left</p><p><strong>定位移动样式只会影响已定位的元素, 对未定位元素没有任何影响</strong></p><p>定位: position, 如果position是static, 那么定位移动样式没有任何作用</p><p>css中有四种position:</p><table><thead><tr><th>值</th><th>定位技术</th><th>作用</th><th></th></tr></thead><tbody><tr><td>absolution</td><td>绝对定位</td><td>相对于父元素&#x2F;浏览器的左上角进行定位, 并且移动后会释放原有空间</td><td>会导致元素重叠</td></tr><tr><td>relative</td><td>相对定位</td><td>相对于原有位置进行定位, 并且不会释放原有空间</td><td>不会导致元素重叠</td></tr><tr><td>fixed</td><td>固定定位</td><td>相对于浏览器的左上角进行定位, 并且移动后会释放原有空间</td><td>会导致元素重叠</td></tr><tr><td>static</td><td>静态定位</td><td></td><td></td></tr></tbody></table><p><strong>定位移动</strong></p><blockquote><p>定位移动是根据position的定位进行移动, 与margin的作用不同</p></blockquote><table><thead><tr><th>样式</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>position</td><td>absolution fixed relative static sticky</td><td>定位</td></tr><tr><td>top</td><td>px</td><td>将元素的位置向下移动px</td></tr><tr><td>bottom</td><td>px</td><td></td></tr><tr><td>right</td><td>px</td><td></td></tr><tr><td>left</td><td>px</td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis缓存击穿</title>
    <link href="/2022/11/03/redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    <url>/2022/11/03/redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    
    <content type="html"><![CDATA[<p>Redis 缓存击穿 缓存穿透</p><h1 id="redis缓存击穿"><a href="#redis缓存击穿" class="headerlink" title="redis缓存击穿"></a>redis缓存击穿</h1><p>redis缓存击穿是指客户端请求的数据在redis和数据库中都不存在, 会导致每次请求都对数据库发送请求, 导致数据库压力大</p><h1 id="redis缓存雪崩"><a href="#redis缓存雪崩" class="headerlink" title="redis缓存雪崩"></a>redis缓存雪崩</h1><p>redis缓存会定期失效, 当大量数据在同一时刻失效时, 会导致数据库收到大量流量压力</p><p>解决方法:</p><ol><li>对更新机制加锁</li><li>缓存过期时间加上随机值, 避免在同时间失效</li><li>对redis集群(分布式系统)使用分布锁</li><li>对数据库请求加锁</li><li>使用后台线程更新</li></ol><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>redis缓存更新策略有: </p><ol><li>定时更新: 定期将    </li><li>读请求更新</li><li>过期更新</li><li>写请求更新</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>validation校验框架</title>
    <link href="/2022/11/03/validation%E6%A0%A1%E9%AA%8C%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/11/03/validation%E6%A0%A1%E9%AA%8C%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="validation校验框架"><a href="#validation校验框架" class="headerlink" title="validation校验框架"></a>validation校验框架</h1><table><thead><tr><th>注解</th><th>元素必须满足条件</th></tr></thead><tbody><tr><td>@Null</td><td>为Null</td></tr><tr><td>@NotNull</td><td>非Null</td></tr><tr><td>@NotBlank</td><td>非空</td></tr><tr><td>@NotEmpty</td><td>非Null切非空</td></tr><tr><td>@AssertTrue</td><td>必须true</td></tr><tr><td>@AssertFalse</td><td>必须false</td></tr><tr><td>范围校验</td><td></td></tr><tr><td>@Min(value&#x3D;最小值)</td><td>必须大于或等于</td></tr><tr><td>@Max(value&#x3D;最大值)</td><td>必须小于或等于</td></tr><tr><td>@DecimalMin(value&#x3D;最小值)</td><td>BigDecimal类型，必须大于或等于</td></tr><tr><td>@DecimalMax(value&#x3D;最小值)</td><td>BigDecimal类型，必须小于或等于</td></tr><tr><td>@Rang(max&#x3D;最大值 min&#x3D;最小值, message&#x3D;“信息”)</td><td>必须满足</td></tr><tr><td>@Past</td><td>时间必须为过去，小于现在</td></tr><tr><td>@Future</td><td>时间必须为未来，大于现在</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java对象内存模型</title>
    <link href="/2022/11/03/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/11/03/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>Java对象内存模型</p><p>JVM启动后会向操作系统申请内存空间 CPU时间片</p><p>JVM内部内存空间分为5个部分</p><blockquote><p>栈(stack) 堆(heap) 本地方法栈 程序计数器 元空间</p></blockquote><p>栈: Java程序中运行方法的内存空间 </p><p>堆(<strong>运行时内存</strong>): 存储对象</p><blockquote><p>字符串常量池属于一种对象缓存池</p><p>也会存储在堆内存中</p></blockquote><p>本地方法栈: 存储与操作系统相关的底层方法,</p><p>与程序中的自定义方法空间不相关</p><p>程序计数器: 存放代码的执行顺序</p><p>元空间: 存储类</p><p><img src="/2022/11/03/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220507105831937.png" alt="image-20220507105831937"></p><blockquote><p>在Java1.8之前元空间叫做持久代或方法区, 存储在JVM内部</p><p>在Java1.8后, 元空间取代了持久代, 存储在JVM外部</p></blockquote><p><img src="/2022/11/03/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220507105849981.png" alt="image-20220507105849981"></p><p>方法中的引用变量存储在栈内存中</p><p>引用变量会指向堆内存中的对象</p><p>数组中的引用变量本身存储在堆内存中, 可以指向堆内存中的其它对象</p><h1 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h1><p>static修饰的成员代表它属于类本身, 不属于单个实例.</p><p>所以static修饰的方法和成员变量也称为类方法 类变量</p><p>没有static修饰的方法 成员变量只能在类的单个实例里面调用(对象), 也叫做实例方法 实例变量</p><blockquote><p>在大部分中文资料里面将static修饰的成员称为静态成员 (静态方法 静态变量), 但实际上特性跟动态没有相反的意思</p></blockquote><p>静态成员无法直接访问非静态成员</p><p>修饰的成员不能访问非static成员, 只能访问其他用static修饰的成员</p><blockquote><p>虽然可以通过实例&#x2F;对象来访问类成员(static),</p><p>但是这种做法会影响程序的可读性, 建议直接通过类来调用类成员</p></blockquote><p><strong>类成员将在类被调用时保存在内存空间中, 后面调用类不再重复创建, 具有唯一性</strong></p><blockquote><p>static成员在类加载期间创建并保存在元空间(独立于JVM)</p></blockquote><p><strong>对象成员必须通过对象来调用访问, 每次创建新的对象时都会创建并保存到所属对象的内存空间中</strong></p><blockquote><p>非static成员在运行时创建并保存在堆内存</p></blockquote><p>所以不同对象的成员变量是不同的,</p><p>类成员变量是唯一的</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>Java提供了三种访问控制修饰符来实现封装</p><p>private protected public</p><blockquote><p>面向对象三大特征: 封装 继承 多态</p><p>抽象也是重要特征</p></blockquote><p>Java中的类和实例的成员变量可以进行封装来向外界隐藏对象的内部信息</p><p>面向对象三大基本特征: 封装(Encapsulation) 继承(implement) 多态(polymorphism)</p><p>封装:</p><p>隐藏–将对象的内部进行隐藏</p><p>包装–不允许外部程序直接访问成员变量, 在类的内部提供对应的方法来实现对成员变量的操作</p><p>封装可以实现:</p><ol><li><p>对类外面隐藏类的实现细节</p><blockquote><p>通常使用private修饰符实现</p></blockquote></li><li><p>提供方法来操作成员变量, 在方法里面可以加入安全限制逻辑</p></li><li><p>保证成员变量的完整性</p></li><li><p>提高代码的可维护性</p></li></ol><p>封装在Java里面通过访问控制修饰符来实现</p><p>Java里面有3种访问控制符: private protected public</p><p>还有一种情况是不加任何访问控制符的默认级别</p><p>访问控制级别从小到大</p><p>private -&gt; default -&gt; protected -&gt; public</p><p>访问控制级别表</p><table><thead><tr><th>范围</th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>同一个包</td><td></td><td>1</td><td>1</td><td>1</td></tr><tr><td>子类中</td><td></td><td></td><td>1</td><td>1</td></tr><tr><td>全局范围内</td><td></td><td></td><td></td><td>1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码定义了一个Outer外部类和Inner内部类</p><p>访问控制符中, private和protected不能用于修饰外部类</p><blockquote><p>访问控制符可以用于控制类的成员能否被其他类访问</p></blockquote><blockquote><p>访问控制符可以用于修饰类成员和类本身</p></blockquote><blockquote><p>对于外部类, 只有一种访问修饰符可以用public</p><p>两种状态: 默认 public</p></blockquote><p>一份Java源代码文件中, 如果所有类都没有用public修饰, 则源代码文件名可以取任意的.</p><p>一个Java源代码中只能有一个public修饰的类, 且文件名必须与public修饰的类名相同</p><p>JavaBean规范: Java类的每个成员变量都用private修饰符修饰, 并且每个成员变量都需要提供对应的setter getter方法(必须是用public修饰的)</p><p>模块化程序设计特点:</p><ol><li>高内聚 (尽量将模块的内部数据, 功能实现向外界隐藏, 避免受到外界干扰)</li><li>低耦合 (提供封装好的方法给外部使用)</li></ol><p>访问控制符使用建议:</p><ol><li>大部分的成员变量都用private修饰, 仅当成员变量被static修饰时或者作为全局变量使用时才考虑用public修饰</li><li>如果一个类中的方法是提供给其子类重写用的, 应该用protected修饰</li><li>类的构造器应该用public修饰, 来运行其他类创建该类的实例, 大部分外部类也应该用public修饰</li></ol><h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><p><strong>this</strong>关键字总是指向调用该方法的对象</p><p>在构造器中this会引用该构造器正在初始化的对象</p><p>在方法中this会引用调用该方法的对象</p><p>this关键字主要用于在类中的一个方法里面访问该类的其他方法或类变量(避免需要重复创建对象来调用其他方法)</p><p>在Java中一个类的类成员可以直接调用其他成员, 相当于省略了this前缀(和加上this的效果是完全一样的)</p><p><strong>注意在static修饰的方法中是不允许使用this关键字的</strong></p><blockquote><p>遵循了类成员(static 静态)无法访问非类成员(非static 非静态)的语法规定(静态成员无法访问非静态成员)</p></blockquote><blockquote><p>本质上是因为类成员变量是在类加载时就创建, 而对象成员变量只在运行时创建. 两者的运行时间和内存空间都完全不同, 所以只允许运行时间在后面的实例方法调用类成员(类成员的作用域比实例成员更大)</p></blockquote><p>当一个类中的方法里有局部变量和全局变量同名, 会导致全局变量被覆盖掉, 这时必须使用this关键字才能访问全局变量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MQ面试</title>
    <link href="/2022/11/03/MQ%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/11/03/MQ%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MQ面试"><a href="#MQ面试" class="headerlink" title="MQ面试"></a>MQ面试</h1><p>1.MQ的基本概念</p><table><thead><tr><th>角色</th><th>解释</th></tr></thead><tbody><tr><td>消息队列</td><td></td></tr><tr><td>交换机</td><td></td></tr><tr><td>消费者</td><td></td></tr><tr><td>生产者</td><td></td></tr><tr><td>消息通道</td><td></td></tr><tr><td>Breker(服务器)</td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>MQ应用场景</p><p>简答: 异步处理, 应用解耦 流量消费 日志处理服务间通信</p><table><thead><tr><th>场景</th><th>作用</th></tr></thead><tbody><tr><td>异步任务</td><td>提高系统吞吐量, 提高响应速度</td></tr><tr><td>服务间异步通信</td><td></td></tr><tr><td>解耦</td><td></td></tr><tr><td>消峰</td><td></td></tr><tr><td>定时任务</td><td></td></tr><tr><td>顺序消费</td><td></td></tr></tbody></table><p>MQ优点</p><table><thead><tr><th>优点</th><th>具体</th></tr></thead><tbody><tr><td>解耦</td><td>多模块间接口调用时, 不需要在代码中直接调用其他模块的接口, 只需要将信息发送到MQ中, 然后其他模块再到MQ队列中消费即可</td></tr><tr><td>异步</td><td>比如一个服务需要调用到多个服务时, 可以将有, 跟踪信息状态</td></tr><tr><td>削峰</td><td>降低系统高峰期的服务器压力</td></tr></tbody></table><p>缺点:</p><p>使系统稳定性降低 业务复杂度提高 还需要考虑数据一致性的问题</p><p>MQ交换机和路由策略</p><table><thead><tr><th>类型</th><th>路由策略</th></tr></thead><tbody><tr><td>Direct</td><td></td></tr><tr><td>Topic</td><td></td></tr><tr><td>Fanout</td><td></td></tr></tbody></table><p>MQ工作模式有哪些</p><table><thead><tr><th>工作模式</th><th>解释</th></tr></thead><tbody><tr><td>简单队列</td><td>1对1</td></tr><tr><td>工作队列</td><td>1对多</td></tr><tr><td>广播模式</td><td>1对多, 多个队列(绑定)</td></tr><tr><td>路由模式</td><td>跟广播模式类似, 但是消息根据路由键发送到绑定的队列中</td></tr><tr><td>Topic模式(主题模式)</td><td>跟路由模式类似, 但是Topic支持模糊匹配</td></tr></tbody></table><p>如何保证幂等性(处理重复消息)</p><p>使用redis分布式锁</p><p>如何确保消息被消费</p><p>消费者接收消息后进行手动消息确认(ACK), MQ等待消费者确认消息后再从队列中删除消息</p><p>确认消息有两种机制: 自动确认和手动确认</p><p>如何保证消息不丢失</p><ol><li>消息持久化</li><li>消息手动确认</li><li>MQ集群, 高可用</li><li>消息补偿</li></ol><p>如何实现延迟队列</p><p>使用死信交换机+信息设置存活时间方案</p><p>死信队列是什么, 死信原因</p><p>当队列中信息变成死信后会被发送到死信交换机, 死信队列绑定了死信交换机</p><p>死信原因:</p><ol><li>信息被拒绝</li><li>存活时间过期</li><li>队列满了</li></ol><p>什么是优先级队列</p><p>优先级队列会在消费者不足, 无法及时消费信息时生效</p><p>首先我们要设置队列的最大优先级</p><p>优先级高的消息会首先被消费</p><p>信息积压如何处理</p><ol><li>临时增加消费者数量</li><li>看下消费者的处理速度是否有异常, 及时修复</li><li>增加新的队列和消费者, 处理新的消费, 旧的堆积消息留着慢慢消耗完</li><li>如果消息设置了存活时间, 会导致大量消息被丢弃, 在业务上重新投递一遍消息</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2022/11/03/Maven/"/>
    <url>/2022/11/03/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>Maven是一个java项目自动化构建工具, 可以用于java项目的构建以及依赖管理</p><p>Maven实现了项目构建的自动化</p><p>java项目构建过程:</p><ol><li>clean </li><li>complie</li><li>test</li><li>report</li><li>package</li><li>install</li><li>deploy</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis plus</title>
    <link href="/2022/11/03/Mybatis%20plus/"/>
    <url>/2022/11/03/Mybatis%20plus/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis plus"></a>Mybatis plus</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis 动态SQL</title>
    <link href="/2022/11/03/Mybatis%20%E5%8A%A8%E6%80%81SQL/"/>
    <url>/2022/11/03/Mybatis%20%E5%8A%A8%E6%80%81SQL/</url>
    
    <content type="html"><![CDATA[<p><strong>mybatis SQL</strong></p><blockquote><p>下面两个sql语句相同</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sq">select * from test where name like &#x27;%$&#123;name&#125;%&#x27;;<br>select * from test where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;);<br></code></pre></td></tr></table></figure><h1 id="Mybatis-动态SQL"><a href="#Mybatis-动态SQL" class="headerlink" title="Mybatis 动态SQL"></a>Mybatis 动态SQL</h1><p>五种动态SQL</p><p>注意动态查询where和动态更新set标签都是为了if语句服务的, 否则加不加where或set标签没有区别</p><ol><li>where if</li><li>set if</li><li>foreach</li><li>include</li><li>choose when otherwise</li></ol><h2 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询"></a>动态查询</h2><p>动态查询由select where if 标签组成</p><p>where便签会自动将内容插入到select语句的where位置</p><p>if标签用于检查传入参数是否符合要求</p><blockquote><p>if标签内为传入参数的标识符, 并非sql中的字段</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;searchStudentByNameAndAge&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.StudentBean&quot;</span>&gt;</span><br>        select * from student_info where stu_name=#&#123;name&#125; and age=#&#123;age&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;searchStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.StudentBean&quot;</span>&gt;</span><br>    select * from student_info<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null&quot;</span>&gt;</span><br>            stu_name like &#x27;%$&#123;name&#125;%&#x27;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age!=null&quot;</span>&gt;</span><br>            age=#&#123;age&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="动态循环"><a href="#动态循环" class="headerlink" title="动态循环"></a>动态循环</h1><p>通过foreach标签实现动态新增或动态删除</p><blockquote><p>动态新增</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveStu&quot;</span>&gt;</span><br>        insert into student_info(stu_no,stu_name,fk_class_id) values<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;stuList&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        (#&#123;stu.stuNo&#125;,#&#123;stu.stuName&#125;,#&#123;stu.fkClassId&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>动态删除</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteStuByIdList&quot;</span>&gt;</span><br>        delete from student_info where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-comment">&lt;!--open和close属性可以手动添加开头结尾代替--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteStuByIdList&quot;</span>&gt;</span><br>        delete from student_info where id in (<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    )<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="动态重复sql"><a href="#动态重复sql" class="headerlink" title="动态重复sql"></a>动态重复sql</h1><p>使用include和sql标签</p><p>include通过refid属性指定对应id的sql标签填充在include标签所在位置</p><p>sql里面包含重复的sql语句或者标签</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;findStuByCommonSql&quot; resultType<span class="hljs-operator">=</span>&quot;com.lee.szdx03.bean.StudentBean&quot;<span class="hljs-operator">&gt;</span><br>        <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student_info<br>    <span class="hljs-operator">&lt;</span>include refid<span class="hljs-operator">=</span>&quot;commonSql&quot;<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>include<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-keyword">sql</span> id<span class="hljs-operator">=</span>&quot;commonSql&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;name!=null&quot;<span class="hljs-operator">&gt;</span><br>            stu_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%$&#123;name&#125;%&#x27;</span><br>        <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;age!=null&quot;<span class="hljs-operator">&gt;</span><br>            age<span class="hljs-operator">=</span>#&#123;age&#125;<br>        <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">sql</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><strong>动态选择了解即可</strong></p><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><p>关联查询有三种方式: 预加载即时加载 延时加载(懒加载)</p><p>按照数量关系也分为一对多查询多对一查询多对多查询</p><p><strong>多对多查询仅需要了解即可</strong></p><p>多表间映射关系:</p><p>一对一映射:任意一方引入另一个方的主键作为外键</p><p>一对多映射:多的一方</p><p>多对多映射:创建中间关系表, 引入两张表的主键作为外键</p><h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><blockquote><p>以班级和学生作为一对多关系进行解释</p></blockquote><p>预加载也被称为表连接查询</p><blockquote><p>在进行条件查询前, 先将两个表用连表查询关联为一张表</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--预加载查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;classmap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.ClassBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;className&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_name&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;classLeader&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_leader&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;stus&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.StudentBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;stuNo&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_no&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;stuName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_name&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findClassByPreload&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;classmap&quot;</span>&gt;</span><br>    select *,cl.id as cid,st.id as sid from class_info as cl inner join student_info as st on cl.id=st.fk_class_id where class_name like &#x27;%$&#123;className&#125;%&#x27;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>ClassBean</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassBean</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> id;<br>    <span class="hljs-keyword">private</span> String className;<br>    <span class="hljs-keyword">private</span> String classLeader;<br>    <span class="hljs-comment">//需要添加stus列表来接收连查表中的student记录</span><br>    <span class="hljs-keyword">private</span> List&lt;StudentBean&gt; stus;<br>&#125;<br></code></pre></td></tr></table></figure><p>及时加载也被称为分布查询</p><blockquote><p>将查询分为两步进行, 先查询班级对象, 然后通过外键在学生表中进行查询, 将查询到的学生对象集合封装到班级对象中</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--即时加载查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;classmap02&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.ClassBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;className&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_name&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;classLeader&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_leader&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--select属性指向第二步查询--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;stus&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getStuByClassId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStuByClassId&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stumap&quot;</span>&gt;</span><br>    select * from student_info where fk_class_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findClassInTimeLoad&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;classmap02&quot;</span>&gt;</span><br>    select * from class_info where class_name like &#x27;%$&#123;className&#125;%&#x27;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>懒加载需要配置mybatis-config.xml文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--开启延迟加载--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">values</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p>开发中常用预加载和懒加载</p><blockquote><p>即时加载有可能会跟子查询一样, 造成大量次数的查询, 消耗大量资源, 效率低下</p></blockquote><h2 id="多对1查询"><a href="#多对1查询" class="headerlink" title="多对1查询"></a>多对1查询</h2><p>预加载延迟加载</p><blockquote><p>多对一推荐使用预加载</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--预加载多对一查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stumap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.StudentBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;stuNo&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_no&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;stuName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_name&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;cls&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.ClassBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;className&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;classLeader&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;class_leader&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findStudentPreload&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stumap&quot;</span>&gt;</span><br>    select *,st.id as sid, cl.id as cid from student_info as st inner join class_info as cl on st.fk_class_id=cl.id where stu_name like &#x27;%$&#123;stuName&#125;%&#x27;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>延迟加载</p></blockquote><h2 id="mybatis缓存机制"><a href="#mybatis缓存机制" class="headerlink" title="mybatis缓存机制"></a>mybatis缓存机制</h2><p>面试知识:</p><ol><li>缓存存储在内存中, 读写速度快</li><li>缓存分为本地缓存和分布式缓存</li><li>本地缓存指本机的内存空间, 可以直接进行使用</li><li>分布式缓存指多台机器上面的内存空间, 通过网络进行使用</li></ol><p>mybatis中有两级缓存, 一级缓存 二级缓存</p><p>一级缓存: (默认开启)由SqlSession提供, 每个SqlSession对象对应一个一级缓存空间</p><p>二级缓存: (默认关闭)由SessionFactory提供</p><blockquote><p>二级缓存架构图</p></blockquote><p><img src="/2022/11/03/Mybatis%20%E5%8A%A8%E6%80%81SQL/image-20220606174620339.png" alt="image-20220606174620339"></p><p>二级缓存有缺陷</p><blockquote><p>一级缓存会将相同的查询语句只执行一次, 将执行结果缓存起来直接返回给相同的查询语句</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">hm.findHouseByNumbersPreload(<span class="hljs-string">&quot;1&quot;</span>);<br>hm.findHouseByNumbersPreload(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-comment">//上述代码只会在数据库中进行一次查询</span><br>pm.selectAllParking();<br>pm.selectAllParking();<br>pm.selectAllParking();<br><span class="hljs-comment">//为什么全表查询会进行两次查询</span><br></code></pre></td></tr></table></figure><blockquote><p>二级缓存有缺陷, 虽然是由SessionFactory提供, 但是会按照Mapper(namespace)来划分缓存空间</p></blockquote><p><img src="/2022/11/03/Mybatis%20%E5%8A%A8%E6%80%81SQL/image-20220607142937162.png" alt="image-20220607142937162"></p><blockquote><p>开发中常用Redis作为缓存技术</p></blockquote><p>需要缓存的数据有:</p><ol><li>高命中热点数据</li><li>空间占用量较小</li><li>修改频率低</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2022/11/03/Mybatis/"/>
    <url>/2022/11/03/Mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>Mybatis是持久层框架, 支持自定义sql 存储过程 高级映射</p><blockquote><p>使用Mybatis框架可以将生成jdbc代码,设置Statement参数, 获取ResultSet的工作都省掉, 程序员只需要专注于编写sql语句, 大大提高了编程效率</p></blockquote><p>为什么要用mybatis代替jdbc:</p><ol><li>使用连接池技术, 自动管理数据库连接,提高编程效率</li><li>sql语句不再放入java代码中, 不需要重复编译</li></ol><p>mybatis底层: 使用简单的xml或注解来进行映射, 将接口和POJOs(普通java对象)映射为数据库中的记录</p><blockquote><p>pojos等同于entity或者bean</p></blockquote><p>mybatis架构图</p><p>![image-20220601153901432](&#x2F;2022&#x2F;11&#x2F;03&#x2F;Mybatis&#x2F;image-20220601153901432.png</p><p><img src="/2022/11/03/Mybatis/image-20220601103119840.png" alt="image-20220601103119840"></p><p>Mybatis项目基本结构图</p><p><img src="/2022/11/03/Mybatis/image-20220601155416148.png" alt="image-20220601155416148"></p><blockquote><p>mybatis主配置: mybatis-config.xml(不需要记忆)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--取别名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;ClassBean&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.ClassBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAlias</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--可以包含多个environment标签, default指定使用的数据库环境--&gt;</span><br>        <span class="hljs-comment">&lt;!--不能同时使用多个数据库, 只能用一个--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--配置单个数据库环境--&gt;</span><br>            <span class="hljs-comment">&lt;!--使用jdbc类型的事务处理方式--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!--dataSource ：指定获取连接的方式</span><br><span class="hljs-comment">       type ：</span><br><span class="hljs-comment">            POOLED：采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现 ​</span><br><span class="hljs-comment">            UNPOOLED：采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。 ​</span><br><span class="hljs-comment">            JNDI：采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样</span><br><span class="hljs-comment">            注意：如果不是web或者maven的war工程，JNDI是不能使用的--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>       <br>                <span class="hljs-comment">&lt;!-- 数据库连接的属性信息 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/woniu&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>       <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>mybatis创建session</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>             <span class="hljs-comment">//-- 1.读取mybatis的核心配置文件 里面有连接池和Mapper的配置信息</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>            <span class="hljs-comment">//-- 2.创建SqlSessionFactory的构建者对象.带有Builder的基本是构建者模式</span><br>            <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>            <span class="hljs-comment">//-- 3.利用构建者构建工厂对象</span><br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> builder.build(is);<br>            <span class="hljs-comment">//-- 4.利用SqlSessionFactory工厂 构建SqlSession</span><br>            <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> factory.openSession();<br>            System.out.println(session);<br>            session.close();        <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置好mybatis-config.xml后, 使用配置来创建SqlSession对象, 则代表项目已经成功与数据库建立了连接</p><p>Mybatis对数据库进行查询操作前需要准备的工作</p><ol><li>编写数据库表对应的实体类, 创建实体类对象来存储读取的表信息</li><li>编写映射接口 ClassMapper, 该接口用于定义SQL命令对应的抽象方法(需要提供方法名, 返回类型(实体类), SQL命令的传入参数)</li><li>编写SQL命令映射文件ClassMapper.xml, 提供SQL命令和对应的抽象方法</li><li>在mybatis-config.xml中注册ClassMapper.xml</li></ol><p>映射接口ClassMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClassMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据ID查询并返回班级对象</span><br><span class="hljs-comment">     */</span><br>    ClassBean <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>;<br>    ClassBean <span class="hljs-title function_">getByName</span><span class="hljs-params">(String classNames)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>映射文件ClassMapper.xml</strong></p><blockquote><p>需要理解和记忆</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--namespace(命名空间)用于绑定接口, 并确保方法的唯一性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.lee.szdx03.mapper.ClassMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--resultType: 声明返回值类型,应该填写bean类的全路径--&gt;</span><br>    <span class="hljs-comment">&lt;!--like语句后需要用$&#123;&#125;作为字符串中的占位符--&gt;</span><br>    <span class="hljs-comment">&lt;!--用#&#123;&#125;作为占位符, 相当于jdbc的?--&gt;</span><br>    <span class="hljs-comment">&lt;!--parameterType可以设定传入sql语句的参数的类型, 不设置的话会使用绑定的方法的参数列表--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.ClassBean&quot;</span>&gt;</span><br>        select id,class_name as className,class_leader as classLeader from class_info where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--&#123;arg0&#125;和&#123;arg1&#125;都是属于匿名参数, 匿名参数必须严格按sql语句的顺序进行传参, 匿名参数名不代表参数顺序--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByIdAndName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.ClassBean&quot;</span>&gt;</span><br>        select id,class_name as className,class_leader as classLeader from class_info where id=#&#123;arg0&#125; and class_name=#&#123;arg1&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将Mapper.xml注册到mybatis-config.xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--注册单个Mapper--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/ClassMapper.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--将整个包下面的Mapper.xml都注册--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.lee.szdx03.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Mybatis多参数传给SQL语句的方式有四种:</p><ol><li>用封装好的对象传递参数</li><li>Map集合传参</li><li>匿名参数(按顺序传参)</li><li>@Param注解</li></ol><p>1 2 4都要重点理解</p><blockquote><p>使用@Param()注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">getByIdAndName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span><span class="hljs-type">long</span> id,<span class="hljs-meta">@Param(&quot;name&quot;)</span>String name)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByIdAndName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.StudentBean&quot;</span>&gt;</span><br>select id,stu_name as stuName,stu_no as stuNo from t_stu where id=#&#123;id&#125; and stu_name=#&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用Map集合传参时 mybatis会使用Map中元素对应的key作为参数名</p><p>使用对象传参时, 使用对象中的属性名来作为参数名</p><blockquote><p>注意, 当resultType为Bean类时, mybatis自动将返回结果的字段映射为Bean类中的属性, 将单行的记录值赋给Bean对象的属性</p></blockquote><blockquote><p>底层实现上会先将字段映射为Map中的key值再映射到类的属性名</p></blockquote><h2 id="核心api"><a href="#核心api" class="headerlink" title="核心api"></a>核心api</h2><ol><li>SqlSession</li><li>SqlSessionFactory</li><li>SqlSessionFactoryBuilder</li></ol><p>SqlSession是一个数据库连接, 以事务为单位执行sql语句, 提供了commit rollback方法来提交或回滚事务</p><blockquote><p>SqlSession不会提供连接池, 需要手动结束连接</p></blockquote><p>SqlSessionFactory提供了数据库连接池, 负责创建SqlSession对象并管理创建好的对象, SqlSessionFactory的生命周期应该等同于整个MyBatis项目的生命周期, 并且SqlSessionFactory对象应该在整个程序内共享使用(类成员)</p><p>SqlSessionFactoryBuilder用于创建SqlSessionFactory对象, 应该在方法作用域中使用(方法成员)</p><p>SqlSessionFactory调用openSession方法时可以传入boolean值, 代表是否开启自动提交</p><h1 id="Log4J"><a href="#Log4J" class="headerlink" title="Log4J"></a>Log4J</h1><p>Log4J是一种java日志框架</p><blockquote><p>java中常见的日志框架还有: Log4J Log4J2 Logback</p></blockquote><blockquote><p>记录的日志可以用异常定位, 数据分析, 调试程序</p><p>一般程序开发时会将日志是直接打印到控制台方便开发调试, 程序上线后必须将日志保存到文件或数据库中</p></blockquote><p>Log4J记录的日志通常分为4种等级:</p><ol><li>DEBUG 调试日志, 开发时用到</li><li>INFO 正常的输出日志</li><li>WARN 警告, 说明程序可能有异常</li><li>ERROR 错误, 说明程序已经出现了异常</li></ol><blockquote><p>重要程度(优先级)从低到高</p></blockquote><p><strong>Log4J可以和Mybatis配合使用</strong></p><blockquote><p>mybatis-config.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>log4j.properties</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">#全局日志<br>log4j.rootLogger=DEBUG, stdout<br># MyBatis 日志配置<br>log4j.logger.org.mybatis.example.BlogMapper=TRACE<br># 控制台输出<br>log4j.appender.stdout=org.apache.log4j.ConsoleAppender<br>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout<br>log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n<br></code></pre></td></tr></table></figure><h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><p>Mybatis默认需要手动提交事务, 因此执行sql增删改操作后需要调用commit方法才能将修改提交到数据库中</p><blockquote><p>insert语句在Mybatis的默认返回类型为int, 代表操作的表受影响的记录行数</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis复习</title>
    <link href="/2022/11/03/Mybatis%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/11/03/Mybatis%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis复习"><a href="#Mybatis复习" class="headerlink" title="Mybatis复习"></a>Mybatis复习</h1><p>JDBC编程的缺点:</p><ol><li>数据库连接无法自动管理, 必须由程序员手动建立和关闭, 浪费数据库性能</li><li>sql语句硬编码在java代码, 每次修改sql语句都需要重新编译java代码</li></ol><p>所以需要一种将java代码和数据库sql语句分离的编程模式</p><p>ORM: 对象关系映射(Object Relational Mapping)</p><p>orm将数据库中的表数据映射为对应的对象,java代码操作orm对象, 然后将orm对象传递给数据库进行增删改查, 实现了业务逻辑代码和数据库sql语句的分离</p><p> <img src="/2022/11/03/Mybatis%E5%A4%8D%E4%B9%A0/image-20220609153319100.png" alt="image-20220609153319100"></p><p>为什么需要ORM:</p><ol><li>ORM可以实现业务逻辑代码和数据库sql语句的分离</li><li>Java代码属于面向对象思想, 数据库sql属于纯粹数学理论, 两者并不兼容, 需要一个兼容层(映射)</li></ol><p>ORM优点:</p><ol><li>将数据库访问的SQwL语句进行封装, 使业务代码在进行数据库增删改查时不需要考虑SQL语句实现</li><li>在xml中编写sql语句, 增强了复用性, 可维护性, 可读性</li><li>可以实现自动化数据类型转化</li></ol><p>ORM缺点:</p><ol><li>自动化的映射和关联管理会导致性能下降, 只能通过延迟加载和缓存技术来降低性能损失</li><li>增加了学习成本</li><li>实现复杂查询会非常困难</li></ol><p>java中常见的ORM框架: Hibernate, iBATIS, mybatis</p><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><p>mybatis是一个持久层ORM框架,支持自定义SQL, 储存过程, 高级映射, 可以完全替代JDBC代码</p><p>mybatis使用xml文件配置原生信息, 将Mapper接口和java中的对象(POJOs)映射为数据库中的记录</p><blockquote><p>注意映射可以是双向的</p></blockquote><p>mybatis-config.xml</p><table><thead><tr><th>标签</th><th>属性</th><th>值</th><th>解释</th></tr></thead><tbody><tr><td>configuration</td><td></td><td></td><td>根标签</td></tr><tr><td>environments</td><td>default</td><td>指定默认的环境id</td><td>可以配置多组环境并指定默认环境</td></tr><tr><td>environment</td><td>id</td><td></td><td>配置单组环境</td></tr><tr><td>transactionManager</td><td>type</td><td>JDBC</td><td>使用jdbc的事务处理方式</td></tr><tr><td>dataSource</td><td>type</td><td>POOLED</td><td>配置数据库连接类型</td></tr><tr><td></td><td></td><td>UNPOOLED</td><td></td></tr><tr><td></td><td></td><td>JNDI</td><td></td></tr><tr><td>property</td><td>name</td><td>配置sql连接的属性</td><td></td></tr><tr><td></td><td>value</td><td>配置对应的值</td><td></td></tr></tbody></table><blockquote><p>mybatis-config.xml需要通过mybatis提供的Resource.getResourcesAsStream方法读取, 并传给SqlSessionFactoryBuilder中的实例方法build()</p></blockquote><p>mybatis框架在session包下提供了创建数据库连接池的类: </p><p>SqlSessionSqlSessionFactorySqlSessionFactoryBuilder</p><blockquote><p>mybatis读取mybatis-config.xml并创建数据库连接池示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//读取mybatis-config.xml,通过配置信息来创建连接池和映射Mapper</span><br>            InputStream is=Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>            <span class="hljs-comment">//创建Builder对象</span><br>            SqlSessionFactoryBuilder builder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>            <span class="hljs-comment">//builder通过配置信息来创建连接池工厂</span><br>            SqlSessionFactory factory=builder.build(is);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>SqlSessionFactoryBuilder: 用于读取配置创建工厂, 一般创建工厂后则不再需要builder, 所以应该将builder作为局部变量(方法内变量)使用</li><li>SqlSessionFactory: 连接池(工厂), 其生命周期应该等同于mybatis程序的生命周期</li><li>SqlSession: 一个数据库连接, 用于执行sql语句.   SqlSession应该作为局部变量使用, SqlSession关闭后会被连接池回收管理</li></ol><blockquote><p>可以用try…catch..finally…语句来确保SqlSession正确关闭</p></blockquote><p>注意SqlSession类似于JDBC中Connection的功能, 但是SqlSession默认需要手动提交事务, Connection默认自动提交事务</p><blockquote><p>Mapper接口也可以被称为DAO接口</p></blockquote><p>SqlSession提供了多种实例方法</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>getMapper</td><td>获取Mapper接口的实现类</td></tr><tr><td>commit</td><td>提交事务</td></tr><tr><td>rollback</td><td>回滚事务</td></tr><tr><td>close</td><td>结束使用资源</td></tr></tbody></table><blockquote><p>SqlSession使用示例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream is=Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>SqlSessionFactory factory=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br>is.close;<br><span class="hljs-comment">//创建ThreadLocal对象</span><br>ThreadLocal&lt;SqlSession&gt; tl=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><span class="hljs-comment">//将会话绑定到threadLocal对象上</span><br>tl.set(factory.openSession());<br><span class="hljs-comment">//通过tl获取SqlSession对象</span><br>SqlSession session=tl.get();<br><span class="hljs-comment">//获取Mapper接口的实现类</span><br>session.getMapper(UserMapper.class);<br><span class="hljs-comment">//解除会话绑定</span><br>tl.remove();<br></code></pre></td></tr></table></figure><blockquote><p>SqlSession线程不安全, 需要绑定ThreadLocal(线程绑定)</p></blockquote><p>分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Page&lt;BuildingBean&gt; page= PageHelper.startPage(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>).doSelectPage(()-&gt;cm.selectAllCarcharge());<br></code></pre></td></tr></table></figure><blockquote><p>mybatis本身没有实现具体的日志, 但是可以将内置的日志工厂交给其他日志框架来实现日志功能如: </p><p>SLF4JLog4jJDK loggingApache Commons Logging</p></blockquote><p>Mapper.xml</p><p>注意resultMapassociationcollection标签都需要手动开启automapping属性, 否则需要全部手动将字段和对象属性做映射</p><p>automapping&#x3D;”true”</p><blockquote><p>默认是false关闭状态</p></blockquote><p>automapping会自动将同名的(不区分大小写)字段和属性进行映射</p><p>SqlSession对象对于select语句提供了两种方法:</p><ol><li>selectOne:(默认方法)只能返回一条查询结果, 如果存在多条返回结果会报错</li><li>selectList:   返回一条或多条记录</li></ol><p><strong>selectList需要在xml中配置select标签设置resultMap属性, 或者在接口类中指定为列表返回类型</strong></p><p>mybatis可以用#{}或${}作为sql语句的占位符来传递参数</p><p>区别:</p><ol><li>#{}为预编译, 可以防止sql注入, 更加安全</li><li>${}为字符串替换, 无法防止sql注入, 不安全</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 传参#&#123;&#125;=11 --&gt;</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> #&#123;&#125;<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 实际执行的sql语句 --&gt;</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> ?<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">--  $&#123;&#125; 传参11 --&gt;</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> $&#123;&#125;<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 实际执行的sql语句 --&gt;</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nacos</title>
    <link href="/2022/11/03/Nacos/"/>
    <url>/2022/11/03/Nacos/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>Nacos是Spring Cloud Alibaba提供的一个微服务开发组件</p><p>Nacos的核心功能: 服务发现 配置管理</p><blockquote><p>服务注册中心 配置中心</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis多行查询</title>
    <link href="/2022/11/03/Mybatis%E5%A4%9A%E8%A1%8C%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/03/Mybatis%E5%A4%9A%E8%A1%8C%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis多行查询"><a href="#Mybatis多行查询" class="headerlink" title="Mybatis多行查询"></a>Mybatis多行查询</h1><p><strong>注意, 默认的Mapper函数都会调用SqlSession.selectOne()方法, 该方法只能返回单行结果, 当返回结果大于1行时会报抛出运行时错误TooManyResultsException</strong></p><p><strong>多行返回结果需要设置resultMa以及将函数的返回类型设置List&lt;Bean类&gt;</strong></p><blockquote><p>返回结果为多行时需要用List(列表)进行接收, 每个元素是一个Bean对象</p></blockquote><p>mybatis多行查询示例</p><blockquote><p>Mapper.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;StudentBean&gt; <span class="hljs-title function_">selectAllStu</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>Mapper.xml</p></blockquote><p><strong>需要注意的地方</strong></p><table><thead><tr><th>标签</th><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>resultMap</td><td>autoMapping</td><td>默认true</td></tr><tr><td></td><td>type</td><td>绑定Bean类型</td></tr><tr><td></td><td>id</td><td>设置当前resultMap的id</td></tr><tr><td>select</td><td>id</td><td>设置id, 绑定对应的方法名</td></tr><tr><td></td><td>resultMap</td><td>将返回多个结果映射为对应的resultMap</td></tr><tr><td></td><td>parameterType</td><td>传入参数类型</td></tr><tr><td></td><td>resultType</td><td>返回结果类型</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--resultMap标签有autoMapping属性, 默认是true--&gt;</span><br>    <span class="hljs-comment">&lt;!--autoMapping属性默认会忽略大小写区别--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lee.szdx03.bean.StudentBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuMap&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;stuName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllStu&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stuMap&quot;</span>&gt;</span><br>        select * from student_info<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Mapper.xml中有4种statement语句: create update select delete</p><p>statemtn语句的id都应该绑定Mapper接口中对应的方法</p><blockquote><p>statement语句的parameterType和resultType显示指定时必须与绑定的接口方法的形参或返回值类型相同, 不显示指定时会自动绑定</p></blockquote><p><strong>mybatis中ORM的体现</strong></p><ol><li>一行记录对应一个Bean对象</li><li>一个字段对应Bean的一种属性</li><li>一张表对应一个Bean类</li></ol><blockquote><p>所有持久层框架都遵循ORM设计</p></blockquote><p><strong>注意Mybatis进行增删改操作后要调用SqlSession的commit方法才能将修改提交到数据库中</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Oracle</title>
    <link href="/2022/11/03/Oracle/"/>
    <url>/2022/11/03/Oracle/</url>
    
    <content type="html"><![CDATA[<h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><p>Oracle体系:</p><p>Oracle是一个关系型数据库, 关系型数据库的三特性:</p><ol><li>结构型</li><li>易操作性</li><li>完整性规则</li></ol><p>Oracle有三种访问&#x2F;操作数据的方法:</p><ol><li>SQL: 关系型数据库的通用操作语言</li><li>PLSQL: PLSQL是对SQL的扩展语言,支持函数 数据类型 变量 子程序 触发器等编程特性</li><li>Java: Oracle数据库可以存储java编写的存储过程,并且plsql和java程序可以互相调用</li></ol><p>Oracle存储结构: </p><p>物理存储结构(文件):</p><ol><li>数据文件</li><li>控制文件</li><li>联机重做日志文件</li></ol><p>逻辑存储结构:(从小到大)</p><ol><li>块</li><li>区</li><li>段</li><li>表空间:</li></ol><p>Oracle进程:</p><ol><li>客户端进程: 连接服务器进程</li><li>后台进程: 负责维护工作: 写日志 清理异常进程等</li><li>服务器进程: 与客户端进程进行交互, 接收客户端请求并执行任务</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2022/11/03/Nginx/"/>
    <url>/2022/11/03/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>nginx是一个静态网页服务器, 可以用于反向代理 负载均衡 动态静态资源分离</p><p>nginx特点: 专门为静态资源优化, 高性能 高效率, 可以用于高并发高负载的场景</p><p>nginx应用场景:</p><ol><li>静态资源服务器</li><li>代理服务器<ol><li>正向代理: 负责代理客户端对外的流量</li><li>反向代理: 负责代理服务器对外的流量<ol><li>负载均衡: 通过反向代理实现将客户端的请求分配给多个服务器</li><li>动静分离: 将动态资源请求和静态资源请求分配给不同的服务器</li></ol></li></ol></li></ol><p>nginx命令:</p><ol><li>nginx stop 关闭nginx</li><li>nginx start</li><li>nginx restart</li><li>nginx -s load nginx热重载配置, 会关闭正在连接的worker线程</li><li>nginx -v</li></ol><p>nginx.conf为配置文件 一般在&#x2F;etc&#x2F;nginx&#x2F;conf下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#nginx并发进程数</span><br>worker_processes 1;<br><br><span class="hljs-comment">#动态均衡</span><br>upstream myserver&#123;<br><span class="hljs-comment">#weight是权重, 默认为1</span><br>        server 127.0.0.1:6060 weight=2;<br>        server 127.0.0.1:6061;<br>&#125;<br>events&#123;<br><span class="hljs-comment">#每个nginx进程的最大用户连接数</span><br><span class="hljs-comment">#默认其最大值为1024</span><br>worker_connections 1024;<br>&#125;<br>http&#123;<br>server&#123;<br>location / &#123;<br>//设置要转发给的upstream<br>                proxy_pass http://myserver;<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>nginx提供了4种负载均衡的方式:</p><table><thead><tr><th>负载均衡方式</th><th>作用</th></tr></thead><tbody><tr><td>轮询（默认）</td><td>默认， 按照请求时间顺序来轮询, 会自动剔除失效的服务器</td></tr><tr><td>权重轮询（weight）</td><td>根据权重来分配访问比例， 权重一般对应服务器的性能</td></tr><tr><td>ip_hash轮询</td><td>根据ip的hash值来轮询对应的服务器， 可以解决session问题</td></tr><tr><td>fair</td><td>第三方智能负载均衡模块， 根据服务器响应时间， 页面大小等因素</td></tr></tbody></table><p>nginx.conf组成部分</p><ol><li>全局块: </li><li>events块: </li><li>http块: <ol><li>server块</li><li>location块<ol><li>设置不同的url匹配</li></ol></li></ol></li></ol><p>location后的url匹配语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">location [=|~|~*|^~] url&#123;&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>匹配符</th><th>作用</th></tr></thead><tbody><tr><td>&#x3D;</td><td>url匹配不使用正则匹配, 使用字符串严格匹配</td></tr><tr><td>^~</td><td>url匹配不使用正则匹配, 使用字符串模糊匹配</td></tr><tr><td>~</td><td>使用正则匹配, 区分大小写</td></tr><tr><td>~*</td><td>使用正则匹配, 不区分大小写</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RBAC 角色权限控制</title>
    <link href="/2022/11/03/RBAC%20%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/11/03/RBAC%20%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="RBAC-角色访问控制"><a href="#RBAC-角色访问控制" class="headerlink" title="RBAC 角色访问控制"></a>RBAC 角色访问控制</h1><p>RBAC: 基于角色的访问控制(Role Based Access Control)</p><p>RBAC是将用户与角色关联, 然后基于角色进行权限管理. 构成了用户-角色-权限的授权模型, 其中用户对角色  角色对权限都是多对多的关系</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS</title>
    <link href="/2022/11/03/JS/"/>
    <url>/2022/11/03/JS/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>js是一种面向对象的解释性编程语言, 但是与java不同在于js程序以原型(prototype)为单位, 而java以类为单位, 并且java是一种半编译半解释的编程语言</p><p>特点:</p><ol><li>脚本语言, 支持嵌入网页中执行</li><li>弱类型, 变量声明时不需要指定类型, 变量类型由赋予的值决定</li><li>语法简单, 不严格</li><li>用于实现网页的动态效果以及服务器通信</li></ol><p>js的版本对应ES标准的版本</p><p>前端常用的ES版本为ES5和ES6</p><p><strong>数据类型</strong></p><p>js的数据类型有三种: 简单数据类型 复合数据类型 特殊数据类型</p><ol><li>简单数据类型: 数值 布尔 字符串</li><li>复合数据类型: 数组 函数 对象</li><li>特殊数据类型: NaN null undefined(特殊情况下的数据)</li></ol><p><strong>声明变量</strong></p><p>可以用var或let来声明变量, const声明常量</p><p>var可以重复声明同名的变量</p><p>而用let声明的变量无法被重复声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-comment">//不会报错</span><br><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">let</span> b;<br><span class="hljs-comment">//报错</span><br><span class="hljs-keyword">let</span> b;<br></code></pre></td></tr></table></figure><p>并且var是支持变量提升, 而let不支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// var 的情况</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// 输出undefined</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// let 的情况</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// 报错ReferenceError:Cannot access &#x27;bar&#x27; before initialization</span><br><span class="hljs-keyword">let</span> bar = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><strong>流程控制</strong></p><p><strong>js中的循环 选择语句与java完全相同</strong></p><p>js中默认执行顺序: 从上到小 从左到右(与java相同)</p><p>可以通过三种方法改变默认的顺序:</p><ol><li>选择结构: 单分支 双分支 多分支</li><li>循环</li><li>调用其他方法</li></ol><blockquote><p>基本和java相同</p></blockquote><p>选择结构: if if else if else if switch case</p><blockquote><p>语法和java相同</p></blockquote><p>循环结构:</p><p>while()for(;;)do{}while()</p><blockquote><p>语法和java相同</p></blockquote><p><strong>数组</strong></p><p>js中数组没有类型和长度的限制, 可以视为java中的集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//声明两个数组</span><br><span class="hljs-keyword">let</span> arrs=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> arrs2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//返回数组长度</span><br>arrs.<span class="hljs-property">length</span>;<br><span class="hljs-comment">//数组排序</span><br>arrs.<span class="hljs-title function_">sort</span>();<br><span class="hljs-comment">//用lambda表达式实现数组的遍历</span><br>arrs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(e))<br><span class="hljs-comment">//for循环遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arrs.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(arrs[i]);<br>&#125; <br><span class="hljs-comment">//增强for循环遍历数组</span><br><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> arrs)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(arrs[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>js中的函数(function)与java中的方法(method)相同</p><blockquote><p>声明自定义函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> 函数名(参数列表)&#123;&#125;<br></code></pre></td></tr></table></figure><p>js中函数的语法和java非常接近, 但是要注意函数名前要用function关键字, 并且返回类型不需要声明, 直接用return返回即可</p><p>三元判断符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(条件语句)?真返回值:假返回值<br></code></pre></td></tr></table></figure><p>lambda表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(形参列表)=&gt;&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>内置函数</strong></p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>调试</td><td>打印信息到浏览器的调试console</td></tr><tr><td>console.log()</td><td>debug级别</td></tr><tr><td>console.info()</td><td>info级别</td></tr><tr><td>console.warn()</td><td>警告级别</td></tr><tr><td>consolde.error()</td><td>错误级别</td></tr><tr><td></td><td></td></tr><tr><td>运算</td><td></td></tr><tr><td>isNaN()</td><td>判断变量是否为NaN</td></tr><tr><td>Number()</td><td>将字符串转换为数值</td></tr><tr><td>eval()</td><td>对字符串变量进行计算</td></tr><tr><td></td><td></td></tr><tr><td>定时运行</td><td></td></tr><tr><td>setTimeout()</td><td>延迟执行任务(只执行一次)</td></tr><tr><td>setInterval()</td><td>定时执行任务(循环)</td></tr><tr><td></td><td></td></tr><tr><td>document</td><td></td></tr><tr><td>document.getElementById(“id”)</td><td>获取对应id的元素, 可以通过该方法返回的对象来继续操作该元素</td></tr><tr><td>document.getElementById().value</td><td>获取value属性值</td></tr><tr><td>document.getElementById().textContent</td><td>获取元素包含的文字对象</td></tr><tr><td></td><td></td></tr><tr><td>弹窗</td><td></td></tr><tr><td>alert()</td><td>警告弹窗</td></tr><tr><td>prompt()</td><td>对话弹窗</td></tr><tr><td>confirm()</td><td>确认弹窗</td></tr><tr><td></td><td></td></tr><tr><td>日期</td><td></td></tr><tr><td>getTime()</td><td>获取时间(1970年)</td></tr><tr><td>getFullYear()</td><td>获取年份</td></tr><tr><td>getMonth()</td><td>获取月</td></tr><tr><td>getDay()</td><td>周</td></tr><tr><td>getDate()</td><td>日</td></tr><tr><td>getMinutes()</td><td>分支</td></tr><tr><td>getSeconds()</td><td>秒</td></tr><tr><td>getMilliseconds()</td><td>毫秒</td></tr></tbody></table><blockquote><p>日期函数使用示例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>date.<span class="hljs-title function_">getFullYear</span>();<br>date.<span class="hljs-title function_">getMonth</span>());<br>date.<span class="hljs-title function_">getDate</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>,date));<br></code></pre></td></tr></table></figure><blockquote><p>内嵌js示例</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> var1 = </span><br><span class="language-javascript">               <span class="hljs-comment">// document.getElementById(&quot;var1&quot;).value;</span></span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> var2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;var2&quot;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> result = var1 + var2;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> resultE = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>);</span><br><span class="language-javascript">            resultE.<span class="hljs-property">textContent</span> = var1 + var2;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(result);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>计算器<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;var1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;var1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;var2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;var2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFunction()&quot;</span>&gt;</span>加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>结果是:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>js对象用{}定义, 由变量和函数组成, 并且是一行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//注意对象体内的代码都是参数, 应该用逗号分隔, 不能用;分隔(视为一行代码)</span><br><span class="hljs-keyword">var</span> girl=&#123;<br>    <span class="hljs-title class_">Name</span>:<span class="hljs-string">&quot;孙尚香&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">hello</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(message);<br>    &#125;,<br>    <span class="hljs-attr">type</span>:<span class="hljs-number">1</span><br>&#125;;<br>girl.<span class="hljs-property">Name</span>;<br>girl.<span class="hljs-title function_">hello</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM: 浏览器对象模型(Browser Object Model)</p><p>BOM提供了变量和函数来读取或操作当前浏览器的信息</p><p>BOM有5种类型: WindowScreenLocationHistoryStorage</p><p>Storage分为LocalStorage(永久缓存)  SessionStorage(会话缓存, 关闭窗口会自动被删除)</p><p><strong>调用Window对象的属性或函数时可以省略window.前缀</strong></p><blockquote><p>BOM属性</p></blockquote><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>screen.width</td><td>屏幕宽度</td></tr><tr><td>screen.height</td><td>屏幕高度</td></tr><tr><td>screen.availWidth</td><td>有效宽度(去掉滚动条)</td></tr><tr><td>screen.availHeight</td><td>有效高度(去掉滚动条)</td></tr><tr><td>screen.colorDepth</td><td>颜色深度</td></tr><tr><td>screen.pixelDepth</td><td>像素深度</td></tr><tr><td></td><td></td></tr><tr><td>history.back()</td><td>返回上一页</td></tr><tr><td>history.forward()</td><td>前往下一页</td></tr><tr><td>history.go()</td><td>跳转到指定的页数</td></tr><tr><td></td><td></td></tr><tr><td>localStorage和sessionStorage的方法完全相同</td><td></td></tr><tr><td>localStorage.setItem(key,value)</td><td>设置key和value</td></tr><tr><td>localStorage.getItem(key)</td><td>根据key返回value</td></tr></tbody></table><blockquote><p>BOM方法</p></blockquote><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>window.</td><td></td></tr><tr><td>alert()</td><td>弹窗</td></tr><tr><td>confirm()</td><td>确认窗口</td></tr><tr><td>prompt()</td><td>对话窗口</td></tr><tr><td>open()</td><td>打开一个window</td></tr><tr><td>close()</td><td>关闭一个window</td></tr></tbody></table><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>JSON: js对象表示方法(JavaScript object notation)</p><p>json可以替代xml, 用于前后端交换信息</p><blockquote><p>json在js中的本质是一个有具体格式的字符串, 并且json字符串保存了单个或多个对象的信息</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user=&#123;<br>    <span class="hljs-attr">userName</span>:<span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>&#125;;<br><span class="hljs-comment">//将对象转换为json字符串</span><br><span class="hljs-keyword">let</span> json=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(user);<br><span class="hljs-keyword">let</span> userList=[&#123;&#125;,&#123;&#125;];<br><span class="hljs-comment">//将对象的集合转换为json字符串</span><br><span class="hljs-keyword">let</span> json2=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(userList);<br><span class="hljs-comment">//手动创建json字符串</span><br><span class="hljs-keyword">let</span> json3=<span class="hljs-string">&#x27;[&#123;&quot;userName&quot;:&quot;张三&quot;,&quot;age&quot;:18&#125;,&#123;&#125;]&#x27;</span>;<br><span class="hljs-comment">//将json字符串解析为集合</span><br><span class="hljs-keyword">let</span> datas=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json3);<br><span class="hljs-comment">//遍历集合</span><br>datas.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;<br>    e.<span class="hljs-property">userName</span>;<br>    e.<span class="hljs-property">age</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>js中的函数都是事件驱动模式</p><blockquote><p>js函数绑定对应的标签元素上的事件, 通过事件去触发运行</p></blockquote><p>事件有: 点击事件 键盘事件 表单事件 初始化事件</p><p><strong>event对象</strong></p><p>event对象可以获取到触发事件的信息</p><p>event.keyCode: 获取键盘触发事件的keyCode(被按下的键)</p><table><thead><tr><th>事件</th><th>触发条件</th></tr></thead><tbody><tr><td>点击事件</td><td></td></tr><tr><td>onclick</td><td>单击</td></tr><tr><td>ondblclick</td><td>双击</td></tr><tr><td>onmousedown</td><td>鼠标按下</td></tr><tr><td>onmouseup</td><td>鼠标放开</td></tr><tr><td>onmouseseenter</td><td>指针移动到元素上</td></tr><tr><td>onmouseleave</td><td>移出元素</td></tr><tr><td>onmouseover</td><td>指针移动到元素或子元素上</td></tr><tr><td>onmouseout</td><td>移出元素或子元素</td></tr><tr><td>键盘事件</td><td></td></tr><tr><td>onkeypress</td><td>点击了某个键</td></tr><tr><td>onkeydown</td><td>按下某个键</td></tr><tr><td>onkeyup</td><td>松开某个键</td></tr><tr><td>初始化事件</td><td></td></tr><tr><td>onload</td><td>页面初始化完成后执行(一般与body元素绑定)</td></tr><tr><td>表单事件</td><td></td></tr><tr><td>oninput</td><td>用户输入时触发</td></tr><tr><td>onchange</td><td>内容改变时触发</td></tr><tr><td>onsubmit</td><td>表单提交前触发</td></tr><tr><td>onreset</td><td>表单重置前触发</td></tr><tr><td>onsearch</td><td>搜索框输入内容时触发</td></tr><tr><td>表单焦点事件</td><td></td></tr><tr><td>onfocus</td><td>获取焦点时触发(点击输入框)</td></tr><tr><td>onblur</td><td>失去焦点时触发(离开输入框)</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在表单提交前进行校验, 只有返回true才会执行submit, false则不会submit</span><br>&lt;form action=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span> onsubmit=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h2><p>document提供了三种方法来获取html中的元素</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>getElementById()</td><td>获取对应id的第一个元素</td></tr><tr><td>getElementByName()</td><td>获取对应name的元素的集合</td></tr><tr><td>getElementByTagName()</td><td>获取对应tag的元素集合</td></tr></tbody></table><p>获取到元素后可以读取或修改元素的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;input&quot;</span>);<br><span class="hljs-comment">//通过style属性可以修改对应的css样式</span><br>input.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&quot;200px&quot;</span>;<br><span class="hljs-comment">//通过input元素的value属性可以获取用户的输入值</span><br><span class="hljs-keyword">let</span> value=input.<span class="hljs-property">value</span>;<br></code></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM: 文档对象模型(Document Object Model)</p><p>DOM会将整个网页从根节点开始解析为一个节点树</p><p><img src="/2022/11/03/JS/image-20220616153137248.png" alt="image-20220616153137248"></p><p>js可以通过DOM访问网页元素:</p><ol><li>修改元素文本内容(e.textContent)</li><li>修改元素属性(e.value)</li><li>修改元素的css样式(e.style.width)</li><li>动态绑定元素(根据元素的状态去绑定)</li><li>修改元素的父元素(parentNode)</li></ol><p><strong>动态绑定</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">myClick</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;点击1&quot;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        &lt;!--动态绑定需要在页面初始化之后--&gt;</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">onloadM</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> btn01 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn01&quot;</span>);</span><br><span class="language-javascript">            btn01.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;点击2&quot;</span>);</span><br><span class="language-javascript">            &#125;;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;onloadM()&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--行内事件绑定--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myClick()&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--动态绑定--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">btn01</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--行内嵌js--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;hello&#x27;);&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>变量</strong></p><p>js中的变量分为全局变量和局部变量</p><p>全局变量定义在函数外, 生命周期为整个页面的生命周期, 作用域为整个页面</p><p>局部变量定义在函数内, 生命周期为函数的生命周期, 作用域为函数内</p><h1 id="CSS内联元素"><a href="#CSS内联元素" class="headerlink" title="CSS内联元素"></a>CSS内联元素</h1><p>html中的元素分为三类: 块状元素 内联元素 内敛块状元素</p><ol><li>块状元素: div p h1-h6</li><li>内联元素: a span br i em strong</li><li>内联块状元素: img input</li></ol><p>块状元素特点: </p><ol><li>独占一行(自动换行)</li><li>可以设置 width height line-height margin-top margin-bottom</li><li>默认宽度为父元素的100%</li></ol><p>内联元素特点:</p><ol><li>不换行</li><li>无法设置width height line-height margin-top margin-bottom</li><li>默认宽度会随包含的内容变化</li></ol><p><strong>可以通过css将标签改为块状元素或内联元素或内联块状元素</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">//改为块状元素<br><span class="hljs-attribute">display</span>:block<br>//改为内联元素<br>display:inline<br>//改为块状内联元素<br>display:inline-block<br></code></pre></td></tr></table></figure><p><strong>注意如果代码块不写在任何函数中, 将会在页面初始化之前就执行该代码</strong></p><p><strong>希望在页面初始化后执行代码需要绑定onload</strong></p><h1 id="regex-正则"><a href="#regex-正则" class="headerlink" title="regex(正则)"></a>regex(正则)</h1><p>正则表达式用于匹配字符串</p><p>正则表达式有7种组成部分</p><ol><li>普通字符: 数字 字母 下划线 汉字以及非特殊含义符号</li><li>转义字符: \n \t \r (在正则表达式中需要用\\表达(\))</li><li>标准字符集合: \d \w \s . \D \W \S</li><li>自定义字符集合: []</li><li>量词: {}</li><li>字符边界: ^ $</li><li>选择符: |(或者)</li></ol><table><thead><tr><th>符号</th><th>范围</th></tr></thead><tbody><tr><td>^</td><td>匹配一行的开头</td></tr><tr><td>$</td><td>匹配一行的结尾</td></tr><tr><td>\b</td><td>匹配单词结尾</td></tr><tr><td>\B</td><td>\b取反</td></tr><tr><td>\d</td><td>[0-9]</td></tr><tr><td>\w</td><td>[a-zA-Z0-9]</td></tr><tr><td>\s</td><td>空白字符</td></tr><tr><td>*</td><td>任意数量</td></tr></tbody></table><blockquote><p>js用正则</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/(^.*$)/</span>;<br><span class="hljs-keyword">if</span>(pattern.<span class="hljs-title function_">test</span>(tel.<span class="hljs-property">value</span>))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><blockquote><p>java用正则</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(^.*$)&quot;</span>;<br><span class="hljs-comment">//返回true或false</span><br>Pattern.compile(pattern).matcher(str).matches();<br></code></pre></td></tr></table></figure><h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>通过axios库提供的方法可以实现依靠json格式进行前端通信</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--导入axios库--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><p>json是一种数据格式,其主体由对象: {“属性名” : “属性值”}组成, 也被称为键值对</p><p>属性值的类型有数值 字符串 数组[] 嵌套子对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">myObj = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;网站&quot;</span>,<br>    <span class="hljs-string">&quot;num&quot;</span>:<span class="hljs-number">3</span>,<br>    <span class="hljs-string">&quot;sites&quot;</span>:[ <span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span> ]<br>&#125;;<br><span class="hljs-comment">//可以通过js的delete方法删除数组中的元素, 但是delete并非完全删除, 仅仅将元素值删除, 其内存空间仍保留着(undefined状态)</span><br><span class="hljs-keyword">delete</span> myObj.<span class="hljs-property">sites</span>[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Elastic</title>
    <link href="/2022/11/03/Elastic/"/>
    <url>/2022/11/03/Elastic/</url>
    
    <content type="html"><![CDATA[<h1 id="Elastic"><a href="#Elastic" class="headerlink" title="Elastic"></a>Elastic</h1><p>ElasticSearch是基于Luncene开发的分布式全文搜索引擎框, 使用RESTful API进行封装</p><blockquote><p>luncene是使用java开发的搜索框架</p></blockquote><p>ES只能对ES内部的数据进行搜索, 因此在使用es搜索前, 必须先将数据存入es中</p><p>es基于luncene实现数据存储</p><blockquote><p>mysql和es的数据储存和操作语句对比</p></blockquote><table><thead><tr><th>Mysql</th><th>Elastic</th><th>对比</th></tr></thead><tbody><tr><td>table</td><td>index(indices)</td><td>索引是文档的集合</td></tr><tr><td>row</td><td>document</td><td>文档以json的格式保存, 代表一条数据</td></tr><tr><td>column</td><td>field</td><td>字段</td></tr><tr><td>constraint</td><td>mapping</td><td>映射相当于数据库中的约束</td></tr><tr><td>sql</td><td>dsl</td><td>es使用(json风格)dsl语句对数据进行增删改查</td></tr></tbody></table><p>mysql和es的优缺点对比</p><ol><li>mysql: 基于事务操作数据, 确保数据安全和一致性, 但是大数据查询效率不高</li><li>elastic: 基于原子性操作数据</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2022/11/03/HTTP/"/>
    <url>/2022/11/03/HTTP/</url>
    
    <content type="html"><![CDATA[<p>网络三要素: IP地址 端口 协议</p><blockquote><p>注意端口是和协议相配对的</p><p>TCP协议和UDP协议的端口相互独立, 互不影响</p></blockquote><p>常见程序的端口:</p><p>tomcat 8080 nginx  80 mysql 3306 redis 6379 ftp使用20和21</p><p>如何查看服务器上使用中的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ano <br>netstat -tulpn<br></code></pre></td></tr></table></figure><blockquote><p>xml中只能有双标签元素</p></blockquote><blockquote><p>但是在html中允许有单标签元素 &lt;标签 &#x2F;&gt;, 也被称为自闭合标签</p></blockquote><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>http协议的步骤:</p><ol><li>建立TCP连接(三次握手)</li><li>进行http通信(一次请求和一次响应配对)</li><li>关闭TCP连接</li></ol><p>http目前的主流版本是1.1</p><p>1.0和1.1的区别:</p><p>1.0一个连接只能进行一次http通信</p><p>1.1一个连接可以进行多次http通信(持久连接)</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p><strong>注意get请求的全部数据都编码在请求的url中, 并且遵循特殊的url编码规则, 在ASCII的基础上还额外支持各种语言和特殊符号</strong></p><p>请求方法(http method)有九种:GET POST PUT HEAD DELETE PATCH OPTIONS CONNECT TRACE</p><p>常用请求方式</p><table><thead><tr><th>请求方式</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取uri对应的资源</td></tr><tr><td>POST</td><td>向uri对应的接口提交数据, 交给服务器处理</td></tr><tr><td>PUT</td><td>向uri对应的地址上传资源</td></tr><tr><td>DELETE</td><td>请求删除uri对应的资源</td></tr><tr><td>PATCH</td><td>对uri对应的资源进行修改</td></tr><tr><td>TRACE</td><td>用于调试</td></tr></tbody></table><p>面试题: GET和POST的区别</p><table><thead><tr><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>reload不影响服务器</td><td>reload会导致数据被重复发送</td></tr><tr><td>可以被浏览器缓存</td><td>从不缓存</td></tr><tr><td>用户在地址栏输入url会默认使用GET方法</td><td></td></tr><tr><td>会保存到浏览器历史记录</td><td>不会被历史记录保存</td></tr><tr><td>有长度限制(因为get请求的数据是直接加到url上, url长度限制为2048)</td><td>无长度限制</td></tr><tr><td>用于请求数据返回</td><td>用于发送数据到服务器</td></tr><tr><td>请求内容是使用ASCII编码的字符</td><td>可以发送二进制文件</td></tr><tr><td>明文使用url发送, 不安全</td><td>发送数据不会显示在url中,, 较安全</td></tr></tbody></table><p><strong>面试</strong></p><p>PUT方法和POST方法相似, 但是put方法多次被调用时不会重复创建资源, 而post方法会重复创建资源</p><p>HEAD方法和GET方法类似, 但是head方法会导致服务器返回的响应中不包含body(主体) 因此head方法常用于get下载文件前检查请求是否增强</p><h2 id="请求和响应的区别"><a href="#请求和响应的区别" class="headerlink" title="请求和响应的区别"></a>请求和响应的区别</h2><p>http请求通常分为3部分: </p><ol><li>请求行(request line):包含 请求方法 请求的URI http协议版本</li><li>请求头:可以包含多个header</li><li>请求体:正文(body可以省略)</li></ol><p>http响应也分为3部分:</p><ol><li>状态行: 包括http协议版本, 状态码, 状态码描述信息</li><li>响应头: 可以包含多个header</li><li>响应体: (body可以省略)</li></ol><p><strong>请求header</strong></p><p>每个header都由字段和值组成, 类似于键值对的结构</p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>Accept</td><td>浏览器支持的数据类型</td></tr><tr><td>Accept-Charset</td><td>浏览器支持的编码</td></tr><tr><td>Host</td><td>用户想要访问的服务器</td></tr><tr><td>Referer</td><td>浏览器从哪个页面跳转过来</td></tr><tr><td>User-Agent</td><td>用户的标识信息(浏览器版本 操作系统版本)</td></tr><tr><td>Cookie</td><td>一般缓存在浏览器中, 用于身份验证</td></tr><tr><td>Cache-Control</td><td>浏览器的缓存控制机制</td></tr><tr><td>Connection</td><td>是否需要在请求完成后关闭连接</td></tr></tbody></table><p><strong>响应header</strong></p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>Server</td><td>服务器信息(类型, 版本)</td></tr><tr><td>Date</td><td>服务器响应时间</td></tr><tr><td>Expire</td><td>缓存过期时间</td></tr><tr><td>Location</td><td>重定向的url地址</td></tr><tr><td>Accept-Ranges</td><td>是否支持分段请求以及请求范围</td></tr><tr><td>Cache-Control</td><td>缓存控制</td></tr><tr><td>Content-Length</td><td>响应内容长度</td></tr><tr><td>Content-Type</td><td>响应内容类型</td></tr><tr><td>Set-Cookie</td><td>发送Cookie信息</td></tr><tr><td>Connection</td><td>是否需要持久连接</td></tr></tbody></table><p>其中的Content-Type使用MIME类型表示</p><table><thead><tr><th>MIME类型</th></tr></thead><tbody><tr><td>text&#x2F;plain</td></tr><tr><td>text&#x2F;xml</td></tr><tr><td>text&#x2F;html</td></tr><tr><td>text&#x2F;css</td></tr><tr><td>image&#x2F;gif</td></tr><tr><td>image&#x2F;png</td></tr><tr><td>application&#x2F;javascript</td></tr><tr><td>application&#x2F;x-httpd-php</td></tr><tr><td>application&#x2F;rtf</td></tr><tr><td>application&#x2F;pdf</td></tr></tbody></table><p>浏览器遇到无法识别的MIME类型会默认执行下载操作</p><p>请求行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET /index.html /2022/11/03/HTTP/1.1<br><span class="hljs-comment">#请求方法请求的uriHTTP版本</span><br></code></pre></td></tr></table></figure><p>状态行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs BASH">HTTP/1.1 200 OK<br><span class="hljs-comment">#HTTP版本 状态码状态描述信息</span><br></code></pre></td></tr></table></figure><blockquote><p>状态码和状态描述信息是配对的</p></blockquote><p>状态码有五类:</p><table><thead><tr><th>分类</th><th>作用</th><th>级别</th></tr></thead><tbody><tr><td>1XX</td><td>需要客户端提交下一步请求</td><td>信息</td></tr><tr><td>2XX</td><td>成功处理请求</td><td>成功</td></tr><tr><td>3XX</td><td>重定向</td><td>重定向</td></tr><tr><td>4XX</td><td>客户端的请求有问题</td><td>客户端问题</td></tr><tr><td>5XX</td><td>服务器或网关有问题</td><td>服务端问题</td></tr></tbody></table><p>常见状态码</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>请求处理成功</td></tr><tr><td>301</td><td>返回一个新的永久地址</td></tr><tr><td>302</td><td>返回一个新的临时地址</td></tr><tr><td>401</td><td>未授权</td></tr><tr><td>403</td><td>请求被拒绝(一般是权限问题)</td></tr><tr><td>404</td><td>请求的资源不存在</td></tr><tr><td>499</td><td>请求超时</td></tr><tr><td>500</td><td>服务器内部错误</td></tr><tr><td>502</td><td>网关错误</td></tr><tr><td>504</td><td>网关超时</td></tr></tbody></table><h1 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h1><p>URI: 统一资源标识符</p><p>URL: 统一资源位置(地址)</p><blockquote><p>举例: 书籍的ISBN是URI但不是URL, ISBN标记了一本特定的书, 但是没有提供对应书籍的地址</p><p>图片网址是URL也是URI, 提供了一个图片的网络地址</p></blockquote><p>URI使用特定的语法规则来标识一个特定资源</p><p>而URL是一种特殊的URI, 除了标识资源还提供了对应资源的网络地址</p><p>URI在java中抽象为java.net.URI类</p><p>URL在java中抽象为java.net.URL</p><blockquote><p>java.net.URL被final修饰</p></blockquote><p>URL是一种特殊的URI</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#URI语法</span><br>模式:模式内容<br><span class="hljs-comment">#示例URI</span><br>jdbc:mysql://127.0.0.1:3306/test?useSSL=<span class="hljs-literal">false</span><br><span class="hljs-comment">#模式内容一般为层次结构</span><br>//接口地址/路径?参数=值&amp;其他参数<br></code></pre></td></tr></table></figure><p>URI的字符串中一般使用ASCII作为基础进行编码, 额外的字符需要使用16进制的UTF-8编码, 并且需要使用%作为转义字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#&quot;木&quot;的16进制UTF-8编码</span><br><span class="hljs-comment">#注意下面每个0x后对应8位2进制</span><br>0xE6 0x9C 0xA8<br><span class="hljs-comment">#转义后的URI字符串</span><br>%E6%9C%A8<br></code></pre></td></tr></table></figure><blockquote><p>在java中有URLEncoder或apache-codec等库提供了URL(URI)编码功能</p></blockquote><p>URL分为相对URL和绝对URL, 一个网站中的子链接可以继承父文档URL的部分信息</p><blockquote><p>以&#x2F;开头的相对URL代表其路径是相对于文档的根目录, 而不是继承当前文档的相对目录</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP详解</title>
    <link href="/2022/11/03/HTTP%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/11/03/HTTP%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP详解"><a href="#HTTP详解" class="headerlink" title="HTTP详解"></a>HTTP详解</h1><p>计算机网络的应用层协议</p><p>我们通常用各种模型将复杂的计算机网络进行分层</p><p>每一层都会有不同的协议</p><blockquote><p>最顶层的协议封装越好, 最方便编程</p><p>最底层</p></blockquote><p>越底层协议对整个网络的影响越大</p><p>翻墙时或公司内网会用到的VPN通常是处于网络层或数链层</p><p>TCP UDP这种协议是属于传输层</p><p>IPv4 IPv6协议属于网络层</p><p><img src="/2022/11/03/HTTP%E8%AF%A6%E8%A7%A3/image-20220711094837050.png" alt="image-20220711094837050"></p><p>而HTTP就是处于最顶层的应用层协议</p><p>应用层协议意味着我们进行软件编程时一般都是直接使用http协议</p><h2 id="IPv4-IPv6"><a href="#IPv4-IPv6" class="headerlink" title="IPv4 IPv6"></a>IPv4 IPv6</h2><p><img src="/2022/11/03/HTTP%E8%AF%A6%E8%A7%A3/IPv4-vs-IPv6.webp" alt="IPv4-vs-IPv6"></p><p>IPv4是一个32位的地址, 意味着它总共可以提供2^32, 大约是43亿个地址</p><p>实质上并不是所有地址都作为公网地址, 也就是互联网上面使用的地址, 因为还要将地址分为内网地址和公网地址</p><p>那个年代的手机</p><p><img src="http://www.netprolive.com/img/Dynatac-phone.jpg" alt="img"></p><p>2斤重 半小时电话就没电</p><p>那个年代的计算机</p><p><img src="/2022/11/03/HTTP%E8%AF%A6%E8%A7%A3/image-20220711102200873.png" alt="image-20220711102200873"></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>https的全称是带加密的http(http with encrypted)</p><p>它跟http协议的区别是https在http的基础上使用SSL安全协议来加密请求和响应</p><p><img src="/2022/11/03/HTTP%E8%AF%A6%E8%A7%A3/image-20220711094353470.png" alt="image-20220711094353470"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap面试题</title>
    <link href="/2022/11/03/HashMap%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/11/03/HashMap%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap面试题"><a href="#HashMap面试题" class="headerlink" title="HashMap面试题"></a>HashMap面试题</h1><p>Put操作步骤:</p><ol><li>索引数组初始化</li><li>计算数组下标index,根据key的hash值&#x2F;2 (位运算)</li><li>链表节点初始化(key不存在)</li><li>(key存在)hash冲突时, 判断key是否相等,相等时进行数据替换</li><li>不相等时 创建新的节点</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaGuide面试突击版</title>
    <link href="/2022/11/03/JavaGuide%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%89%88/"/>
    <url>/2022/11/03/JavaGuide%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaGuide面试突击版"><a href="#JavaGuide面试突击版" class="headerlink" title="JavaGuide面试突击版"></a>JavaGuide面试突击版</h1><p><strong>如何介绍自己做的项目:</strong></p><ol><li><p>对项⽬整体设计的⼀个感受（⾯试官可能会让你画系统的架构图）</p></li><li><p>在这个项⽬中你负责了什么、做了什么、担任了什么⻆⾊</p></li><li><p>从这个项⽬中你学会了那些东⻄，使⽤到了那些技术，学会了那些新技术的使⽤</p></li><li><p>你是如何协调项⽬组成员协同开发的或者在遇到某⼀个棘⼿的问题的时候你是如何解决的⼜或者 说你在这个项⽬⽤了什么技术实现了什么功能⽐如：优化了数据库的设计减少了冗余字段、⽤ redis 做缓存提⾼了访问速度、使⽤消息队列削峰和降流、进⾏了服务拆分并集成了 dubbo 和 nacos 等等</p></li><li><p>尽量准备好性能优化的手段介绍, 对项目性能进行压测</p></li></ol><p>JVM: JVM负责执行java字节码, 实现java一次编译到处运行的关键</p><p>JVM是一种规范, 不同的公司会有不同的JVM实现</p><p>目前通用的JVM为HotSpot VM</p><p>JVM对于热点代码(经常被调用的代码)引入了JIT编译器(just-in-time compliation)</p><p>JIT编译器属于运行时编译, 并且会将编译后的机器码保存下来, 后面的运行会直接使用</p><blockquote><p>java属于半编译版解释的语言</p></blockquote><p>HotSpot使用惰性评估, 将热点代码交给JIT编译为机器码并保存, 提高运行效率</p><blockquote><p>JDK9中引入了AOT编译模式, 直接将字节码编译为机器码, 与JIT的预热编译不同</p></blockquote><p>由于需要使用动态代理等修改字节码的技术, 因此AOT编码模式不能普遍使用</p><p>编译型语言: 将源代码全部编译为机器码,  执行速度快, 开发效率低</p><p>解释型语言: 将源代码逐行解释为机器码并执行, 执行速度慢, 开发灵活</p><p><img src="/2022/11/03/JavaGuide%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%89%88/image-20220831102906485.png" alt="image-20220831102906485"></p><p>成员变量和局部变量的区别：</p><ol><li>语法：成员变量可以被访问控制修饰符修饰</li><li>储存空间： 类变量存储在元空间， 实例变量存储在堆内存， 局部变量存储在栈内存</li><li>生命周期： 类 对象 方法的生命周期</li><li>默认值： 成员变量会被自动初始化， 局部变量不会</li></ol><p>通常static变量用final修饰作为常量使用</p><p>静态方法只能访问静态成员</p><p>重载（overload）， 不同形参，视为不同方法</p><p>重写(override)， 同一个方法由于类型不同表现出多态性</p><p>重写的要求：</p><ol><li>方法名和参数列表相同 （同一个方法）</li><li>被private&#x2F;final&#x2F;static修饰的方法不能被子类重写， static修饰的方法可以被重写定义</li><li>构造方法无法重写（子类访问父类的构造方法需要使用super关键字）</li><li>返回类型相同（如果是引用类型可以为子类）</li></ol><p>java有8种基本数据类型:</p><p>4种整数型 byte short int long</p><p>2种浮点型 float double</p><p>1种字符型</p><p>1种布尔型</p><p><img src="/2022/11/03/JavaGuide%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB%E7%89%88/image-20220831201453313.png" alt="image-20220831201453313"></p><blockquote><p>注意java的基本数据类型大小都是固定的, 与平台无关</p></blockquote><p>包装类型只能用equals方法对比， 不能用&#x3D;&#x3D;</p><blockquote><p>因为包装类型是对象， 引用类型</p></blockquote><p>包装类型的拆装箱操作会影响系统性能， 尽量减少使用</p><p>基本类型和包装类型的区别:</p><ol><li>基本类型可以自动初始化为默认值, 引用类型默认为null</li><li>引用类型</li></ol><p>拆箱: valueOf()</p><p>装箱: 自动装箱(将基本数据类型赋值给包装类型) 手动装箱(强制类型转换)</p><p>包装类型的缓存机制:</p><p>用于提高性能, 4种整数包装类型都默认提供了[-128,127]的缓存数据</p><blockquote><p>注意缓存池都是针对字面量提供, 通过new创建的对象不会通过缓存池</p></blockquote><blockquote><p>String字面量也是有缓存池</p></blockquote><p>浮点数据类型由于范围过大所以没有缓存机制提供</p><p>浮点数为什么会有数据丢失问题?</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
